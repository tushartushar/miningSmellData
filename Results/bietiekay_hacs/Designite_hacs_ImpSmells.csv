Implementation smell,Namespace,Class,File,Method,Description
Long Method,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The method has 279 lines of code.
Long Method,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The method has 234 lines of code.
Long Method,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The method has 236 lines of code.
Long Method,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The method has 218 lines of code.
Long Method,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The method has 127 lines of code.
Long Method,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The method has 481 lines of code.
Long Method,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method has 1073 lines of code.
Long Method,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The method has 417 lines of code.
Long Method,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The method has 417 lines of code.
Complex Method,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,Cyclomatic complexity of the method is 41
Complex Method,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,hacs,DiffHouse,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\DiffSet\DiffHouse.cs,CalculateDifferences,Cyclomatic complexity of the method is 13
Complex Method,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,Cyclomatic complexity of the method is 28
Complex Method,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,Cyclomatic complexity of the method is 26
Complex Method,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,Cyclomatic complexity of the method is 14
Complex Method,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,hacs,HTTPProxy,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\HTTPProxy.cs,Proxy,Cyclomatic complexity of the method is 9
Complex Method,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_sensors,Cyclomatic complexity of the method is 8
Complex Method,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,Cyclomatic complexity of the method is 9
Complex Method,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,Cyclomatic complexity of the method is 28
Complex Method,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,process,Cyclomatic complexity of the method is 9
Complex Method,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,Cyclomatic complexity of the method is 111
Complex Method,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,Cyclomatic complexity of the method is 9
Complex Method,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateJSONDataActorStatus,Cyclomatic complexity of the method is 9
Complex Method,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,Cyclomatic complexity of the method is 9
Complex Method,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateNumericsJSONDataActorStatus,Cyclomatic complexity of the method is 9
Long Parameter List,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,AlarmingThread,The method has 5 parameters. Parameters: Logger' _AlarmQueue' sensor_data' actor_data' latitude_data
Long Parameter List,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,MAXMonitoringThread,The method has 5 parameters. Parameters: _Hostname' _Port' COL' EventQueue' UpdateTime
Long Parameter List,hacs,XS1MonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1MonitoringThread.cs,XS1MonitoringThread,The method has 5 parameters. Parameters: _ServerName' Logger' _Username' _Password' _Queue
Long Parameter List,hacs,GenerateSwimlane,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\SwimlaneJSON\GenerateSwimlane.cs,Generate,The method has 6 parameters. Parameters: ELVMAX' SensorDataStore' ObjectName' ObjectTypeName' StartDateTime' EndDateTime
Long Parameter List,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,LoggingThread,The method has 9 parameters. Parameters: _ServerName' Logger' _actor_store' _sensor_store' _unknown_store' _miataru_store' _Username' _Password' _ConfigurationCacheMinutes
Long Parameter List,hacs,MiataruDataObject,C:\repos\bietiekay_hacs\hacs\Devices\Miataru\MiataruDataObject.cs,MiataruDataObject,The method has 6 parameters. Parameters: _AccountName' _DeviceID' _TimeStamp' _Latitude' _Longitude' _AccuracyInMeters
Long Parameter List,hacs.xs1,XS1_DataObject,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1_DataObject.cs,XS1_DataObject,The method has 8 parameters. Parameters: _ServerName' _Name' _Type' _TypeName' _Timecode' _XS1ObjectID' _Value' _IgnoreForAlarming
Long Parameter List,hacs.xs1,XS1_DataObject,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1_DataObject.cs,XS1_DataObject,The method has 9 parameters. Parameters: _ServerName' _Name' _Type' _TypeName' _Timecode' _XS1ObjectID' _Value' OriginalStatement' _IgnoreForAlarming
Long Parameter List,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,HttpProcessor,The method has 11 parameters. Parameters: s' HTTP_DocumentRoot' Storage' LatitudeStorage' _XS1_Configuration' Logger' ELVMAXMonitoring' AuthEnabled' Uname' Pword' StartAddrFilter
Long Parameter List,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,HttpServer,The method has 12 parameters. Parameters: HTTP_Port' HTTP_ListeningIP' HTTP_DocumentRoot' _Storage' _LatitudeStorage' _XS1_Configuration' Logger' _ELVMAXMonitoringThread' AuthEnabled' Uname' Pword' StartAdrFilter
Long Parameter List,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateDataJSONOutputWithoutInterpolation,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateDataJSONOutput,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateJSONDataActorStatistics,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateDataNumericsJSONOutputWithoutInterpolation,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateDataNumericsJSONOutput,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateNumericsJSONDataActorStatistics,The method has 5 parameters. Parameters: DataType' ObjectTypeName' ObjectName' StartDateTime' EndDateTime
Long Parameter List,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The method has 6 parameters. Parameters: XS1_URL' Username' Password' actorname' preset' XS1_Configuration
Long Parameter List,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The method has 5 parameters. Parameters: XS1_URL' Username' Password' ActuatorID' PresetID
Long Identifier,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_actuators,The length of the parameter XS1_get_list_actuators_response is 31.
Long Identifier,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,,The length of the parameter AuthDisabledForAdressesThatStartWith is 36.
Long Identifier,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,,The length of the parameter AuthDisabledForAdressesThatStartWith is 36.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "                                                    TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);" is 146.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "                                                            SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality); " is 139.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "                                                    TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);" is 146.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "                                                            SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality); " is 139.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "									if ((_activator.device.ToUpper() == "NETWORKMONITOR")&&(dataobject.AlarmingType() == AlarmingEventType.NetworkingEvent))" is 120.
Long Statement,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The length of the statement  "									if ((_activator.device.ToUpper() == "GOOGLELATITUDE")&&(dataobject.AlarmingType() == AlarmingEventType.GoogleLatitudeEvent))" is 124.
Long Statement,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The length of the statement  "							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries);" is 122.
Long Statement,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The length of the statement  "								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries);" is 122.
Long Statement,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The length of the statement  "									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);" is 137.
Long Statement,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The length of the statement  "									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);" is 131.
Long Statement,hacs,HeatingThermostatDiff,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\DiffSet\HeatingThermostatDiff.cs,ToString,The length of the statement  "			//return string.Format ("[HeatingThermostatDiff: DeviceType={0}' DeviceName={1}' RoomID={2}' RoomName={3}' Mode={4}' Temperature={5}' LowBattery={6}]"' DeviceType' DeviceName' RoomID' RoomName' Mode' Temperature' LowBattery); " is 225.
Long Statement,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The length of the statement  "                                    ConsoleOutputLogger.WriteLine("Switching again actor " + status.ActorName + "(" + (DateTime.Now - status.LastUpdate).TotalMinutes + ")"); " is 137.
Long Statement,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The length of the statement  "                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "ON"' XS1_Configuration); " is 194.
Long Statement,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The length of the statement  "                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "OFF"' XS1_Configuration); " is 195.
Long Statement,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The length of the statement  "                                throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime")); " is 129.
Long Statement,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The length of the statement  "                                throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime")); " is 127.
Long Statement,hacs,ScriptingTimerThread,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerThread.cs,Run,The length of the statement  "                    // this is the main loop of all Scripting Timer Handling - so here is decided when something is to be switched on or off " is 120.
Long Statement,hacs,ScriptingTimerThread,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerThread.cs,Run,The length of the statement  "                    // # TimerName DateTime_Start(YearDoesn'tMatter) DateTime_End(YearDoesn'tMatter) Duration_Minutes_Start Duration_Minutes_End OperationMode SwitchName JitterYesNo MinimumOnTimeMinutes    " is 182.
Long Statement,hacs,ConsoleOutputLogger,C:\repos\bietiekay_hacs\hacs\ConsoleOutputLogger.cs,LogToFile,The length of the statement  "					WriteLineToScreenOnly("Opening Logfile: " + Properties.Settings.Default.LogfileDirectory + Path.DirectorySeparatorChar + GenerateLogFilename()); " is 144.
Long Statement,hacs,ConsoleOutputLogger,C:\repos\bietiekay_hacs\hacs\ConsoleOutputLogger.cs,LogToFile,The length of the statement  "					Logfile = new StreamWriter(Properties.Settings.Default.LogfileDirectory + Path.DirectorySeparatorChar + GenerateLogFilename()' true);" is 133.
Long Statement,hacs,ConsoleOutputLogger,C:\repos\bietiekay_hacs\hacs\ConsoleOutputLogger.cs,LogToFile,The length of the statement  "					Logfile = new StreamWriter(Properties.Settings.Default.LogfileDirectory + Path.DirectorySeparatorChar + GenerateLogFilename()' true);" is 133.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            ConsoleOutputLogger.WriteLine("home automation control server " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString());" is 146.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            TinyOnDiskStorage actor_data_store = new TinyOnDiskStorage(Properties.Settings.Default.DataDirectory + Path.DirectorySeparatorChar + "actor-data"' false' hacs.Properties.Settings.Default.DataObjectCacheSize);" is 208.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            TinyOnDiskStorage sensor_data_store = new TinyOnDiskStorage(Properties.Settings.Default.DataDirectory + Path.DirectorySeparatorChar + "sensor-data"' false' hacs.Properties.Settings.Default.DataObjectCacheSize);" is 210.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            TinyOnDiskStorage unknown_data_store = new TinyOnDiskStorage(Properties.Settings.Default.DataDirectory + Path.DirectorySeparatorChar + "unknown-data"' false' hacs.Properties.Settings.Default.DataObjectCacheSize);" is 212.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "				miataru_data_store = new TinyOnDiskStorage(Properties.Settings.Default.DataDirectory + Path.DirectorySeparatorChar + "miataru-data"' false' hacs.Properties.Settings.Default.DataObjectCacheSize);" is 194.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            ScriptingActorConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.ScriptingActorConfigurationFilename); " is 194.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            PowerSensorConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.PowerSensorConfigurationFilename); " is 188.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            ScriptingTimerConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.ScriptingTimerConfigurationFilename); " is 194.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            SensorCheckIgnoreConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.SensorCheckIgnoreFile); " is 183.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "            HTTPProxyConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.HTTPProxyConfigurationFilename);" is 184.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "                AlarmingConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.AlarmingConfigurationFilename);" is 182.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "				MiataruConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.MiataruConfigurationFilename); " is 180.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "                MQTTBindingConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.MQTTBindingConfigurationFile);" is 184.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "                NetworkMonitorConfiguration.ReadConfiguration(Properties.Settings.Default.ConfigurationDirectory + Path.DirectorySeparatorChar + Properties.Settings.Default.NetworkMonitorConfigurationFilename);" is 194.
Long Statement,hacs,Program,C:\repos\bietiekay_hacs\hacs\hacs.cs,Main,The length of the statement  "			LoggingThread _Thread = new LoggingThread(Properties.Settings.Default.XS1' ConsoleOutputLogger' actor_data_store' sensor_data_store' unknown_data_store'miataru_data_store'Properties.Settings.Default.Username'Properties.Settings.Default.Password'Properties.Settings.Default.ConfigurationCacheMinutes);" is 300.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "            ActorReswitching ActorReSwitch_ = new ActorReswitching(XS1_Configuration' ConsoleOutputLogger' TemporaryBlacklist'OnWaitOffLIst); " is 129.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "				SolarLog = new SolarLogMonitoringThread(Properties.Settings.Default.SolarLogURLDomain'ConsoleOutputLogger'SolarLog_DataQueue'Properties.Settings.Default.SolarLogUpdateIntervalMsec);" is 181.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "				ELVMax = new MAXMonitoringThread(Properties.Settings.Default.ELVMAXIP'Properties.Settings.Default.ELVMAXPort'ConsoleOutputLogger'MAX_DataQueue'Properties.Settings.Default.ELVMAXUpdateIntervalMsec);" is 197.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "			HttpServer httpServer = new HttpServer(Properties.Settings.Default.HTTPPort' Properties.Settings.Default.HTTPIP' Properties.Settings.Default.HTTPDocumentRoot' sensor_data_store' miataru_data_store' XS1_Configuration' ConsoleOutputLogger' ELVMax'Properties.Settings.Default.HTTPAuthEnabled'Properties.Settings.Default.HTTPAuthUsername'Properties.Settings.Default.HTTPAuthPassword'Properties.Settings.Default.HTTPAuthDisabledAdressStartsWith); " is 441.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "			    NetworkMonitoring monitor = new NetworkMonitoring(ConsoleOutputLogger'NetworkMonitor_Queue'Properties.Settings.Default.NetworkMonitorUpdateIntervalMsec);" is 153.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "				AlarmingThread alarmThread = new AlarmingThread(ConsoleOutputLogger'Alarming_Queue'sensor_data_store'actor_data_store'miataru_data_store);" is 138.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "				MiataruThread miataruThread = new MiataruThread (ConsoleOutputLogger' miataru_data_store' Properties.Settings.Default.MiataruUpdateTime);" is 137.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                    ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on actor " + Element.SensorToWatchName + " - " + Element.ActorToSwitchName + " to " + Element.ActionToRunName); " is 186.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration); " is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration); " is 204.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                                    ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration); " is 204.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration); " is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                                ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration); " is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration); " is 212.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                    ConsoleOutputLogger.WriteLine("Actor "+dataobject.Name+" is on the blacklist (ActorReSwitching) and therefore is ignored this time."); " is 134.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "									if (!dataobject.IgnoreForAlarming)	// this if for those events which get re-queued as xs1 events despite being for example elvmax events" is 136.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                            ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on sensor "+Element.SensorToWatchName+" - "+Element.ActorToSwitchName+" to "+Element.ActionToRunName); " is 177.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);" is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);" is 204.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                            ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);" is 204.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                                ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);" is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration); " is 203.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration); " is 212.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                                                ConsoleOutputLogger.WriteLine("Actorswitching Action not triggered since it's out of timespan. ("+Element.StartHour+"-"+Element.EndHour+")"); " is 141.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "								XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"heating_thermostat"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()'true);" is 245.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "									XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()+"' LowBattery"'true);" is 256.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "									XS1_DataObject boostmodeobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"boost"'DateTime.Now'_heating.RoomID'_heating.Temperature' _heating.ToString()+"' Boost"'true);" is 245.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()'true);" is 225.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()'true);" is 225.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()+"'LowBattery"'true);" is 238.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()+"'LowBattery"'true);" is 238.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                            XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "Pac"' ObjectTypes.Sensor' "Pac"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.Pac' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'Pac'" + solarlog_dataobject.Pac + "'" + solarlog_dataobject.DateAndTime.Ticks'true));" is 332.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "                            XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "aPdc"' ObjectTypes.Sensor' "aPdc"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.aPdc' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'aPdc'" + solarlog_dataobject.aPdc+"'"+solarlog_dataobject.DateAndTime.Ticks'true));" is 333.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'1'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Online"'true));" is 299.
Long Statement,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The length of the statement  "								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'0'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Offline"'true));" is 300.
Long Statement,hacs,MiataruThread,C:\repos\bietiekay_hacs\hacs\Devices\Miataru\MiataruThread.cs,Run,The length of the statement  "							MiataruDataObject retrievedData = new MiataruDataObject(Account.Name'Locations[0].Device'Locations[0].Timestamp'Locations[0].Latitude'Locations[0].Longitude'Locations[0].HorizontalAccuracy);" is 190.
Long Statement,hacs,MiataruThread,C:\repos\bietiekay_hacs\hacs\Devices\Miataru\MiataruThread.cs,Run,The length of the statement  "									ConsoleOutputLogger.WriteLine("Miataru: "+retrievedData.AccountName+" - "+retrievedData.Latitude+"'"+retrievedData.Longitude+"'"+retrievedData.AccuracyInMeters);" is 161.
Long Statement,hacs,MiataruThread,C:\repos\bietiekay_hacs\hacs\Devices\Miataru\MiataruThread.cs,Run,The length of the statement  "                                ConsoleOutputLogger.WriteLine("Miataru: " + retrievedData.AccountName + " - " + retrievedData.Latitude + "'" + retrievedData.Longitude + "'" + retrievedData.AccuracyInMeters);" is 175.
Long Statement,hacs.Devices.MQTTBinding,MQTT_Handling,C:\repos\bietiekay_hacs\hacs\Devices\MQTTBinding\MQTT_HandlingThread.cs,MQTT_Handle_Sensor,The length of the statement  "                    client.Publish(sensormap.mqtt' Encoding.UTF8.GetBytes(Convert.ToString(XS1SensorData.Value))' MqttMsgBase.QOS_LEVEL_EXACTLY_ONCE' true); " is 136.
Long Statement,hacs.Devices.MQTTBinding,MQTT_Handling,C:\repos\bietiekay_hacs\hacs\Devices\MQTTBinding\MQTT_HandlingThread.cs,MQTT_Handle_Actor,The length of the statement  "                    client.Publish(actormap.mqtt' Encoding.UTF8.GetBytes(Convert.ToString(XS1ActorData.Value))' MqttMsgBase.QOS_LEVEL_EXACTLY_ONCE' true); " is 134.
Long Statement,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The length of the statement  "            newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7])); " is 238.
Long Statement,hacs.xs1.configuration,XS1Configuration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1-Configuration.cs,getXS1ActuatorList,The length of the statement  "            WebRequest wrGetURL = WebRequest.Create("http://" + XS1_URL + "/control?user=" + Username + "&pwd=" + Password + "&callback=actorlist&cmd=get_list_actuators"); " is 159.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,ForwardToIndexHTML,The length of the statement  "			Output = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"><html><head><title>" + Message + "</title><meta http-equiv=\"refresh\" content=\"5; URL=/index.html\"></head><body><a href=\"/index.html\">" + Message + "</a></body></html>";" is 248.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,ForwardToLastPage,The length of the statement  "			Output = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"><html><head><title>" + Message + "</title><meta http-equiv=\"refresh\" content=\"5; URL=\"javascript:history.back(2)\"></head><body><a href=\"/index.html\">" + Message + "</a></body></html>";" is 265.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,ForwardToPage,The length of the statement  "			Output = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"><html><head><title>" + Message + "</title><meta http-equiv=\"refresh\" content=\"5; URL=" + URL + "\"></head><body><a href=\"" + URL + "\">" + Message + "</a></body></html>";" is 248.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "                            Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName); " is 120.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "                        XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password); " is 192.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "                        XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);" is 190.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "                        XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);" is 190.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "                                        ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);" is 180.
Long Statement,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The length of the statement  "					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows" is 121.
Long Statement,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,listen,The length of the statement  "                ConsoleOutputLogger.WriteLineToScreenOnly("[HTTP] AdministrationsoberflÃ¤che unter http://" + HTTPServer_ListeningIP+ ":" + HTTPServer_Port+ " erreichbar.");" is 156.
Long Statement,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,listen,The length of the statement  "                        HttpProcessor processor = new HttpProcessor(s' HTTPServer_DocumentRoot'Storage'LatitudeStorage'XS1_Configuration' ConsoleOutputLogger' ELVMAXMonitoringThread' AuthorizationEnabled'Username'Password' AuthDisabledForAdressesThatStartWith);" is 237.
Long Statement,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,listen,The length of the statement  "                        ConsoleOutputLogger.WriteLine("[FEHLER@HTTP] Kann nicht auf TCP-Port " + HTTPServer_Port+ " verbinden - wird vermutlich schon benutzt.");" is 137.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateDataJSONOutputWithoutInterpolation,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateDataJSONOutputWithoutInterpolation,The length of the statement  "			ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with "+SerializerCounter+" Elements and outputted "+OutputCounter+" Elements.");" is 147.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateDataJSONOutput,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The length of the statement  "                                                            //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")"); " is 136.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateJSONDataActorStatistics,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GenerateJSONDataActorStatistics,The length of the statement  "			ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with "+SerializerCounter+" Elements and outputted "+OutputCounter+" Elements.");" is 147.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateDataNumericsJSONOutputWithoutInterpolation,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateDataNumericsJSONOutputWithoutInterpolation,The length of the statement  "			ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with "+SerializerCounter+" Elements and outputted "+OutputCounter+" Elements.");" is 147.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateDataNumericsJSONOutput,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The length of the statement  "                                                            //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")"); " is 136.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateNumericsJSONDataActorStatistics,The length of the statement  "             *       data: [[1999' 3.0]' [2000' 3.9]' [2001' 2.0]' [2002' 1.2]' [2003' 1.3]' [2004' 2.5]' [2005' 2.0]' [2006' 3.1]' [2007' 2.9]' [2008' 0.9]]" is 144.
Long Statement,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GenerateNumericsJSONDataActorStatistics,The length of the statement  "			ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with "+SerializerCounter+" Elements and outputted "+OutputCounter+" Elements.");" is 147.
Long Statement,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The length of the statement  "            XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);" is 192.
Long Statement,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The length of the statement  "                            Output = ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);" is 189.
Long Statement,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The length of the statement  "            WebRequest wrGetURL = WebRequest.Create("http://" + XS1_URL + "/control?user=" + Username + "&pwd=" + Password + "&callback=setstate&cmd=set_state_actuator&number="+ActuatorID+"&function="+PresetID);" is 199.
Empty Catch Block,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The method has an empty catch block.
Empty Catch Block,hacs,SensorCheck,C:\repos\bietiekay_hacs\hacs\Devices\XS1\SensorCheck.cs,Run,The method has an empty catch block.
Empty Catch Block,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The method has an empty catch block.
Empty Catch Block,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,process,The method has an empty catch block.
Empty Catch Block,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The method has an empty catch block.
Magic Number,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The following statement contains a magic number: while (!Shutdown) 			{ 				try 				{ 					IAlarmingEvent dataobject = null; 					if (Alarming_Queue.TryDequeue(out dataobject)) 					{ 						// we should get events from all sorts of devices here - let's take them and check if they 						// are eventually matching the activators - if they do we check against the other 						// data storages to follow up with the alarms...  						// check if we find this in the alarms... 						foreach(Alarm _alarm in AlarmingConfiguration.Alarms.Alarms) 						{ 							foreach(Activator _activator in _alarm.activators) 							{ 								// activator names are case sensitive!!! 								if (dataobject.AlarmingName() == _activator.name) 								{ 									// we got a positive activator match here! 									// now check further circumstances... 									#region XS1 Events 									if ((_activator.device.ToUpper() == "XS1")&&(dataobject.AlarmingType() == AlarmingEventType.XS1Event)) 									{ 										// now we got an alarm triggering this activator and device... 										// check if the type matches... 										XS1_DataObject xs1_data = (XS1_DataObject)dataobject;  										if (_activator.type.ToUpper() == xs1_data.TypeName.ToUpper()) 										{ 											// for the value comparison convert the given value to a double... 											double comp_value = Convert.ToDouble(_activator.value); 											// it's the right typename... 											// now we gotta check for the right value there... 											Boolean alarm_activated = false; 											#region Activator Value Comparison 											switch(_activator.comparison) 											{ 												case "==": 													if (comp_value == xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case "<=": 													if (comp_value <= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case ">=": 													if (comp_value >= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 											} 											#endregion  											#region do the sensor and actor checks... 											// TODO: this is very rough - needs to be worked out more later on...  											// for the moment it is just a actor check - MORE HERE !!!!!!!! 											if (alarm_activated) 											{ 												foreach(Actorcheck _actor in _alarm.actorchecks) 												{ 													#region XS1 actors... 													if (_actor.device.ToUpper() == "XS1") 													{ 														if (KnownActorStates.KnownActorStatuses.ContainsKey(_actor.name)) 														{ 															// there's an actor... 															current_actor_status status = (current_actor_status)KnownActorStates.KnownActorStatuses[_actor.name]; 															// TODO: what about actor types!?  															if (_actor.value.ToUpper() == "ON") 															{ 																// so it should be on... 																if (status.Status != actor_status.On) 																{ 																	alarm_activated = false; 																}									 															} 															if (_actor.value.ToUpper() == "OFF") 															{ 																// so it should be off... 																if (status.Status != actor_status.Off) 																{ 																	alarm_activated = false; 																}									  															} 														} 													} 													#endregion 												} 											} 											#endregion  											if (alarm_activated) 											{ 												ConsoleOutputLogger.WriteLine("!!!! ALARM - "+_alarm.name+" - ALARM !!!!");                                                                                                    // authenticate Telekom                                                  if (Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                      TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);  												// send out the SMS... 												foreach(Smsrecipient recipient in _alarm.smsrecipients) 												{ 													ConsoleOutputLogger.WriteLine("Sending Alarm SMS to "+recipient.number+" for alarm "+_alarm.name);                                                        try                                                      {                                                          if (!Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                              SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality);                                                          else                                                              TelekomSMSGateway.Send(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber);                                                     }                                                     catch(Exception e)                                                      {                                                          ConsoleOutputLogger.WriteLine("SMS Sending Exception: " + e.Message);                                                      } 												} 											} 										} 									} 									#endregion  									#region ELVMAX Events 									if ((_activator.device.ToUpper() == "ELVMAX")&&(dataobject.AlarmingType() == AlarmingEventType.ELVMAXEvent)) 									{                                                                                   //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.device);  										// now we got an alarm triggering this activator and device... 										// check if the type matches... 										IDeviceDiffSet diffset = (IDeviceDiffSet)dataobject;                                            //ConsoleOutputLogger.WriteLine("ELVMAX: " + diffset.DeviceName);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + diffset.RoomName);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.type);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.name);   										// for now only shuttercontacts are interesting 										if ((_activator.type.ToUpper() == "SHUTTERCONTACT")&&(diffset.DeviceType == DeviceTypes.ShutterContact)&&                                             (_activator.name == diffset.DeviceName)) 										{                                              //ConsoleOutputLogger.WriteLine("ELVMAX Shuttercontact");  											ShutterContactDiff shutterdiff = (ShutterContactDiff)diffset;                                                //ConsoleOutputLogger.WriteLine("ELVMAX: "+shutterdiff.ToString());  											ShutterContactModes activatorstate = ShutterContactModes.unchanged; 											Boolean alarm_activated = false;  											if (_activator.value.ToUpper() == "OPEN") 												activatorstate = ShutterContactModes.open;  											if (_activator.value.ToUpper() == "CLOSED") 												activatorstate = ShutterContactModes.closed;  											if (activatorstate == shutterdiff.ShutterState) 												alarm_activated = true;  											#region do the sensor and actor checks... 											// TODO: this is very rough - needs to be worked out more later on...  											// for the moment it is just a actor check - MORE HERE !!!!!!!! 											if (alarm_activated) 											{ 												foreach(Actorcheck _actor in _alarm.actorchecks) 												{ 													#region XS1 actors... 													if (_actor.device.ToUpper() == "XS1") 													{ 														if (KnownActorStates.KnownActorStatuses.ContainsKey(_actor.name)) 														{ 															// there's an actor... 															current_actor_status status = (current_actor_status)KnownActorStates.KnownActorStatuses[_actor.name]; 															// TODO: what about actor types!? 															 															if (_actor.value.ToUpper() == "ON") 															{ 																// so it should be on... 																if (status.Status != actor_status.On) 																{ 																	alarm_activated = false; 																}									 															} 															if (_actor.value.ToUpper() == "OFF") 															{ 																// so it should be off... 																if (status.Status != actor_status.Off) 																{ 																	alarm_activated = false; 																}									 																 															} 														} 													} 													#endregion 												} 											} 											#endregion 											 											if (alarm_activated) 											{ 												ConsoleOutputLogger.WriteLine("!!!! ALARM - "+_alarm.name+" - ALARM !!!!");                                                    // authenticate Telekom                                                  if (Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                      TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);                                                                                                  // send out the SMS... 												foreach(Smsrecipient recipient in _alarm.smsrecipients) 												{ 													ConsoleOutputLogger.WriteLine("Sending Alarm SMS to "+recipient.number+" for alarm "+_alarm.name);                                                     try                                                     {                                                          if (!Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                              SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality);                                                          else                                                              TelekomSMSGateway.Send(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber);                                                     }                                                     catch(Exception e)                                                      {                                                          ConsoleOutputLogger.WriteLine("SMS Sending Exception: " + e.Message);                                                      } 												} 											}                                          } 									} 									#endregion 									// TODO: ------------------------------ 									#region SolarLog Events 									if ((_activator.device.ToUpper() == "SOLARLOG")&&(dataobject.AlarmingType() == AlarmingEventType.SolarLogEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 									#region Network Monitor Events 									if ((_activator.device.ToUpper() == "NETWORKMONITOR")&&(dataobject.AlarmingType() == AlarmingEventType.NetworkingEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 									#region Google Latitude Events 									if ((_activator.device.ToUpper() == "GOOGLELATITUDE")&&(dataobject.AlarmingType() == AlarmingEventType.GoogleLatitudeEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 								} 							} 						}      					}  				} 				catch (Exception e) 				{                    					//Shutdown = true; 					ConsoleOutputLogger.WriteLine("Alarming Exception: "+e.Message); 					ConsoleOutputLogger.WriteLine("Stopping Alarming Execution!"); 					Thread.Sleep(100); 				} 				 				Thread.Sleep(10); 			}
Magic Number,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The following statement contains a magic number: while (!Shutdown) 			{ 				try 				{ 					IAlarmingEvent dataobject = null; 					if (Alarming_Queue.TryDequeue(out dataobject)) 					{ 						// we should get events from all sorts of devices here - let's take them and check if they 						// are eventually matching the activators - if they do we check against the other 						// data storages to follow up with the alarms...  						// check if we find this in the alarms... 						foreach(Alarm _alarm in AlarmingConfiguration.Alarms.Alarms) 						{ 							foreach(Activator _activator in _alarm.activators) 							{ 								// activator names are case sensitive!!! 								if (dataobject.AlarmingName() == _activator.name) 								{ 									// we got a positive activator match here! 									// now check further circumstances... 									#region XS1 Events 									if ((_activator.device.ToUpper() == "XS1")&&(dataobject.AlarmingType() == AlarmingEventType.XS1Event)) 									{ 										// now we got an alarm triggering this activator and device... 										// check if the type matches... 										XS1_DataObject xs1_data = (XS1_DataObject)dataobject;  										if (_activator.type.ToUpper() == xs1_data.TypeName.ToUpper()) 										{ 											// for the value comparison convert the given value to a double... 											double comp_value = Convert.ToDouble(_activator.value); 											// it's the right typename... 											// now we gotta check for the right value there... 											Boolean alarm_activated = false; 											#region Activator Value Comparison 											switch(_activator.comparison) 											{ 												case "==": 													if (comp_value == xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case "<=": 													if (comp_value <= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case ">=": 													if (comp_value >= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 											} 											#endregion  											#region do the sensor and actor checks... 											// TODO: this is very rough - needs to be worked out more later on...  											// for the moment it is just a actor check - MORE HERE !!!!!!!! 											if (alarm_activated) 											{ 												foreach(Actorcheck _actor in _alarm.actorchecks) 												{ 													#region XS1 actors... 													if (_actor.device.ToUpper() == "XS1") 													{ 														if (KnownActorStates.KnownActorStatuses.ContainsKey(_actor.name)) 														{ 															// there's an actor... 															current_actor_status status = (current_actor_status)KnownActorStates.KnownActorStatuses[_actor.name]; 															// TODO: what about actor types!?  															if (_actor.value.ToUpper() == "ON") 															{ 																// so it should be on... 																if (status.Status != actor_status.On) 																{ 																	alarm_activated = false; 																}									 															} 															if (_actor.value.ToUpper() == "OFF") 															{ 																// so it should be off... 																if (status.Status != actor_status.Off) 																{ 																	alarm_activated = false; 																}									  															} 														} 													} 													#endregion 												} 											} 											#endregion  											if (alarm_activated) 											{ 												ConsoleOutputLogger.WriteLine("!!!! ALARM - "+_alarm.name+" - ALARM !!!!");                                                                                                    // authenticate Telekom                                                  if (Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                      TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);  												// send out the SMS... 												foreach(Smsrecipient recipient in _alarm.smsrecipients) 												{ 													ConsoleOutputLogger.WriteLine("Sending Alarm SMS to "+recipient.number+" for alarm "+_alarm.name);                                                        try                                                      {                                                          if (!Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                              SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality);                                                          else                                                              TelekomSMSGateway.Send(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber);                                                     }                                                     catch(Exception e)                                                      {                                                          ConsoleOutputLogger.WriteLine("SMS Sending Exception: " + e.Message);                                                      } 												} 											} 										} 									} 									#endregion  									#region ELVMAX Events 									if ((_activator.device.ToUpper() == "ELVMAX")&&(dataobject.AlarmingType() == AlarmingEventType.ELVMAXEvent)) 									{                                                                                   //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.device);  										// now we got an alarm triggering this activator and device... 										// check if the type matches... 										IDeviceDiffSet diffset = (IDeviceDiffSet)dataobject;                                            //ConsoleOutputLogger.WriteLine("ELVMAX: " + diffset.DeviceName);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + diffset.RoomName);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.type);                                          //ConsoleOutputLogger.WriteLine("ELVMAX: " + _activator.name);   										// for now only shuttercontacts are interesting 										if ((_activator.type.ToUpper() == "SHUTTERCONTACT")&&(diffset.DeviceType == DeviceTypes.ShutterContact)&&                                             (_activator.name == diffset.DeviceName)) 										{                                              //ConsoleOutputLogger.WriteLine("ELVMAX Shuttercontact");  											ShutterContactDiff shutterdiff = (ShutterContactDiff)diffset;                                                //ConsoleOutputLogger.WriteLine("ELVMAX: "+shutterdiff.ToString());  											ShutterContactModes activatorstate = ShutterContactModes.unchanged; 											Boolean alarm_activated = false;  											if (_activator.value.ToUpper() == "OPEN") 												activatorstate = ShutterContactModes.open;  											if (_activator.value.ToUpper() == "CLOSED") 												activatorstate = ShutterContactModes.closed;  											if (activatorstate == shutterdiff.ShutterState) 												alarm_activated = true;  											#region do the sensor and actor checks... 											// TODO: this is very rough - needs to be worked out more later on...  											// for the moment it is just a actor check - MORE HERE !!!!!!!! 											if (alarm_activated) 											{ 												foreach(Actorcheck _actor in _alarm.actorchecks) 												{ 													#region XS1 actors... 													if (_actor.device.ToUpper() == "XS1") 													{ 														if (KnownActorStates.KnownActorStatuses.ContainsKey(_actor.name)) 														{ 															// there's an actor... 															current_actor_status status = (current_actor_status)KnownActorStates.KnownActorStatuses[_actor.name]; 															// TODO: what about actor types!? 															 															if (_actor.value.ToUpper() == "ON") 															{ 																// so it should be on... 																if (status.Status != actor_status.On) 																{ 																	alarm_activated = false; 																}									 															} 															if (_actor.value.ToUpper() == "OFF") 															{ 																// so it should be off... 																if (status.Status != actor_status.Off) 																{ 																	alarm_activated = false; 																}									 																 															} 														} 													} 													#endregion 												} 											} 											#endregion 											 											if (alarm_activated) 											{ 												ConsoleOutputLogger.WriteLine("!!!! ALARM - "+_alarm.name+" - ALARM !!!!");                                                    // authenticate Telekom                                                  if (Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                      TelekomSMSGateway = new TelekomSendSMSGateway(Properties.Settings.Default.TelekomSMSClientID' Properties.Settings.Default.TelekomSMSClientSecret);                                                                                                  // send out the SMS... 												foreach(Smsrecipient recipient in _alarm.smsrecipients) 												{ 													ConsoleOutputLogger.WriteLine("Sending Alarm SMS to "+recipient.number+" for alarm "+_alarm.name);                                                     try                                                     {                                                          if (!Properties.Settings.Default.UseTelekomSMSInsteadofSMS77)                                                              SMSGateway.SendSMS(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber' false' false' SMSType.quality);                                                          else                                                              TelekomSMSGateway.Send(recipient.number' _alarm.message' Properties.Settings.Default.AlarmingSMS77SenderNumber);                                                     }                                                     catch(Exception e)                                                      {                                                          ConsoleOutputLogger.WriteLine("SMS Sending Exception: " + e.Message);                                                      } 												} 											}                                          } 									} 									#endregion 									// TODO: ------------------------------ 									#region SolarLog Events 									if ((_activator.device.ToUpper() == "SOLARLOG")&&(dataobject.AlarmingType() == AlarmingEventType.SolarLogEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 									#region Network Monitor Events 									if ((_activator.device.ToUpper() == "NETWORKMONITOR")&&(dataobject.AlarmingType() == AlarmingEventType.NetworkingEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 									#region Google Latitude Events 									if ((_activator.device.ToUpper() == "GOOGLELATITUDE")&&(dataobject.AlarmingType() == AlarmingEventType.GoogleLatitudeEvent)) 									{ 										// now we got an alarm triggering this activator and device... 									} 									#endregion 								} 							} 						}      					}  				} 				catch (Exception e) 				{                    					//Shutdown = true; 					ConsoleOutputLogger.WriteLine("Alarming Exception: "+e.Message); 					ConsoleOutputLogger.WriteLine("Stopping Alarming Execution!"); 					Thread.Sleep(100); 				} 				 				Thread.Sleep(10); 			}
Magic Number,hacs,MAXEncodeDecode,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXEncodeDecode.cs,ProcessLMessage,The following statement contains a magic number: if (Message.Length < 2) 				throw new MAXException("Unable to process message: "+Message);
Magic Number,hacs,MAXEncodeDecode,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXEncodeDecode.cs,ProcessMessage,The following statement contains a magic number: if (Message.Length < 2) 				throw new MAXException("Unable to process message: "+Message);
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				TcpClient client; 				NetworkStream stream;                 Dictionary<String' IMAXDevice> currentHouse = new Dictionary<string'IMAXDevice>();  				#region Update House 				try 				{ 					// now fill that with the initial handshake data...  					#region Initial connect and retrieving everything we get from the cube 					// network connect and first initialization 					client = new TcpClient(); 					client.Connect(Hostname'Port); 					stream = client.GetStream();  					// the read buffer (chosen quite big) 					byte[] myReadBuffer = new byte[4096*8]; 					List<String> Messages = new List<string>(); 					 					// to build the complete message 					StringBuilder myCompleteMessage = new StringBuilder(); 					int numberOfBytesRead = 0; 					 					MAXEncodeDecode DecoderEncoder = new MAXEncodeDecode(); 					keepRunning = true; 					// Incoming message may be larger than the buffer size. 					do 					{ 						myCompleteMessage = new StringBuilder(); 						stream.ReadTimeout = 1000; 						try 						{ 							numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 							myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 							 							Messages.Add(myCompleteMessage.ToString()); 						} 						catch(Exception) 						{ 							previousHouse = null; 							// everything to start 							theHouse = new House();  							keepRunning = false; 						} 					} 					while(keepRunning); 					#endregion  					ConsoleOutputLogger.WriteLine("ELV MAX Cube connected...");  					#region preprocess 					List<String> PreProcessedMessages = new List<string>(); 					foreach(String _Message in Messages) 					{ 						if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 						{ 							String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 							foreach(String pmessage in PMessages) 							{ 								PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 							} 						} 						else 							PreProcessedMessages.Add(_Message); 					}			 					#endregion  					#region process 					// Analyze and Output Messages' feed them to the decoder 					foreach(String _Message in PreProcessedMessages) 					{ 						//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 						//							if (Message != null) 						//							{ 						//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(Message.ToString()); 						//								ConsoleOutputLogger.WriteLine(""); 						//							}  						DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 					} 					#endregion  					//while(running) 					//{ 						// when we are here' we got a filled "theHouse" which does contain first hand L message information 						previousHouse = theHouse.GetAllDevicesInADictionary();  						#region send L: request and get all the feedback 						System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding(); 						byte[] args_data_buffer = enc.GetBytes("l:\r\n"); 						Messages = new List<string>(); 						keepRunning = true; 						// Incoming message may be larger than the buffer size.                         stream.Write(args_data_buffer' 0' args_data_buffer.Length); 						do 						{ 							myCompleteMessage = new StringBuilder(); 							stream.ReadTimeout = 1000; 							try 							{ 								numberOfBytesRead = stream.Read(myReadBuffer' 0' myReadBuffer.Length); 								myCompleteMessage.AppendFormat("{0}"' Encoding.ASCII.GetString(myReadBuffer' 0' numberOfBytesRead)); 								 								Messages.Add(myCompleteMessage.ToString()); 							} 							catch(Exception) 							{ 								keepRunning = false; 							} 						} 						while(keepRunning); 						#endregion 						 						#region preprocess 						PreProcessedMessages = new List<string>(); 						foreach(String _Message in Messages) 						{ 							if (_Message.Remove(_Message.Length-2).Contains("\r\n")) 							{ 								String[] PMessages = _Message.Remove(_Message.Length-2).Split(new char[1] { '\n' }'StringSplitOptions.RemoveEmptyEntries); 								foreach(String pmessage in PMessages) 								{ 									PreProcessedMessages.Add(pmessage.Replace("\r"'"")+"\r\n"); 								} 							} 							else 								PreProcessedMessages.Add(_Message); 						}			 						#endregion 						 						#region process 						// Analyze and Output Messages' feed them to the decoder 						foreach(String _Message in PreProcessedMessages) 						{ 							//IMAXMessage Message = DecoderEncoder.ProcessMessage(_Message.ToString()' theHouse); 							//							if (Message != null) 							//							{ 							//								ConsoleOutputLogger.WriteLine(_Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(Message.ToString()); 							//								ConsoleOutputLogger.WriteLine(""); 							//							}                             currentHouse = new Dictionary<string' IMAXDevice>(); 							DecoderEncoder.ProcessLMessage(_Message.ToString()' theHouse' currentHouse); 						} 						#endregion  						#region Diff the house 						if (previousHouse != null) 						{ 							// only if we already got two houses in here... 							List<IDeviceDiffSet> differences = DiffHouse.CalculateDifferences(previousHouse'currentHouse); 							if (differences.Count != 0) 							{ 								#region enqueue the difference-sets into the data queue 								foreach(IDeviceDiffSet _difference in differences) 								{ 									iQueue.Enqueue(_difference); 								} 								#endregion 							} 						} 						#endregion                         theHouse.UpdateDevices(currentHouse);  						// update appropriate devices and in given intervals output non updated 						TimeSpan _lastUpdate = DateTime.Now-LastReStoring; 						 						// auto-update every n ... minutes 						if (_lastUpdate.TotalSeconds > Properties.Settings.Default.ELVMAXSensorReStoringSec) 						{ 							LastReStoring = DateTime.Now;  							foreach(IMAXDevice _device in currentHouse.Values) 							{  								#region Heating Thermostat 								if (_device.Type == DeviceTypes.HeatingThermostat) 								{ 									HeatingThermostat _heating = (HeatingThermostat)_device; 									HeatingThermostatDiff _queueable = new HeatingThermostatDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_heating.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.Mode = _heating.Mode; 									_queueable.Temperature = _heating.Temperature;  									if (_queueable.Temperature != 0) 										iQueue.Enqueue(_queueable); 								} 								#endregion  								#region ShutterContact 								if (_device.Type == DeviceTypes.ShutterContact) 								{ 									ShutterContact _shutter = (ShutterContact)_device; 									ShutterContactDiff _queueable = new ShutterContactDiff(_device.Name'_device.AssociatedRoom.RoomID'_device.AssociatedRoom.RoomName);  									if (_shutter.LowBattery) 										_queueable.LowBattery = BatteryStatus.lowbattery; 									else 										_queueable.LowBattery = BatteryStatus.ok;  									_queueable.ShutterState = _shutter.ShutterState; 									iQueue.Enqueue(_queueable); 								} 								#endregion 							} 						}                          stream.Close();                          ConsoleOutputLogger.WriteLine("ELV MAX Cube disconnect..."); 						Thread.Sleep (MAXUpdateTime); 					//} 				} 				catch(Exception e) 				{ 					ConsoleOutputLogger.WriteLine(e.Message);                      Thread.Sleep(Properties.Settings.Default.ELVMAXReconnectTimeMsec);  					ConsoleOutputLogger.WriteLine("ELV MAX Cube reconnect..."); 					//stream.Close(); 					//client.Close(); 				} 				#endregion  			}
Magic Number,hacs,C_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\C_Message.cs,C_Message,The following statement contains a magic number: if (RAW_Message.Length < 2)  				throw new MAXException("Unable to process the RAW Message.");
Magic Number,hacs,C_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\C_Message.cs,C_Message,The following statement contains a magic number: String[] SplittedRAWMessage = RAW_Message.Remove(0'2).Split(new char[1] { ''' });
Magic Number,hacs,C_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\C_Message.cs,C_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 2)  			{  				RFAdress = SplittedRAWMessage[0];//Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[1]);  			}  			else  				throw new MAXException("Unable to process C Message. Not enough content.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Day = Int32.Parse(CubeDate.Substring (4'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Day = Int32.Parse(CubeDate.Substring (4'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Month = Int32.Parse(CubeDate.Substring(2'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Month = Int32.Parse(CubeDate.Substring(2'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Year = Int32.Parse(CubeDate.Substring(0'2)'System.Globalization.NumberStyles.HexNumber)+2000;
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Year = Int32.Parse(CubeDate.Substring(0'2)'System.Globalization.NumberStyles.HexNumber)+2000;
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Hour = Int32.Parse(CubeTime.Substring(0'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Minute = Int32.Parse(CubeTime.Substring(2'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,DecodeDateTime,The following statement contains a magic number: Int32 Minute = Int32.Parse(CubeTime.Substring(2'2)'System.Globalization.NumberStyles.HexNumber);
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (RAW_Message.Length < 2)  				throw new MAXException("Unable to process the RAW Message.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: String[] SplittedRAWMessage = RAW_Message.Remove(0'2).Split(new char[1] { ''' });
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				MAXserialNumber = SplittedRAWMessage[0];  				RFAddress = SplittedRAWMessage[1];//Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				FirmwareVersion = Int32.Parse(SplittedRAWMessage[2]'System.Globalization.NumberStyles.HexNumber);  				HTTPConnId = SplittedRAWMessage[4];  				CubeDateTime = DecodeDateTime(SplittedRAWMessage[7]'SplittedRAWMessage[8]);    				_House.CubeInformation = this;  			}  			else  				throw new MAXException("Unable to process H Message. Not enough content.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				MAXserialNumber = SplittedRAWMessage[0];  				RFAddress = SplittedRAWMessage[1];//Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				FirmwareVersion = Int32.Parse(SplittedRAWMessage[2]'System.Globalization.NumberStyles.HexNumber);  				HTTPConnId = SplittedRAWMessage[4];  				CubeDateTime = DecodeDateTime(SplittedRAWMessage[7]'SplittedRAWMessage[8]);    				_House.CubeInformation = this;  			}  			else  				throw new MAXException("Unable to process H Message. Not enough content.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				MAXserialNumber = SplittedRAWMessage[0];  				RFAddress = SplittedRAWMessage[1];//Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				FirmwareVersion = Int32.Parse(SplittedRAWMessage[2]'System.Globalization.NumberStyles.HexNumber);  				HTTPConnId = SplittedRAWMessage[4];  				CubeDateTime = DecodeDateTime(SplittedRAWMessage[7]'SplittedRAWMessage[8]);    				_House.CubeInformation = this;  			}  			else  				throw new MAXException("Unable to process H Message. Not enough content.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				MAXserialNumber = SplittedRAWMessage[0];  				RFAddress = SplittedRAWMessage[1];//Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				FirmwareVersion = Int32.Parse(SplittedRAWMessage[2]'System.Globalization.NumberStyles.HexNumber);  				HTTPConnId = SplittedRAWMessage[4];  				CubeDateTime = DecodeDateTime(SplittedRAWMessage[7]'SplittedRAWMessage[8]);    				_House.CubeInformation = this;  			}  			else  				throw new MAXException("Unable to process H Message. Not enough content.");
Magic Number,hacs,H_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\H_Message.cs,H_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				MAXserialNumber = SplittedRAWMessage[0];  				RFAddress = SplittedRAWMessage[1];//Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				FirmwareVersion = Int32.Parse(SplittedRAWMessage[2]'System.Globalization.NumberStyles.HexNumber);  				HTTPConnId = SplittedRAWMessage[4];  				CubeDateTime = DecodeDateTime(SplittedRAWMessage[7]'SplittedRAWMessage[8]);    				_House.CubeInformation = this;  			}  			else  				throw new MAXException("Unable to process H Message. Not enough content.");
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: if (RAW_Message.Length < 2) 				throw new MAXException("Unable to process the RAW Message.");
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: RawMessageDecoded = Base64.Decode(RAW_Message.Remove(0'2));
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder(); 				 				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5]; 				 				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0'); 				 				Int32 Cursor = 7;	// the current position' skipping ?1' 				 				String RFAddress = sb.ToString(); 				 				#region look for this RF Adress in the House's device list                  List<IMAXDevice> AllDevices = _theHouse.GetAllDevices();                  IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{                          if (_device.Type == DeviceTypes.HeatingThermostat)                          {                              foundDevice = new HeatingThermostat();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }                          if (_device.Type == DeviceTypes.ShutterContact)                          {                              foundDevice = new ShutterContact();                              foundDevice.AssociatedRoom = _device.AssociatedRoom;                              foundDevice.Name = _device.Name;                              foundDevice.RFAddress = _device.RFAddress;                              foundDevice.SerialNumber = _device.SerialNumber;                          }  						break; 					} 				} 				#endregion 				 				if (foundDevice != null) 				{ 					// remove the device from the house to add it later again... 					DevicesInThisMessage.Add(foundDevice); 					 					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.Mode = ThermostatModes.automatic; 							break; 						case "01": 							KnownDevice.Mode = ThermostatModes.manual; 							break; 						case "10": 							KnownDevice.Mode = ThermostatModes.vacation; 							break; 						case "11": 							KnownDevice.Mode = ThermostatModes.boost; 							break;	 						default: 							break; 						} 						#endregion 						 						#endregion 						 						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++;                            OutputDeviceList.Add(KnownDevice.SerialNumber'KnownDevice); 					} 					#endregion 					 					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 						 						#region get all those flags out of Data1 and Data2 						 						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion 						 						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion 						 						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion 						 						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion 						 						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion 						 						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion 						 						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion 						 						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7]; 						 						switch(ModeValue) 						{ 						case "00": 							KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 						case "10": 							KnownDevice.ShutterState = ShutterContactModes.open; 							break; 						default: 							break; 						} 						#endregion 						 						#endregion                            OutputDeviceList.Add(KnownDevice.SerialNumber' KnownDevice); 					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: if (RAW_Message.Length < 2) 				throw new MAXException("Unable to process the RAW Message.");
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: RawMessageDecoded = Base64.Decode(RAW_Message.Remove(0'2));
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The following statement contains a magic number: foreach(byte[] array in Tokenized) 			{ 				StringBuilder sb = new StringBuilder();  				for(int i=0;i<=2;i++) 				{ 					sb.Append(array[i]); 				} 				// get data 1 and data 2 out 				// on position 5'6 				byte Data1 = array[4]; 				byte Data2 = array[5];  				String binValueData1 = Convert.ToString(Data1'2); 				binValueData1 = binValueData1.PadLeft(8' '0'); 				String binValueData2 = Convert.ToString(Data2'2); 				binValueData2 = binValueData2.PadLeft(8' '0');  				Int32 Cursor = 7;	// the current position' skipping ?1'  				String RFAddress = sb.ToString();  				#region look for this RF Adress in the House's device list 				List<IMAXDevice> AllDevices = _House.GetAllDevices(); 				IMAXDevice foundDevice = null; 				foreach(IMAXDevice _device in AllDevices) 				{ 					if (_device.RFAddress == RFAddress) 					{ 						foundDevice = _device; 						break; 					} 				} 				#endregion  				if (foundDevice != null) 				{ 					DevicesInThisMessage.Add(foundDevice);  					#region HeatingThermostat 					if (foundDevice.Type == DeviceTypes.HeatingThermostat) 					{ 						HeatingThermostat KnownDevice = (HeatingThermostat)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.Mode = ThermostatModes.automatic; 							break; 							case "01": 								KnownDevice.Mode = ThermostatModes.manual; 							break; 							case "10": 								KnownDevice.Mode = ThermostatModes.vacation; 							break; 							case "11": 								KnownDevice.Mode = ThermostatModes.boost; 							break;	 							default: 							break; 						} 						#endregion  						#endregion  						// hurray' we've got a device we know how to handle B-) 						((HeatingThermostat)foundDevice).Temperature = array[Cursor]/2; 						Cursor++; 					} 					#endregion  					#region ShutterContact 					if (foundDevice.Type == DeviceTypes.ShutterContact) 					{ 						ShutterContact KnownDevice = (ShutterContact)foundDevice; 		 						#region get all those flags out of Data1 and Data2  						#region Valid 						if (binValueData1[3] == '1') 							KnownDevice.Valid = true; 						else 							KnownDevice.Valid = false; 						#endregion  						#region Error 						if (binValueData1[4] == '1') 							KnownDevice.Error = true; 						else 							KnownDevice.Error = false; 						#endregion  						#region IsAnswer 						if (binValueData1[5] == '1') 							KnownDevice.IsAnswer = true; 						else 							KnownDevice.IsAnswer = false; 						#endregion  						#region LowBattery 						if (binValueData2[0] == '1') 							KnownDevice.LowBattery = true; 						else 							KnownDevice.LowBattery = false; 						#endregion  						#region LinkError 						if (binValueData2[1] == '1') 							KnownDevice.LinkError = true; 						else 							KnownDevice.LinkError = false; 						#endregion  						#region PanelLock 						if (binValueData2[2] == '1') 							KnownDevice.PanelLock = true; 						else 							KnownDevice.PanelLock = false; 						#endregion  						#region GatewayOK 						if (binValueData2[3] == '1') 							KnownDevice.GatewayOK = true; 						else 							KnownDevice.GatewayOK = false; 						#endregion  						#region Mode 						String ModeValue = binValueData2[6]+""+binValueData2[7];  						switch(ModeValue) 						{ 							case "00": 								KnownDevice.ShutterState = ShutterContactModes.closed; 							break; 							case "10": 								KnownDevice.ShutterState = ShutterContactModes.open; 							break; 							default: 							break; 						} 						#endregion  						#endregion  					} 					#endregion 				} 			}
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (RAW_Message.Length < 2)  				throw new MAXException("Unable to process the RAW Message.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: String[] SplittedRAWMessage = RAW_Message.Remove(0'2).Split(new char[1] { ''' });
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,M_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\M_Message.cs,M_Message,The following statement contains a magic number: if (SplittedRAWMessage.Length >= 3)  			{  				Index = Int32.Parse(SplittedRAWMessage[0]'System.Globalization.NumberStyles.HexNumber);  				Count = Int32.Parse(SplittedRAWMessage[1]'System.Globalization.NumberStyles.HexNumber);  				RawMessageDecoded = Base64.Decode(SplittedRAWMessage[2]);    //				System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();  //				Console.WriteLine(enc.GetString (RawMessageDecoded));  //				StringBuilder hexlist = new StringBuilder();  //  //				foreach(Byte _byte in RawMessageDecoded)  //				{  //					hexlist.Append(_byte.ToString()+" ");  //				}    				Int32 Cursor = 2;    				// now go deeper  				Byte RoomCount = RawMessageDecoded[Cursor];  				Cursor++;    				#region Rooms  				// go through every room  				for(byte roomnumber=1;roomnumber<=RoomCount;roomnumber++)  				{  					Room newRoom = new Room(thisHouse);    					newRoom.RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					Byte RoomNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] RoomName = new byte[RoomNameLength];    					for(Byte j=0;j<=RoomNameLength-1;j++)  					{  						//RoomName.Append((char)RawMessageDecoded[Cursor]);  						RoomName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newRoom.RoomName = System.Text.Encoding.UTF8.GetString(RoomName);    					StringBuilder RFAddress_Buffer = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						RFAddress_Buffer.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newRoom.RFAddress = RFAddress_Buffer.ToString();//Int32.Parse(RFAddress_Buffer.ToString()'System.Globalization.NumberStyles.HexNumber);    					_House.Rooms.Add(newRoom);  				}    				#region Devices  				//newRoom.RFAddress = Int32.Parse(RFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);  				Byte DeviceCount = RawMessageDecoded[Cursor];  				Cursor++;  				// go through all the devices in here  				for(byte devicenumber=1;devicenumber<=DeviceCount;devicenumber++)  				{  					// read in the device  					IMAXDevice newDevice = new UnknownDevice();    					#region Determine DeviceType  					Byte DevType = RawMessageDecoded[Cursor];  					Cursor++;  					  					switch(DevType)  					{  						case 1:   							newDevice = new HeatingThermostat();  					        break;  					    case 2:  					        newDevice = new HeatingThermostatPlus();  					        break;  					    case 3:  					        newDevice = new WallMountedThermostat();  					        break;  					    case 4:  					        newDevice = new ShutterContact();  					        break;  					    case 5:  					        newDevice = new PushButton();  					        break;  					    default:  					        break;  					}  					#endregion    					StringBuilder DeviceRFAddress = new StringBuilder();  					for(Byte j=0;j<=3-1;j++)  					{  						DeviceRFAddress.Append(RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.RFAddress = DeviceRFAddress.ToString();//Int32.Parse(DeviceRFAddress.ToString()'System.Globalization.NumberStyles.HexNumber);    					StringBuilder DeviceSerialNumber = new StringBuilder();  					for(Byte j=0;j<=10-1;j++)  					{  						DeviceSerialNumber.Append((char)RawMessageDecoded[Cursor]);  						Cursor++;  					}  					newDevice.SerialNumber = DeviceSerialNumber.ToString();    					Byte DeviceNameLength = RawMessageDecoded[Cursor];  					Cursor++;    					byte[] DeviceName = new byte[DeviceNameLength];    					for(Byte j=0;j<=DeviceNameLength-1;j++)  					{  						DeviceName[j] = RawMessageDecoded[Cursor];  						Cursor++;  					}  					newDevice.Name = System.Text.Encoding.UTF8.GetString(DeviceName);    					Byte RoomID = RawMessageDecoded[Cursor];  					Cursor++;    					// add the device to the room  					foreach(Room newRoom in _House.Rooms)  					{  						if (newRoom.RoomID == RoomID)  						{  							newDevice.AssociatedRoom = newRoom;  							newRoom.Devices.Add(newDevice.SerialNumber'newDevice);  							break;  						}  					}  				}  				#endregion  				// add this Room to the M_Message-Structure  				#endregion  			}  			else  				throw new MAXException("Unable to process M Message. Not enough content.");
Magic Number,hacs,NetworkMonitoring,C:\repos\bietiekay_hacs\hacs\Devices\NetworkMonitoring\NetworkMonitoring.cs,Run,The following statement contains a magic number: while(running) 			{ 				foreach(NetworkMonitoringHost Host in NetworkMonitorConfiguration.NetworkHosts) 				{ 					// start pinging around 					ICMP_PingResult result = null; 					try 					{ 						result = pinger.Ping(Host.IPAdressOrHostname'1'500); 					} 					catch(Exception) 					{ 						//ConsoleOutputLogger.WriteLine("NetworkMonitor Exception: "+e.Message);                          result = new ICMP_PingResult();                          result.Status = ICMP_Status.TimeOut;                          result.hostIP = null;                     }  					// we got a result... 					if (result != null) 					{ 						// it's already in the list 						if (OnOfflineList.ContainsKey(Host.IPAdressOrHostname)) 						{ 							if (OnOfflineList[Host.IPAdressOrHostname] == true) // this one was online before... 							{ 								if (result.Status == ICMP_Status.TimeOut) 								{ 									// it's now offline... 									OnOfflineList[Host.IPAdressOrHostname] = false;  									NetworkMonitoringDataSet ds_result = new NetworkMonitoringDataSet(); 									 									ds_result.AverageRoundtripMS = result.AverageRoundtripMS; 									ds_result.Descriptor = Host.Descriptor; 									ds_result.HostnameIP = Host.IPAdressOrHostname; 									ds_result.Status = result.Status; 									ds_result.TimeOfMeasurement = result.TimeOfMeasurement; 									 									iQueue.Enqueue(ds_result); 								} 							} 							else 							{ 								if (result.Status == ICMP_Status.Success) 								{ 									// it's now online... 									OnOfflineList[Host.IPAdressOrHostname] = true; 									 									NetworkMonitoringDataSet ds_result = new NetworkMonitoringDataSet(); 									 									ds_result.AverageRoundtripMS = result.AverageRoundtripMS; 									ds_result.Descriptor = Host.Descriptor; 									ds_result.HostnameIP = Host.IPAdressOrHostname; 									ds_result.Status = result.Status; 									ds_result.TimeOfMeasurement = result.TimeOfMeasurement; 									 									iQueue.Enqueue(ds_result); 								} 							} 						} 						else 						{ 							if (result.Status == ICMP_Status.Success) 								OnOfflineList.Add(Host.IPAdressOrHostname'true); 							else 								OnOfflineList.Add(Host.IPAdressOrHostname'false);  							// enqueue 							NetworkMonitoringDataSet ds_result = new NetworkMonitoringDataSet(); 							 							ds_result.AverageRoundtripMS = result.AverageRoundtripMS; 							ds_result.Descriptor = Host.Descriptor; 							ds_result.HostnameIP = Host.IPAdressOrHostname; 							ds_result.Status = result.Status; 							ds_result.TimeOfMeasurement = result.TimeOfMeasurement; 							 							iQueue.Enqueue(ds_result); 						}  					} 				}  				Thread.Sleep (NetworkMonitorUpdateTime); 			}
Magic Number,hacs,NetworkMonitorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\NetworkMonitoring\NetworkMonitoringConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] ConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;    				foreach(String LineElement in ConfigFileContent)                  {                                            String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {   						NetworkMonitoringHost NewElement = new NetworkMonitoringHost();                            if (TokenizedLine.Length == 2)                          {                               NewElement.IPAdressOrHostname = TokenizedLine[0];  							NewElement.Descriptor = TokenizedLine[1];    							NetworkHosts.Add(NewElement);                          }                          else                              throw (new Exception("NetworkMonitoring Host Configuration File - Error in line "+LineNumber));                      }                  }              }              else              {  				throw (new Exception("NetworkMonitoring Host Configuration File  not found!"));              }
Magic Number,hacs,SolarLogMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\SolarLog\SolarLogMonitoringThread.cs,Run,The following statement contains a magic number: while(running) 			{ 				SolarLogDataSet data = SolarLogDataHelper.UpdateSolarLog(URL'ConsoleOutputLogger);  				if (data != null) 				{ 					if (LastDataSet == null) 					{ 						LastDataSet = data; 						iQueue.Enqueue(data); 					} 					else 					{ 						bool QueueIt = false;  						if (data.Pac != LastDataSet.Pac) 							QueueIt = true;  						if (data.aPdc != LastDataSet.aPdc) 							QueueIt = true;  						// if the last data set is older than 5 minutes' definitly queue this one... 						TimeSpan Diff = DateTime.Now-LastDataSet.DateAndTime; 						//if (Diff.TotalMinutes > Properties.Settings.Default.AutomatedSensorCheck_ResponseTimeWindow) 						if (Diff.TotalMinutes > 5) 							QueueIt = true;  						if (QueueIt)                         { 							iQueue.Enqueue(data);                              LastDataSet = data;                          } 					} 				}  				Thread.Sleep (SolarLogUpdateTime); 			}
Magic Number,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The following statement contains a magic number: while (!_Shutdown)             {                  // we start by                  // checking how much time passed since we were here the last time                  SinceLastCheckpoint = DateTime.Now - LastCheckpoint;                  //Console.WriteLine(SinceLastCheckpoint.TotalMinutes);                  // now we can do something every minute or so                  if (SinceLastCheckpoint.TotalMinutes >= hacs.Properties.Settings.Default.SwitchAgainCheckpointMinutes)                  {                      //ConsoleOutputLogger.WriteLine("Sensor Checkpoint");                      LastCheckpoint = DateTime.Now;                      #region Switch Actors again with same state                      // go through all the known actor status codes and try to send                      // them again to the actor one after another                                            // TODO: this try is just here to handle enum exceptions just in case' introduce locking!                      try                      {                          foreach (current_actor_status status in KnownActorStates.KnownActorStatuses.Values)                          {                              // if this actor was switched within the last configured minutes we switch it again to the exact same                              // state' just to make sure that they were successfully switched (just ON/OFF states)                              if ((DateTime.Now - status.LastUpdate).TotalMinutes <= hacs.Properties.Settings.Default.SwitchAgainTimeWindowMinutes)                              {                                  bool ignorethisone = false;                                  lock(OnWaitOffList)                                  {                                      if (OnWaitOffList.Contains(status.ActorName))                                      {                                          //Console.WriteLine(status.ActorName+" is on the ignorelist");                                          ignorethisone = true;                                      }                                  }                                                                    if (!ignorethisone)                                  {                                      ConsoleOutputLogger.WriteLine("Switching again actor " + status.ActorName + "(" + (DateTime.Now - status.LastUpdate).TotalMinutes + ")");                                      // yes' within the last given number of minutes                                      set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                      #region ON state                                      if (status.Status == actor_status.On)                                      {                                          // set on temporary blacklist                                          lock (TemporaryBlacklist)                                          {                                              TemporaryBlacklist.Add(status.ActorName);                                          }                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "ON"' XS1_Configuration);                                      }                                      #endregion                                        #region OFF state                                      if (status.Status == actor_status.Off)                                      {                                          // set on temporary blacklist                                          lock (TemporaryBlacklist)                                          {                                              TemporaryBlacklist.Add(status.ActorName);                                          }                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "OFF"' XS1_Configuration);                                      }                                      #endregion                                  }                              }                              Thread.Sleep(2000);                          }                      }                      catch(Exception)                      {                      }                      #endregion                  }   				Thread.Sleep(10000); // just check every 10 seconds... 			}
Magic Number,hacs,ActorReswitching,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ActorReSwitching.cs,Run,The following statement contains a magic number: while (!_Shutdown)             {                  // we start by                  // checking how much time passed since we were here the last time                  SinceLastCheckpoint = DateTime.Now - LastCheckpoint;                  //Console.WriteLine(SinceLastCheckpoint.TotalMinutes);                  // now we can do something every minute or so                  if (SinceLastCheckpoint.TotalMinutes >= hacs.Properties.Settings.Default.SwitchAgainCheckpointMinutes)                  {                      //ConsoleOutputLogger.WriteLine("Sensor Checkpoint");                      LastCheckpoint = DateTime.Now;                      #region Switch Actors again with same state                      // go through all the known actor status codes and try to send                      // them again to the actor one after another                                            // TODO: this try is just here to handle enum exceptions just in case' introduce locking!                      try                      {                          foreach (current_actor_status status in KnownActorStates.KnownActorStatuses.Values)                          {                              // if this actor was switched within the last configured minutes we switch it again to the exact same                              // state' just to make sure that they were successfully switched (just ON/OFF states)                              if ((DateTime.Now - status.LastUpdate).TotalMinutes <= hacs.Properties.Settings.Default.SwitchAgainTimeWindowMinutes)                              {                                  bool ignorethisone = false;                                  lock(OnWaitOffList)                                  {                                      if (OnWaitOffList.Contains(status.ActorName))                                      {                                          //Console.WriteLine(status.ActorName+" is on the ignorelist");                                          ignorethisone = true;                                      }                                  }                                                                    if (!ignorethisone)                                  {                                      ConsoleOutputLogger.WriteLine("Switching again actor " + status.ActorName + "(" + (DateTime.Now - status.LastUpdate).TotalMinutes + ")");                                      // yes' within the last given number of minutes                                      set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                      #region ON state                                      if (status.Status == actor_status.On)                                      {                                          // set on temporary blacklist                                          lock (TemporaryBlacklist)                                          {                                              TemporaryBlacklist.Add(status.ActorName);                                          }                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "ON"' XS1_Configuration);                                      }                                      #endregion                                        #region OFF state                                      if (status.Status == actor_status.Off)                                      {                                          // set on temporary blacklist                                          lock (TemporaryBlacklist)                                          {                                              TemporaryBlacklist.Add(status.ActorName);                                          }                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' status.ActorName' "OFF"' XS1_Configuration);                                      }                                      #endregion                                  }                              }                              Thread.Sleep(2000);                          }                      }                      catch(Exception)                      {                      }                      #endregion                  }   				Thread.Sleep(10000); // just check every 10 seconds... 			}
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,ScriptingActorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\ScriptingActorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] ActorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                  foreach(String LineElement in ActorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                           ScriptingActorElement NewElement = new ScriptingActorElement();                          if (TokenizedLine.Length == 5)                         {                              NewElement.SensorToWatchName = TokenizedLine[0];                             NewElement.SensorValue = Convert.ToDouble(TokenizedLine[1]);                             NewElement.ActorToSwitchName = TokenizedLine[2];                             if (TokenizedLine[3].ToUpper() == "ON")                                 NewElement.ActionToRunName = actor_status.On;                             else                                 if (TokenizedLine[3].ToUpper() == "OFF")                                     NewElement.ActionToRunName = actor_status.Off;                                 else                                     if (TokenizedLine[3].ToUpper() == "ONOFF")                                         NewElement.ActionToRunName = actor_status.OnOff;                                     else                                         if (TokenizedLine[3].ToUpper() == "ONWAITOFF")                                             NewElement.ActionToRunName = actor_status.OnWaitOff; 										else 											if (TokenizedLine[3].ToUpper() == "URL") 												NewElement.ActionToRunName = actor_status.URL;                                String[] FromToTime = TokenizedLine[4].Split(new char[1] { '-' });                              NewElement.StartHour = Convert.ToInt32(FromToTime[0]);                              NewElement.EndHour = Convert.ToInt32(FromToTime[1]);  							ScriptingActorActions.Add(NewElement);                         }                         else                             throw (new Exception("Scripting Actor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Scripting Actor Configuration File not found! (" + Configfilename+")"));             }
Magic Number,hacs,SensorCheck,C:\repos\bietiekay_hacs\hacs\Devices\XS1\SensorCheck.cs,Run,The following statement contains a magic number: while (!_Shutdown)             {                 try                 { 				    // check... 				    foreach(string SensorName in SensorCache.Keys) 				    { 					    temp = new TimeSpan(DateTime.Now.Ticks-SensorCache[SensorName].Ticks);  					    if (temp.TotalMinutes > hacs.Properties.Settings.Default.AutomatedSensorCheck_ResponseTimeWindow)                         {                             if (!SensorCheckIgnoreConfiguration.SensorCheckIgnoreList.Contains(SensorName)) 			                    ConsoleOutputLogger.WriteLine("#WARNING# An outdated sensor was detected: "+SensorName);                          } 				    }                  }                 catch(Exception)                  {                 }  				Thread.Sleep(Properties.Settings.Default.SensorCheckIntervalSec*1000); // just check every 6 seconds... 			}
Magic Number,hacs,XS1MonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1MonitoringThread.cs,Run,The following statement contains a magic number: while(running)  			{  				try  				{  					byte[] buf = new byte[8192];  					  					String HacsURL = "http://" + ServerName + "/control?callback=cname&cmd=subscribe&format=tsv";  					  					HttpWebRequest request = (HttpWebRequest)WebRequest.Create(HacsURL);  					request.Timeout = 60000;  					request.Credentials = new NetworkCredential(UserName'Password);  					  					String _UsernameAndPassword = UserName+ ":" + Password;  					Uri _URI = new Uri(HacsURL);  					  					CredentialCache _CredentialCache = new CredentialCache();  					_CredentialCache.Remove(_URI' "Basic");  					_CredentialCache.Add(_URI' "Basic"' new NetworkCredential(UserName' Password));  					String _AuthorizationHeader = "Basic " + Convert.ToBase64String(new ASCIIEncoding().GetBytes(_UsernameAndPassword));  					  					request.Headers.Add("Authorization"' _AuthorizationHeader);  					  					// execute the request  					HttpWebResponse response = (HttpWebResponse)request.GetResponse();  					if (response.StatusCode == HttpStatusCode.OK)  					{  						AcceptingCommands = true;  						ConsoleOutputLogger.WriteLineToScreenOnly("XS1 successfully connected!");  					}  					// we will read data via the response stream  					Stream resStream = response.GetResponseStream();  					  					string tempString = null;  					int count = 0;  					  					do  					{  						#region XS1 Receiving and Queue stuffing  						// fill the buffer with data  						count = resStream.Read(buf' 0' buf.Length);  						  						// make sure we read some data  						if (count != 0)  						{  							// translate from bytes to ASCII text  							tempString = Encoding.ASCII.GetString(buf' 0' count);  							XS1_DataObject dataobject = HandleXS1_TSV.HandleValue(tempString);  							dataobject.ServerName = ServerName;  							dataobject.OriginalXS1Statement = tempString;    							iQueue.Enqueue(dataobject);	// add it to the queue  						}					  						#endregion  					}  					while (count > 0); // any more data to read?  				}  				catch (Exception)  				{                     					AcceptingCommands = false;  					Thread.Sleep(1);  				}    			}
Magic Number,hacs,XS1MonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1MonitoringThread.cs,Run,The following statement contains a magic number: while(running)  			{  				try  				{  					byte[] buf = new byte[8192];  					  					String HacsURL = "http://" + ServerName + "/control?callback=cname&cmd=subscribe&format=tsv";  					  					HttpWebRequest request = (HttpWebRequest)WebRequest.Create(HacsURL);  					request.Timeout = 60000;  					request.Credentials = new NetworkCredential(UserName'Password);  					  					String _UsernameAndPassword = UserName+ ":" + Password;  					Uri _URI = new Uri(HacsURL);  					  					CredentialCache _CredentialCache = new CredentialCache();  					_CredentialCache.Remove(_URI' "Basic");  					_CredentialCache.Add(_URI' "Basic"' new NetworkCredential(UserName' Password));  					String _AuthorizationHeader = "Basic " + Convert.ToBase64String(new ASCIIEncoding().GetBytes(_UsernameAndPassword));  					  					request.Headers.Add("Authorization"' _AuthorizationHeader);  					  					// execute the request  					HttpWebResponse response = (HttpWebResponse)request.GetResponse();  					if (response.StatusCode == HttpStatusCode.OK)  					{  						AcceptingCommands = true;  						ConsoleOutputLogger.WriteLineToScreenOnly("XS1 successfully connected!");  					}  					// we will read data via the response stream  					Stream resStream = response.GetResponseStream();  					  					string tempString = null;  					int count = 0;  					  					do  					{  						#region XS1 Receiving and Queue stuffing  						// fill the buffer with data  						count = resStream.Read(buf' 0' buf.Length);  						  						// make sure we read some data  						if (count != 0)  						{  							// translate from bytes to ASCII text  							tempString = Encoding.ASCII.GetString(buf' 0' count);  							XS1_DataObject dataobject = HandleXS1_TSV.HandleValue(tempString);  							dataobject.ServerName = ServerName;  							dataobject.OriginalXS1Statement = tempString;    							iQueue.Enqueue(dataobject);	// add it to the queue  						}					  						#endregion  					}  					while (count > 0); // any more data to read?  				}  				catch (Exception)  				{                     					AcceptingCommands = false;  					Thread.Sleep(1);  				}    			}
Magic Number,hacs,HTTPProxyConfiguration,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\HTTPProxyConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] ProxyConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in ProxyConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ProxyElement NewElement = new ProxyElement();                            if (TokenizedLine.Length == 2)                          {                              NewElement.ActivationURL = TokenizedLine[0];  							NewElement.OutgoingMappingURL = TokenizedLine[1];                                                            ProxyElements.Add(NewElement);                          }                          else                              throw (new Exception("HTTPProxy Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("HTTPProxy Configuration File not found!"));              }
Magic Number,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_actuators,The following statement contains a magic number: Prepared = Prepared.Remove(Prepared.Length - 4' 4);
Magic Number,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_actuators,The following statement contains a magic number: Prepared = Prepared.Remove(Prepared.Length - 4' 4);
Magic Number,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_sensors,The following statement contains a magic number: Prepared = Prepared.Remove(Prepared.Length - 4' 4);
Magic Number,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_sensors,The following statement contains a magic number: Prepared = Prepared.Remove(Prepared.Length - 4' 4);
Magic Number,hacs,VirtualXS1,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProxy\VirtualXS1Sensors\VirtualXS1.cs,Inject_get_list_sensors,The following statement contains a magic number: foreach(IMAXDevice _device in devices)              {                  if (_device.Type == DeviceTypes.HeatingThermostat)                  {                      HeatingThermostat heating = (HeatingThermostat)_device;                        //heating.Temperature                      SensorJSON _newsensor = new SensorJSON();                        if (heating.Temperature == 4.0)                      {                          // this heatingthermostat is on "OFF"                          _newsensor.id = id;                          id++;                          _newsensor.name = heating.Name;                          _newsensor.type = "remotecontrol";                          _newsensor.unit = "boolean";                          _newsensor.value = 0.0; 						_newsensor.utime = heating.LastUpdate.JavaScriptTimestampNonMsec(); 					}                      else                      {                          //this is normal temperature                          _newsensor.id = id;                          id++;                          _newsensor.name = heating.Name;                          _newsensor.type = "temperature";                          _newsensor.unit = "Â°C";                          _newsensor.value = heating.Temperature; 						_newsensor.utime = heating.LastUpdate.JavaScriptTimestampNonMsec();                      }                        deserializedSensors.sensor.Add(_newsensor);                  }                    if (_device.Type == DeviceTypes.ShutterContact)                  {                      ShutterContact shutter = (ShutterContact)_device;                        SensorJSON _newsensor = new SensorJSON();                      _newsensor.id = id;                      id++;                      _newsensor.name = shutter.Name;                      _newsensor.type = "dooropen";                      _newsensor.unit = "boolean"; 					_newsensor.utime = shutter.LastUpdate.JavaScriptTimestampNonMsec();                       if (shutter.ShutterState == ShutterContactModes.open)                          _newsensor.value = 1.0;                      else                          _newsensor.value = 0.0;                        deserializedSensors.sensor.Add(_newsensor);                  }              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerConfiguration,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))              {                  // get all lines from the                   String[] TimerConfigFileContent = File.ReadAllLines(Configfilename);                  Int32 LineNumber = 0;                    foreach (String LineElement in TimerConfigFileContent)                  {                      String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                      LineNumber++;                        if (!LineElement.StartsWith("#"))                      {                            ScriptingTimerElement NewElement = new ScriptingTimerElement();                            if (TokenizedLine.Length == 9)                          {                              NewElement.TimerName = TokenizedLine[0];                                                            if (!DateTime.TryParse(TokenizedLine[1].Replace('_'' ' ')' out NewElement.Start))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse Start DateTime"));                              if (!DateTime.TryParse(TokenizedLine[2].Replace('_'' ' ')' out NewElement.End))                                  throw (new Exception("Scripting Timers Configuration File - Error in line " + LineNumber + " - Could not parse End DateTime"));                                NewElement.Duration_Start = Convert.ToInt32(TokenizedLine[3]);                              NewElement.Duration_End = Convert.ToInt32(TokenizedLine[4]);                                if (TokenizedLine[5].ToUpper() == "ONOFF")                                  NewElement.OperationMode = scripting_timer_operation_modes.OnOff;                                NewElement.SwitchName = TokenizedLine[6];                                if (TokenizedLine[7].ToUpper() == "YES")                                  NewElement.Jitter = true;                              else                                  NewElement.Jitter = false;                                NewElement.MinimumOnTime = Convert.ToInt32(TokenizedLine[8]);                                ScriptingTimerActions.Add(NewElement);                          }                          else                              throw (new Exception("Scripting Timer Configuration File - Error in line " + LineNumber));                      }                  }              }              else              {                  throw (new Exception("Scripting Timer Configuration File not found!"));              }
Magic Number,hacs,ScriptingTimerThread,C:\repos\bietiekay_hacs\hacs\ScriptingTimers\ScriptingTimerThread.cs,Run,The following statement contains a magic number: while (!Shutdown)             {                 try                 {                     // this is the main loop of all Scripting Timer Handling - so here is decided when something is to be switched on or off                      // # TimerName DateTime_Start(YearDoesn'tMatter) DateTime_End(YearDoesn'tMatter) Duration_Minutes_Start Duration_Minutes_End OperationMode SwitchName JitterYesNo MinimumOnTimeMinutes                         foreach (ScriptingTimerElement ScriptingTimer in ScriptingTimerConfiguration.ScriptingTimerActions)                      {                          // we got one timer' now we decide if this one is overdue                          if (TimerOverdue(ScriptingTimer))                          {                                                           }                        }                 }                 catch (Exception)                 {                                        Thread.Sleep(100);                 }                    Thread.Sleep(1);             }
Magic Number,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The following statement contains a magic number: while (!Shutdown)             {                 try                 { 					#region Handle XS1 events 					XS1_DataObject dataobject = null; 					if (XS1_DataQueue.TryDequeue(out dataobject)) 					{ 						if (dataobject.Type == ObjectTypes.Actor)                         {                             // Write to Disk                             lock(actor_data_store)                             {                                 actor_data_store.Write(dataobject.Serialize());                              }                              lock(KnownActorStates.KnownActorStatuses)                             {                                  bool usethisactor = true;                                  // check if this actor is on temporary blacklist (like when it was handled)                                  lock (TemporaryBlacklist)                                  {                                      if (TemporaryBlacklist.Contains(dataobject.Name))                                          usethisactor = false;                                      TemporaryBlacklist.Remove(dataobject.Name);                                  }                                   if (usethisactor)                                  { 									// if Alarming is enabled' queue this XS1 Event up for alarming... 									if (Properties.Settings.Default.AlarmingEnabled) 									{ 										Alarming_Queue.Enqueue(dataobject); 									}  									// this actor action did not result in any action hacs made - so we try to make the best out of it 									#region Scripting Handling 									// check if this sensor is something we should act uppon 									foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions) 									{                                              if (dataobject.Name == Element.SensorToWatchName)                                              {                                                  if (dataobject.Value == Element.SensorValue)                                                  {                                                      // obviously there is a ScriptingActorConfiguration entry                                                      // so we execute the actor preset                                                        set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                                      ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on actor " + Element.SensorToWatchName + " - " + Element.ActorToSwitchName + " to " + Element.ActionToRunName);                                                                                                            if (Element.isCurrentlyWithinStartEndHours())                                                      {                                                          #region Scripting Actor Actions                                                      if (Element.ActionToRunName == actor_status.URL)                                                      {                                                          ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                          // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                              try                                                          {                                                              WebClient client = new WebClient();                                                              client.Encoding = System.Text.Encoding.UTF8;                                                              String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                                ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                          }                                                          catch (Exception e)                                                          {                                                              ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                          }                                                      }                                                        // check what action is going to happen now...                                                      if (Element.ActionToRunName == actor_status.On)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                      }                                                        if (Element.ActionToRunName == actor_status.Off)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                            // remove from OnWaitOffList                                                          lock (OnWaitOffLIst)                                                          {                                                              if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                                  OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                          }                                                      }                                                        if (Element.ActionToRunName == actor_status.OnOff)                                                      {                                                          // look for the current status in the known actors table                                                          lock (KnownActorStates.KnownActorStatuses)                                                          {                                                              if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                              {                                                                  current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                                  if (Status.Status == actor_status.On)                                                                      ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                  else                                                                      if (Status.Status == actor_status.Off)                                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                              }                                                              else                                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                          }                                                      }                                                      if (Element.ActionToRunName == actor_status.OnWaitOff)                                                      {                                                          lock (OnWaitOffLIst)                                                          {                                                              ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                              OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                          }                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                                      }                                                      #endregion                                                      }                                                    }                                              } 									} 									#endregion                                        #region MQTT Handling Actor                                      if (Properties.Settings.Default.MQTTBindingEnabled)                                      {                                          MQTT_Binding.MQTT_Handle_Actor(dataobject);                                      }                                      #endregion                                        if (KnownActorStates.KnownActorStatuses.ContainsKey(dataobject.Name))                                      {                                          // is contained                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.On);                                          else                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.Off);                                      }                                      else                                      {                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.On));                                          else                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.Off));                                      }                                  }                                  else                                      ConsoleOutputLogger.WriteLine("Actor "+dataobject.Name+" is on the blacklist (ActorReSwitching) and therefore is ignored this time.");                              }                         }                         else                             if (dataobject.Type == ObjectTypes.Sensor)                             {                                 lock(sensor_data_store)                                 {                                     sensor_data_store.Write(dataobject.Serialize());                                  }                                 // update the sensor in the sensor check                                 Sensorcheck.UpdateSensor(dataobject.Name);  								// if Alarming is enabled' queue this XS1 Event up for alarming... 								if (Properties.Settings.Default.AlarmingEnabled) 								{ 									if (!dataobject.IgnoreForAlarming)	// this if for those events which get re-queued as xs1 events despite being for example elvmax events 										Alarming_Queue.Enqueue(dataobject);                                  }                                    #region Scripting                                  // check if this sensor is something we should act uppon                                 foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions)                                 {                                     if (dataobject.Name == Element.SensorToWatchName)                                     {                                         if (dataobject.Value == Element.SensorValue)                                         {                                              // obviously there is a ScriptingActorConfiguration entry                                             // so we execute the actor preset                                              set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                             ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on sensor "+Element.SensorToWatchName+" - "+Element.ActorToSwitchName+" to "+Element.ActionToRunName);                                              if (Element.isCurrentlyWithinStartEndHours())                                              {                                              #region Scripting Actor actions                                              if (Element.ActionToRunName == actor_status.URL)                                              {                                                  ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                  // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                    try                                                  {                                                      WebClient client = new WebClient();                                                      client.Encoding = System.Text.Encoding.UTF8;                                                      String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                        ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                  }                                                  catch (Exception e)                                                  {                                                      ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                  }                                              }                                              // check what action is going to happen now...                                             if (Element.ActionToRunName == actor_status.On)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                             }                                              if (Element.ActionToRunName == actor_status.Off)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                                                  // remove from OnWaitOffList                                                 lock (OnWaitOffLIst)                                                 {                                                      if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                          OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                  }                                             }                                              if (Element.ActionToRunName == actor_status.OnOff)                                             {                                                 // look for the current status in the known actors table                                                  lock(KnownActorStates.KnownActorStatuses)                                                  {                                                      if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                     {                                                          current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                         if (Status.Status == actor_status.On)                                                             ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                         else                                                             if (Status.Status == actor_status.Off)                                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                     }                                                     else                                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                  }                                             }                                             if (Element.ActionToRunName == actor_status.OnWaitOff)                                              {                                                  lock (OnWaitOffLIst)                                                  {                                                      ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                      OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                  }                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                              }                                              #endregion                                              }                                              else                                              {                                                  ConsoleOutputLogger.WriteLine("Actorswitching Action not triggered since it's out of timespan. ("+Element.StartHour+"-"+Element.EndHour+")");                                              }                                          }                                     }                                  }                                  #endregion                                    #region MQTT Handling Sensor                                  if (Properties.Settings.Default.MQTTBindingEnabled)                                  {                                      MQTT_Binding.MQTT_Handle_Sensor(dataobject);                                  }                                  #endregion                                }                             else                                 if (dataobject.Type == ObjectTypes.Unknown)                                 {                                     unknown_data_store.Write(dataobject.Serialize());                                 }                          ConsoleOutputLogger.WriteLine(ServerName+" - "+dataobject.OriginalXS1Statement); 					} 					#endregion  					#region Handle MAX events 					// the strategy for MAX events is quite easy: emulate XS1 events and stuff the XS1 queue with those faked events 					// that takes care of the storage and the 					if (Properties.Settings.Default.ELVMAXEnabled) 					{ 						IDeviceDiffSet max_dataobject = null;  						if(MAX_DataQueue.TryDequeue(out max_dataobject)) 					   	{ 							// if Alarming is enabled' queue this ELV MAX up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(max_dataobject); 							}  							StringBuilder sb = new StringBuilder();  							sb.Append("S\t"+max_dataobject.DeviceName+"\t"+max_dataobject.DeviceType);  							if (max_dataobject.DeviceType == DeviceTypes.HeatingThermostat) 							{ 								HeatingThermostatDiff _heating = (HeatingThermostatDiff)max_dataobject;  								// this is what is different on the heating thermostats 								//ConsoleOutputLogger.WriteLine(_heating.ToString());  								// first the temperature data 								XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"heating_thermostat"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()'true); 								SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 								XS1_DataQueue.Enqueue(maxdataobject);  								// then the low battery if exists 								if (_heating.LowBattery == BatteryStatus.lowbattery) 								{ 									XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()+"' LowBattery"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 									XS1_DataQueue.Enqueue(lowbatteryobject); 								}  								if (_heating.Mode == ThermostatModes.boost) 								{ 									XS1_DataObject boostmodeobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"boost"'DateTime.Now'_heating.RoomID'_heating.Temperature' _heating.ToString()+"' Boost"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(boostmodeobject.Name); 									XS1_DataQueue.Enqueue(boostmodeobject); 								} 							}  							if (max_dataobject.DeviceType == DeviceTypes.ShutterContact) 							{ 								ShutterContactDiff _shutter = (ShutterContactDiff)max_dataobject;  								// this is what is different on the ShutterContacts 								//ConsoleOutputLogger.WriteLine(_shutter.ToString());  								// first the open/close status 								if (_shutter.ShutterState == ShutterContactModes.open) 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								} 								else 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								}  								// then the low battery if exists 								if (_shutter.LowBattery == BatteryStatus.lowbattery) 								{ 									if (_shutter.ShutterState == ShutterContactModes.open) 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 									else 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 								}  							} 						} 					} 					#endregion  					#region Handle SolarLog events 					if (Properties.Settings.Default.SolarLogEnabled) 					{ 						SolarLogDataSet solarlog_dataobject = null; 						 						if(SolarLog_DataQueue.TryDequeue(out solarlog_dataobject)) 						{ 							// Pac                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "Pac"' ObjectTypes.Sensor' "Pac"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.Pac' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'Pac'" + solarlog_dataobject.Pac + "'" + solarlog_dataobject.DateAndTime.Ticks'true)); 							// aPdc                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "aPdc"' ObjectTypes.Sensor' "aPdc"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.aPdc' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'aPdc'" + solarlog_dataobject.aPdc+"'"+solarlog_dataobject.DateAndTime.Ticks'true));  							// if Alarming is enabled' queue this SolarLog Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(solarlog_dataobject); 							} 						} 					} 					#endregion  					#region Handle Network Monitor events 					if (Properties.Settings.Default.NetworkMonitorEnabled) 					{ 						NetworkMonitoringDataSet networkmonitor_dataobject = null; 						 						if(NetworkMonitor_Queue.TryDequeue(out networkmonitor_dataobject)) 						{ 							if (networkmonitor_dataobject.Status == Org.Mentalis.Network.ICMP_Status.Success) 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'1'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Online"'true)); 							else 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'0'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Offline"'true));  							// if Alarming is enabled' queue this Network Monitor Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(networkmonitor_dataobject); 							} 						} 					} 					#endregion                 }                 catch (Exception)                 {                                        AcceptingCommands = false;                     //Thread.Sleep(1);                 }                  Thread.Sleep(1);             }
Magic Number,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The following statement contains a magic number: while (!Shutdown)             {                 try                 { 					#region Handle XS1 events 					XS1_DataObject dataobject = null; 					if (XS1_DataQueue.TryDequeue(out dataobject)) 					{ 						if (dataobject.Type == ObjectTypes.Actor)                         {                             // Write to Disk                             lock(actor_data_store)                             {                                 actor_data_store.Write(dataobject.Serialize());                              }                              lock(KnownActorStates.KnownActorStatuses)                             {                                  bool usethisactor = true;                                  // check if this actor is on temporary blacklist (like when it was handled)                                  lock (TemporaryBlacklist)                                  {                                      if (TemporaryBlacklist.Contains(dataobject.Name))                                          usethisactor = false;                                      TemporaryBlacklist.Remove(dataobject.Name);                                  }                                   if (usethisactor)                                  { 									// if Alarming is enabled' queue this XS1 Event up for alarming... 									if (Properties.Settings.Default.AlarmingEnabled) 									{ 										Alarming_Queue.Enqueue(dataobject); 									}  									// this actor action did not result in any action hacs made - so we try to make the best out of it 									#region Scripting Handling 									// check if this sensor is something we should act uppon 									foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions) 									{                                              if (dataobject.Name == Element.SensorToWatchName)                                              {                                                  if (dataobject.Value == Element.SensorValue)                                                  {                                                      // obviously there is a ScriptingActorConfiguration entry                                                      // so we execute the actor preset                                                        set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                                      ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on actor " + Element.SensorToWatchName + " - " + Element.ActorToSwitchName + " to " + Element.ActionToRunName);                                                                                                            if (Element.isCurrentlyWithinStartEndHours())                                                      {                                                          #region Scripting Actor Actions                                                      if (Element.ActionToRunName == actor_status.URL)                                                      {                                                          ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                          // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                              try                                                          {                                                              WebClient client = new WebClient();                                                              client.Encoding = System.Text.Encoding.UTF8;                                                              String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                                ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                          }                                                          catch (Exception e)                                                          {                                                              ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                          }                                                      }                                                        // check what action is going to happen now...                                                      if (Element.ActionToRunName == actor_status.On)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                      }                                                        if (Element.ActionToRunName == actor_status.Off)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                            // remove from OnWaitOffList                                                          lock (OnWaitOffLIst)                                                          {                                                              if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                                  OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                          }                                                      }                                                        if (Element.ActionToRunName == actor_status.OnOff)                                                      {                                                          // look for the current status in the known actors table                                                          lock (KnownActorStates.KnownActorStatuses)                                                          {                                                              if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                              {                                                                  current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                                  if (Status.Status == actor_status.On)                                                                      ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                  else                                                                      if (Status.Status == actor_status.Off)                                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                              }                                                              else                                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                          }                                                      }                                                      if (Element.ActionToRunName == actor_status.OnWaitOff)                                                      {                                                          lock (OnWaitOffLIst)                                                          {                                                              ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                              OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                          }                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                                      }                                                      #endregion                                                      }                                                    }                                              } 									} 									#endregion                                        #region MQTT Handling Actor                                      if (Properties.Settings.Default.MQTTBindingEnabled)                                      {                                          MQTT_Binding.MQTT_Handle_Actor(dataobject);                                      }                                      #endregion                                        if (KnownActorStates.KnownActorStatuses.ContainsKey(dataobject.Name))                                      {                                          // is contained                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.On);                                          else                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.Off);                                      }                                      else                                      {                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.On));                                          else                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.Off));                                      }                                  }                                  else                                      ConsoleOutputLogger.WriteLine("Actor "+dataobject.Name+" is on the blacklist (ActorReSwitching) and therefore is ignored this time.");                              }                         }                         else                             if (dataobject.Type == ObjectTypes.Sensor)                             {                                 lock(sensor_data_store)                                 {                                     sensor_data_store.Write(dataobject.Serialize());                                  }                                 // update the sensor in the sensor check                                 Sensorcheck.UpdateSensor(dataobject.Name);  								// if Alarming is enabled' queue this XS1 Event up for alarming... 								if (Properties.Settings.Default.AlarmingEnabled) 								{ 									if (!dataobject.IgnoreForAlarming)	// this if for those events which get re-queued as xs1 events despite being for example elvmax events 										Alarming_Queue.Enqueue(dataobject);                                  }                                    #region Scripting                                  // check if this sensor is something we should act uppon                                 foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions)                                 {                                     if (dataobject.Name == Element.SensorToWatchName)                                     {                                         if (dataobject.Value == Element.SensorValue)                                         {                                              // obviously there is a ScriptingActorConfiguration entry                                             // so we execute the actor preset                                              set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                             ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on sensor "+Element.SensorToWatchName+" - "+Element.ActorToSwitchName+" to "+Element.ActionToRunName);                                              if (Element.isCurrentlyWithinStartEndHours())                                              {                                              #region Scripting Actor actions                                              if (Element.ActionToRunName == actor_status.URL)                                              {                                                  ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                  // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                    try                                                  {                                                      WebClient client = new WebClient();                                                      client.Encoding = System.Text.Encoding.UTF8;                                                      String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                        ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                  }                                                  catch (Exception e)                                                  {                                                      ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                  }                                              }                                              // check what action is going to happen now...                                             if (Element.ActionToRunName == actor_status.On)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                             }                                              if (Element.ActionToRunName == actor_status.Off)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                                                  // remove from OnWaitOffList                                                 lock (OnWaitOffLIst)                                                 {                                                      if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                          OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                  }                                             }                                              if (Element.ActionToRunName == actor_status.OnOff)                                             {                                                 // look for the current status in the known actors table                                                  lock(KnownActorStates.KnownActorStatuses)                                                  {                                                      if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                     {                                                          current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                         if (Status.Status == actor_status.On)                                                             ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                         else                                                             if (Status.Status == actor_status.Off)                                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                     }                                                     else                                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                  }                                             }                                             if (Element.ActionToRunName == actor_status.OnWaitOff)                                              {                                                  lock (OnWaitOffLIst)                                                  {                                                      ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                      OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                  }                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                              }                                              #endregion                                              }                                              else                                              {                                                  ConsoleOutputLogger.WriteLine("Actorswitching Action not triggered since it's out of timespan. ("+Element.StartHour+"-"+Element.EndHour+")");                                              }                                          }                                     }                                  }                                  #endregion                                    #region MQTT Handling Sensor                                  if (Properties.Settings.Default.MQTTBindingEnabled)                                  {                                      MQTT_Binding.MQTT_Handle_Sensor(dataobject);                                  }                                  #endregion                                }                             else                                 if (dataobject.Type == ObjectTypes.Unknown)                                 {                                     unknown_data_store.Write(dataobject.Serialize());                                 }                          ConsoleOutputLogger.WriteLine(ServerName+" - "+dataobject.OriginalXS1Statement); 					} 					#endregion  					#region Handle MAX events 					// the strategy for MAX events is quite easy: emulate XS1 events and stuff the XS1 queue with those faked events 					// that takes care of the storage and the 					if (Properties.Settings.Default.ELVMAXEnabled) 					{ 						IDeviceDiffSet max_dataobject = null;  						if(MAX_DataQueue.TryDequeue(out max_dataobject)) 					   	{ 							// if Alarming is enabled' queue this ELV MAX up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(max_dataobject); 							}  							StringBuilder sb = new StringBuilder();  							sb.Append("S\t"+max_dataobject.DeviceName+"\t"+max_dataobject.DeviceType);  							if (max_dataobject.DeviceType == DeviceTypes.HeatingThermostat) 							{ 								HeatingThermostatDiff _heating = (HeatingThermostatDiff)max_dataobject;  								// this is what is different on the heating thermostats 								//ConsoleOutputLogger.WriteLine(_heating.ToString());  								// first the temperature data 								XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"heating_thermostat"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()'true); 								SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 								XS1_DataQueue.Enqueue(maxdataobject);  								// then the low battery if exists 								if (_heating.LowBattery == BatteryStatus.lowbattery) 								{ 									XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()+"' LowBattery"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 									XS1_DataQueue.Enqueue(lowbatteryobject); 								}  								if (_heating.Mode == ThermostatModes.boost) 								{ 									XS1_DataObject boostmodeobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"boost"'DateTime.Now'_heating.RoomID'_heating.Temperature' _heating.ToString()+"' Boost"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(boostmodeobject.Name); 									XS1_DataQueue.Enqueue(boostmodeobject); 								} 							}  							if (max_dataobject.DeviceType == DeviceTypes.ShutterContact) 							{ 								ShutterContactDiff _shutter = (ShutterContactDiff)max_dataobject;  								// this is what is different on the ShutterContacts 								//ConsoleOutputLogger.WriteLine(_shutter.ToString());  								// first the open/close status 								if (_shutter.ShutterState == ShutterContactModes.open) 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								} 								else 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								}  								// then the low battery if exists 								if (_shutter.LowBattery == BatteryStatus.lowbattery) 								{ 									if (_shutter.ShutterState == ShutterContactModes.open) 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 									else 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 								}  							} 						} 					} 					#endregion  					#region Handle SolarLog events 					if (Properties.Settings.Default.SolarLogEnabled) 					{ 						SolarLogDataSet solarlog_dataobject = null; 						 						if(SolarLog_DataQueue.TryDequeue(out solarlog_dataobject)) 						{ 							// Pac                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "Pac"' ObjectTypes.Sensor' "Pac"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.Pac' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'Pac'" + solarlog_dataobject.Pac + "'" + solarlog_dataobject.DateAndTime.Ticks'true)); 							// aPdc                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "aPdc"' ObjectTypes.Sensor' "aPdc"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.aPdc' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'aPdc'" + solarlog_dataobject.aPdc+"'"+solarlog_dataobject.DateAndTime.Ticks'true));  							// if Alarming is enabled' queue this SolarLog Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(solarlog_dataobject); 							} 						} 					} 					#endregion  					#region Handle Network Monitor events 					if (Properties.Settings.Default.NetworkMonitorEnabled) 					{ 						NetworkMonitoringDataSet networkmonitor_dataobject = null; 						 						if(NetworkMonitor_Queue.TryDequeue(out networkmonitor_dataobject)) 						{ 							if (networkmonitor_dataobject.Status == Org.Mentalis.Network.ICMP_Status.Success) 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'1'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Online"'true)); 							else 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'0'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Offline"'true));  							// if Alarming is enabled' queue this Network Monitor Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(networkmonitor_dataobject); 							} 						} 					} 					#endregion                 }                 catch (Exception)                 {                                        AcceptingCommands = false;                     //Thread.Sleep(1);                 }                  Thread.Sleep(1);             }
Magic Number,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The following statement contains a magic number: while (!Shutdown)             {                 try                 { 					#region Handle XS1 events 					XS1_DataObject dataobject = null; 					if (XS1_DataQueue.TryDequeue(out dataobject)) 					{ 						if (dataobject.Type == ObjectTypes.Actor)                         {                             // Write to Disk                             lock(actor_data_store)                             {                                 actor_data_store.Write(dataobject.Serialize());                              }                              lock(KnownActorStates.KnownActorStatuses)                             {                                  bool usethisactor = true;                                  // check if this actor is on temporary blacklist (like when it was handled)                                  lock (TemporaryBlacklist)                                  {                                      if (TemporaryBlacklist.Contains(dataobject.Name))                                          usethisactor = false;                                      TemporaryBlacklist.Remove(dataobject.Name);                                  }                                   if (usethisactor)                                  { 									// if Alarming is enabled' queue this XS1 Event up for alarming... 									if (Properties.Settings.Default.AlarmingEnabled) 									{ 										Alarming_Queue.Enqueue(dataobject); 									}  									// this actor action did not result in any action hacs made - so we try to make the best out of it 									#region Scripting Handling 									// check if this sensor is something we should act uppon 									foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions) 									{                                              if (dataobject.Name == Element.SensorToWatchName)                                              {                                                  if (dataobject.Value == Element.SensorValue)                                                  {                                                      // obviously there is a ScriptingActorConfiguration entry                                                      // so we execute the actor preset                                                        set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                                      ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on actor " + Element.SensorToWatchName + " - " + Element.ActorToSwitchName + " to " + Element.ActionToRunName);                                                                                                            if (Element.isCurrentlyWithinStartEndHours())                                                      {                                                          #region Scripting Actor Actions                                                      if (Element.ActionToRunName == actor_status.URL)                                                      {                                                          ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                          // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                              try                                                          {                                                              WebClient client = new WebClient();                                                              client.Encoding = System.Text.Encoding.UTF8;                                                              String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                                ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                          }                                                          catch (Exception e)                                                          {                                                              ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                          }                                                      }                                                        // check what action is going to happen now...                                                      if (Element.ActionToRunName == actor_status.On)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                      }                                                        if (Element.ActionToRunName == actor_status.Off)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                            // remove from OnWaitOffList                                                          lock (OnWaitOffLIst)                                                          {                                                              if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                                  OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                          }                                                      }                                                        if (Element.ActionToRunName == actor_status.OnOff)                                                      {                                                          // look for the current status in the known actors table                                                          lock (KnownActorStates.KnownActorStatuses)                                                          {                                                              if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                              {                                                                  current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                                  if (Status.Status == actor_status.On)                                                                      ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                  else                                                                      if (Status.Status == actor_status.Off)                                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                              }                                                              else                                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                          }                                                      }                                                      if (Element.ActionToRunName == actor_status.OnWaitOff)                                                      {                                                          lock (OnWaitOffLIst)                                                          {                                                              ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                              OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                          }                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                                      }                                                      #endregion                                                      }                                                    }                                              } 									} 									#endregion                                        #region MQTT Handling Actor                                      if (Properties.Settings.Default.MQTTBindingEnabled)                                      {                                          MQTT_Binding.MQTT_Handle_Actor(dataobject);                                      }                                      #endregion                                        if (KnownActorStates.KnownActorStatuses.ContainsKey(dataobject.Name))                                      {                                          // is contained                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.On);                                          else                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.Off);                                      }                                      else                                      {                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.On));                                          else                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.Off));                                      }                                  }                                  else                                      ConsoleOutputLogger.WriteLine("Actor "+dataobject.Name+" is on the blacklist (ActorReSwitching) and therefore is ignored this time.");                              }                         }                         else                             if (dataobject.Type == ObjectTypes.Sensor)                             {                                 lock(sensor_data_store)                                 {                                     sensor_data_store.Write(dataobject.Serialize());                                  }                                 // update the sensor in the sensor check                                 Sensorcheck.UpdateSensor(dataobject.Name);  								// if Alarming is enabled' queue this XS1 Event up for alarming... 								if (Properties.Settings.Default.AlarmingEnabled) 								{ 									if (!dataobject.IgnoreForAlarming)	// this if for those events which get re-queued as xs1 events despite being for example elvmax events 										Alarming_Queue.Enqueue(dataobject);                                  }                                    #region Scripting                                  // check if this sensor is something we should act uppon                                 foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions)                                 {                                     if (dataobject.Name == Element.SensorToWatchName)                                     {                                         if (dataobject.Value == Element.SensorValue)                                         {                                              // obviously there is a ScriptingActorConfiguration entry                                             // so we execute the actor preset                                              set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                             ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on sensor "+Element.SensorToWatchName+" - "+Element.ActorToSwitchName+" to "+Element.ActionToRunName);                                              if (Element.isCurrentlyWithinStartEndHours())                                              {                                              #region Scripting Actor actions                                              if (Element.ActionToRunName == actor_status.URL)                                              {                                                  ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                  // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                    try                                                  {                                                      WebClient client = new WebClient();                                                      client.Encoding = System.Text.Encoding.UTF8;                                                      String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                        ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                  }                                                  catch (Exception e)                                                  {                                                      ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                  }                                              }                                              // check what action is going to happen now...                                             if (Element.ActionToRunName == actor_status.On)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                             }                                              if (Element.ActionToRunName == actor_status.Off)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                                                  // remove from OnWaitOffList                                                 lock (OnWaitOffLIst)                                                 {                                                      if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                          OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                  }                                             }                                              if (Element.ActionToRunName == actor_status.OnOff)                                             {                                                 // look for the current status in the known actors table                                                  lock(KnownActorStates.KnownActorStatuses)                                                  {                                                      if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                     {                                                          current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                         if (Status.Status == actor_status.On)                                                             ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                         else                                                             if (Status.Status == actor_status.Off)                                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                     }                                                     else                                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                  }                                             }                                             if (Element.ActionToRunName == actor_status.OnWaitOff)                                              {                                                  lock (OnWaitOffLIst)                                                  {                                                      ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                      OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                  }                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                              }                                              #endregion                                              }                                              else                                              {                                                  ConsoleOutputLogger.WriteLine("Actorswitching Action not triggered since it's out of timespan. ("+Element.StartHour+"-"+Element.EndHour+")");                                              }                                          }                                     }                                  }                                  #endregion                                    #region MQTT Handling Sensor                                  if (Properties.Settings.Default.MQTTBindingEnabled)                                  {                                      MQTT_Binding.MQTT_Handle_Sensor(dataobject);                                  }                                  #endregion                                }                             else                                 if (dataobject.Type == ObjectTypes.Unknown)                                 {                                     unknown_data_store.Write(dataobject.Serialize());                                 }                          ConsoleOutputLogger.WriteLine(ServerName+" - "+dataobject.OriginalXS1Statement); 					} 					#endregion  					#region Handle MAX events 					// the strategy for MAX events is quite easy: emulate XS1 events and stuff the XS1 queue with those faked events 					// that takes care of the storage and the 					if (Properties.Settings.Default.ELVMAXEnabled) 					{ 						IDeviceDiffSet max_dataobject = null;  						if(MAX_DataQueue.TryDequeue(out max_dataobject)) 					   	{ 							// if Alarming is enabled' queue this ELV MAX up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(max_dataobject); 							}  							StringBuilder sb = new StringBuilder();  							sb.Append("S\t"+max_dataobject.DeviceName+"\t"+max_dataobject.DeviceType);  							if (max_dataobject.DeviceType == DeviceTypes.HeatingThermostat) 							{ 								HeatingThermostatDiff _heating = (HeatingThermostatDiff)max_dataobject;  								// this is what is different on the heating thermostats 								//ConsoleOutputLogger.WriteLine(_heating.ToString());  								// first the temperature data 								XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"heating_thermostat"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()'true); 								SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 								XS1_DataQueue.Enqueue(maxdataobject);  								// then the low battery if exists 								if (_heating.LowBattery == BatteryStatus.lowbattery) 								{ 									XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()+"' LowBattery"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 									XS1_DataQueue.Enqueue(lowbatteryobject); 								}  								if (_heating.Mode == ThermostatModes.boost) 								{ 									XS1_DataObject boostmodeobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"boost"'DateTime.Now'_heating.RoomID'_heating.Temperature' _heating.ToString()+"' Boost"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(boostmodeobject.Name); 									XS1_DataQueue.Enqueue(boostmodeobject); 								} 							}  							if (max_dataobject.DeviceType == DeviceTypes.ShutterContact) 							{ 								ShutterContactDiff _shutter = (ShutterContactDiff)max_dataobject;  								// this is what is different on the ShutterContacts 								//ConsoleOutputLogger.WriteLine(_shutter.ToString());  								// first the open/close status 								if (_shutter.ShutterState == ShutterContactModes.open) 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								} 								else 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								}  								// then the low battery if exists 								if (_shutter.LowBattery == BatteryStatus.lowbattery) 								{ 									if (_shutter.ShutterState == ShutterContactModes.open) 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 									else 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 								}  							} 						} 					} 					#endregion  					#region Handle SolarLog events 					if (Properties.Settings.Default.SolarLogEnabled) 					{ 						SolarLogDataSet solarlog_dataobject = null; 						 						if(SolarLog_DataQueue.TryDequeue(out solarlog_dataobject)) 						{ 							// Pac                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "Pac"' ObjectTypes.Sensor' "Pac"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.Pac' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'Pac'" + solarlog_dataobject.Pac + "'" + solarlog_dataobject.DateAndTime.Ticks'true)); 							// aPdc                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "aPdc"' ObjectTypes.Sensor' "aPdc"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.aPdc' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'aPdc'" + solarlog_dataobject.aPdc+"'"+solarlog_dataobject.DateAndTime.Ticks'true));  							// if Alarming is enabled' queue this SolarLog Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(solarlog_dataobject); 							} 						} 					} 					#endregion  					#region Handle Network Monitor events 					if (Properties.Settings.Default.NetworkMonitorEnabled) 					{ 						NetworkMonitoringDataSet networkmonitor_dataobject = null; 						 						if(NetworkMonitor_Queue.TryDequeue(out networkmonitor_dataobject)) 						{ 							if (networkmonitor_dataobject.Status == Org.Mentalis.Network.ICMP_Status.Success) 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'1'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Online"'true)); 							else 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'0'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Offline"'true));  							// if Alarming is enabled' queue this Network Monitor Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(networkmonitor_dataobject); 							} 						} 					} 					#endregion                 }                 catch (Exception)                 {                                        AcceptingCommands = false;                     //Thread.Sleep(1);                 }                  Thread.Sleep(1);             }
Magic Number,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The following statement contains a magic number: while (!Shutdown)             {                 try                 { 					#region Handle XS1 events 					XS1_DataObject dataobject = null; 					if (XS1_DataQueue.TryDequeue(out dataobject)) 					{ 						if (dataobject.Type == ObjectTypes.Actor)                         {                             // Write to Disk                             lock(actor_data_store)                             {                                 actor_data_store.Write(dataobject.Serialize());                              }                              lock(KnownActorStates.KnownActorStatuses)                             {                                  bool usethisactor = true;                                  // check if this actor is on temporary blacklist (like when it was handled)                                  lock (TemporaryBlacklist)                                  {                                      if (TemporaryBlacklist.Contains(dataobject.Name))                                          usethisactor = false;                                      TemporaryBlacklist.Remove(dataobject.Name);                                  }                                   if (usethisactor)                                  { 									// if Alarming is enabled' queue this XS1 Event up for alarming... 									if (Properties.Settings.Default.AlarmingEnabled) 									{ 										Alarming_Queue.Enqueue(dataobject); 									}  									// this actor action did not result in any action hacs made - so we try to make the best out of it 									#region Scripting Handling 									// check if this sensor is something we should act uppon 									foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions) 									{                                              if (dataobject.Name == Element.SensorToWatchName)                                              {                                                  if (dataobject.Value == Element.SensorValue)                                                  {                                                      // obviously there is a ScriptingActorConfiguration entry                                                      // so we execute the actor preset                                                        set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                                      ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on actor " + Element.SensorToWatchName + " - " + Element.ActorToSwitchName + " to " + Element.ActionToRunName);                                                                                                            if (Element.isCurrentlyWithinStartEndHours())                                                      {                                                          #region Scripting Actor Actions                                                      if (Element.ActionToRunName == actor_status.URL)                                                      {                                                          ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                          // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                              try                                                          {                                                              WebClient client = new WebClient();                                                              client.Encoding = System.Text.Encoding.UTF8;                                                              String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                                ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                          }                                                          catch (Exception e)                                                          {                                                              ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                          }                                                      }                                                        // check what action is going to happen now...                                                      if (Element.ActionToRunName == actor_status.On)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                      }                                                        if (Element.ActionToRunName == actor_status.Off)                                                      {                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                            // remove from OnWaitOffList                                                          lock (OnWaitOffLIst)                                                          {                                                              if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                                  OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                          }                                                      }                                                        if (Element.ActionToRunName == actor_status.OnOff)                                                      {                                                          // look for the current status in the known actors table                                                          lock (KnownActorStates.KnownActorStatuses)                                                          {                                                              if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                              {                                                                  current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                                  if (Status.Status == actor_status.On)                                                                      ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                  else                                                                      if (Status.Status == actor_status.Off)                                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                              }                                                              else                                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                          }                                                      }                                                      if (Element.ActionToRunName == actor_status.OnWaitOff)                                                      {                                                          lock (OnWaitOffLIst)                                                          {                                                              ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                              OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                          }                                                          ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                                      }                                                      #endregion                                                      }                                                    }                                              } 									} 									#endregion                                        #region MQTT Handling Actor                                      if (Properties.Settings.Default.MQTTBindingEnabled)                                      {                                          MQTT_Binding.MQTT_Handle_Actor(dataobject);                                      }                                      #endregion                                        if (KnownActorStates.KnownActorStatuses.ContainsKey(dataobject.Name))                                      {                                          // is contained                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.On);                                          else                                              KnownActorStates.KnownActorStatuses[dataobject.Name] = new current_actor_status(dataobject.Name' actor_status.Off);                                      }                                      else                                      {                                          if (dataobject.Value == 100)                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.On));                                          else                                              KnownActorStates.KnownActorStatuses.Add(dataobject.Name' new current_actor_status(dataobject.Name' actor_status.Off));                                      }                                  }                                  else                                      ConsoleOutputLogger.WriteLine("Actor "+dataobject.Name+" is on the blacklist (ActorReSwitching) and therefore is ignored this time.");                              }                         }                         else                             if (dataobject.Type == ObjectTypes.Sensor)                             {                                 lock(sensor_data_store)                                 {                                     sensor_data_store.Write(dataobject.Serialize());                                  }                                 // update the sensor in the sensor check                                 Sensorcheck.UpdateSensor(dataobject.Name);  								// if Alarming is enabled' queue this XS1 Event up for alarming... 								if (Properties.Settings.Default.AlarmingEnabled) 								{ 									if (!dataobject.IgnoreForAlarming)	// this if for those events which get re-queued as xs1 events despite being for example elvmax events 										Alarming_Queue.Enqueue(dataobject);                                  }                                    #region Scripting                                  // check if this sensor is something we should act uppon                                 foreach (ScriptingActorElement Element in ScriptingActorConfiguration.ScriptingActorActions)                                 {                                     if (dataobject.Name == Element.SensorToWatchName)                                     {                                         if (dataobject.Value == Element.SensorValue)                                         {                                              // obviously there is a ScriptingActorConfiguration entry                                             // so we execute the actor preset                                              set_state_actuator.set_state_actuator ssa = new set_state_actuator.set_state_actuator();                                             ConsoleOutputLogger.WriteLineToScreenOnly("detected actor scripting action on sensor "+Element.SensorToWatchName+" - "+Element.ActorToSwitchName+" to "+Element.ActionToRunName);                                              if (Element.isCurrentlyWithinStartEndHours())                                              {                                              #region Scripting Actor actions                                              if (Element.ActionToRunName == actor_status.URL)                                              {                                                  ConsoleOutputLogger.WriteLine("Scripting Actor URL");                                                  // handle URLs -> the ActorToSwitch Name will be the URL to trigger                                                    try                                                  {                                                      WebClient client = new WebClient();                                                      client.Encoding = System.Text.Encoding.UTF8;                                                      String JSONInput = client.DownloadString(Element.ActorToSwitchName);                                                        ConsoleOutputLogger.WriteLine("Doing HTTP GET on: " + Element.ActorToSwitchName);                                                  }                                                  catch (Exception e)                                                  {                                                      ConsoleOutputLogger.WriteLine("Exception on URL Actor Scripting: " + e.Message);                                                  }                                              }                                              // check what action is going to happen now...                                             if (Element.ActionToRunName == actor_status.On)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                             }                                              if (Element.ActionToRunName == actor_status.Off)                                             {                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                                                                  // remove from OnWaitOffList                                                 lock (OnWaitOffLIst)                                                 {                                                      if (OnWaitOffLIst.Contains(Element.ActorToSwitchName))                                                          OnWaitOffLIst.Remove(Element.ActorToSwitchName);                                                  }                                             }                                              if (Element.ActionToRunName == actor_status.OnOff)                                             {                                                 // look for the current status in the known actors table                                                  lock(KnownActorStates.KnownActorStatuses)                                                  {                                                      if (KnownActorStates.KnownActorStatuses.ContainsKey(Element.ActorToSwitchName))                                                     {                                                          current_actor_status Status = KnownActorStates.KnownActorStatuses[Element.ActorToSwitchName];                                                         if (Status.Status == actor_status.On)                                                             ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "OFF"' XS1_Configuration);                                                         else                                                             if (Status.Status == actor_status.Off)                                                                 ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                     }                                                     else                                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON"' XS1_Configuration);                                                  }                                             }                                             if (Element.ActionToRunName == actor_status.OnWaitOff)                                              {                                                  lock (OnWaitOffLIst)                                                  {                                                      ConsoleOutputLogger.WriteLine("Adding " + Element.ActorToSwitchName + " to ActorReSwitching OnWaitOff List");                                                      OnWaitOffLIst.Add(Element.ActorToSwitchName);                                                  }                                                  ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' Element.ActorToSwitchName' "ON_WAIT_OFF"' XS1_Configuration);                                              }                                              #endregion                                              }                                              else                                              {                                                  ConsoleOutputLogger.WriteLine("Actorswitching Action not triggered since it's out of timespan. ("+Element.StartHour+"-"+Element.EndHour+")");                                              }                                          }                                     }                                  }                                  #endregion                                    #region MQTT Handling Sensor                                  if (Properties.Settings.Default.MQTTBindingEnabled)                                  {                                      MQTT_Binding.MQTT_Handle_Sensor(dataobject);                                  }                                  #endregion                                }                             else                                 if (dataobject.Type == ObjectTypes.Unknown)                                 {                                     unknown_data_store.Write(dataobject.Serialize());                                 }                          ConsoleOutputLogger.WriteLine(ServerName+" - "+dataobject.OriginalXS1Statement); 					} 					#endregion  					#region Handle MAX events 					// the strategy for MAX events is quite easy: emulate XS1 events and stuff the XS1 queue with those faked events 					// that takes care of the storage and the 					if (Properties.Settings.Default.ELVMAXEnabled) 					{ 						IDeviceDiffSet max_dataobject = null;  						if(MAX_DataQueue.TryDequeue(out max_dataobject)) 					   	{ 							// if Alarming is enabled' queue this ELV MAX up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(max_dataobject); 							}  							StringBuilder sb = new StringBuilder();  							sb.Append("S\t"+max_dataobject.DeviceName+"\t"+max_dataobject.DeviceType);  							if (max_dataobject.DeviceType == DeviceTypes.HeatingThermostat) 							{ 								HeatingThermostatDiff _heating = (HeatingThermostatDiff)max_dataobject;  								// this is what is different on the heating thermostats 								//ConsoleOutputLogger.WriteLine(_heating.ToString());  								// first the temperature data 								XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"heating_thermostat"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()'true); 								SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 								XS1_DataQueue.Enqueue(maxdataobject);  								// then the low battery if exists 								if (_heating.LowBattery == BatteryStatus.lowbattery) 								{ 									XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_heating.RoomID'_heating.Temperature'_heating.ToString()+"' LowBattery"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 									XS1_DataQueue.Enqueue(lowbatteryobject); 								}  								if (_heating.Mode == ThermostatModes.boost) 								{ 									XS1_DataObject boostmodeobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_heating.RoomName+"-"+_heating.DeviceName'ObjectTypes.Sensor'"boost"'DateTime.Now'_heating.RoomID'_heating.Temperature' _heating.ToString()+"' Boost"'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(boostmodeobject.Name); 									XS1_DataQueue.Enqueue(boostmodeobject); 								} 							}  							if (max_dataobject.DeviceType == DeviceTypes.ShutterContact) 							{ 								ShutterContactDiff _shutter = (ShutterContactDiff)max_dataobject;  								// this is what is different on the ShutterContacts 								//ConsoleOutputLogger.WriteLine(_shutter.ToString());  								// first the open/close status 								if (_shutter.ShutterState == ShutterContactModes.open) 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								} 								else 								{ 									XS1_DataObject maxdataobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"shutter_contact"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()'true); 									SensorCheckIgnoreConfiguration.AddToIgnoreList(maxdataobject.Name); 									XS1_DataQueue.Enqueue(maxdataobject); 								}  								// then the low battery if exists 								if (_shutter.LowBattery == BatteryStatus.lowbattery) 								{ 									if (_shutter.ShutterState == ShutterContactModes.open) 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'1.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 									else 									{ 										XS1_DataObject lowbatteryobject = new XS1_DataObject(Properties.Settings.Default.ELVMAXIP'_shutter.RoomName+"-"+_shutter.DeviceName'ObjectTypes.Sensor'"low_battery"'DateTime.Now'_shutter.RoomID'0.0'_shutter.ToString()+"'LowBattery"'true); 										SensorCheckIgnoreConfiguration.AddToIgnoreList(lowbatteryobject.Name); 										XS1_DataQueue.Enqueue(lowbatteryobject); 									} 								}  							} 						} 					} 					#endregion  					#region Handle SolarLog events 					if (Properties.Settings.Default.SolarLogEnabled) 					{ 						SolarLogDataSet solarlog_dataobject = null; 						 						if(SolarLog_DataQueue.TryDequeue(out solarlog_dataobject)) 						{ 							// Pac                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "Pac"' ObjectTypes.Sensor' "Pac"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.Pac' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'Pac'" + solarlog_dataobject.Pac + "'" + solarlog_dataobject.DateAndTime.Ticks'true)); 							// aPdc                              XS1_DataQueue.Enqueue(new XS1_DataObject(Properties.Settings.Default.SolarLogURLDomain' "aPdc"' ObjectTypes.Sensor' "aPdc"' solarlog_dataobject.DateAndTime' 1' solarlog_dataobject.aPdc' "solarlog'" + Properties.Settings.Default.SolarLogURLDomain + "'aPdc'" + solarlog_dataobject.aPdc+"'"+solarlog_dataobject.DateAndTime.Ticks'true));  							// if Alarming is enabled' queue this SolarLog Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(solarlog_dataobject); 							} 						} 					} 					#endregion  					#region Handle Network Monitor events 					if (Properties.Settings.Default.NetworkMonitorEnabled) 					{ 						NetworkMonitoringDataSet networkmonitor_dataobject = null; 						 						if(NetworkMonitor_Queue.TryDequeue(out networkmonitor_dataobject)) 						{ 							if (networkmonitor_dataobject.Status == Org.Mentalis.Network.ICMP_Status.Success) 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'1'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Online"'true)); 							else 								XS1_DataQueue.Enqueue(new XS1_DataObject(networkmonitor_dataobject.Descriptor'networkmonitor_dataobject.HostnameIP'ObjectTypes.Sensor'"Ping"'networkmonitor_dataobject.TimeOfMeasurement'2'0'"OnlineCheck'"+networkmonitor_dataobject.HostnameIP+"'"+networkmonitor_dataobject.Descriptor+"'Offline"'true));  							// if Alarming is enabled' queue this Network Monitor Event up for alarming... 							if (Properties.Settings.Default.AlarmingEnabled) 							{ 								Alarming_Queue.Enqueue(networkmonitor_dataobject); 							} 						} 					} 					#endregion                 }                 catch (Exception)                 {                                        AcceptingCommands = false;                     //Thread.Sleep(1);                 }                  Thread.Sleep(1);             }
Magic Number,hacs,LoggingThread,C:\repos\bietiekay_hacs\hacs\HandlingThread.cs,Run,The following statement contains a magic number: Thread.Sleep (200);
Magic Number,hacs,PowerSensorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\PowerSensor\PowerSensorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] PowerSensorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                    foreach (String LineElement in PowerSensorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                            PowerConsumptionSensor NewElement = new PowerConsumptionSensor();                          if (TokenizedLine.Length == 4)                         {                              NewElement.PowerSensorName = TokenizedLine[0];                             NewElement.InitialPowerSensorValue = Convert.ToDouble(TokenizedLine[2]);                              NewElement.Corrector = Convert.ToDouble(TokenizedLine[3]);                                if (DateTime.TryParse(TokenizedLine[1].Replace('_''' ')' out NewElement.InitialPowerSensorDate))                              {                                  PowerConsumptionSensors.Add(NewElement);                              }                             else                                 throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber+" - Could not parse DateTime"));                         }                         else                             throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Power Sensor Configuration File not found!"));             }
Magic Number,hacs,PowerSensorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\PowerSensor\PowerSensorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] PowerSensorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                    foreach (String LineElement in PowerSensorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                            PowerConsumptionSensor NewElement = new PowerConsumptionSensor();                          if (TokenizedLine.Length == 4)                         {                              NewElement.PowerSensorName = TokenizedLine[0];                             NewElement.InitialPowerSensorValue = Convert.ToDouble(TokenizedLine[2]);                              NewElement.Corrector = Convert.ToDouble(TokenizedLine[3]);                                if (DateTime.TryParse(TokenizedLine[1].Replace('_''' ')' out NewElement.InitialPowerSensorDate))                              {                                  PowerConsumptionSensors.Add(NewElement);                              }                             else                                 throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber+" - Could not parse DateTime"));                         }                         else                             throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Power Sensor Configuration File not found!"));             }
Magic Number,hacs,PowerSensorConfiguration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\PowerSensor\PowerSensorConfiguration.cs,ReadConfiguration,The following statement contains a magic number: if (File.Exists(Configfilename))             {                 // get all lines from the                  String[] PowerSensorConfigFileContent = File.ReadAllLines(Configfilename);                 Int32 LineNumber = 0;                    foreach (String LineElement in PowerSensorConfigFileContent)                 {                                          String[] TokenizedLine = LineElement.Split(new char[1] { ' ' });                     LineNumber++;                      if (!LineElement.StartsWith("#"))                     {                            PowerConsumptionSensor NewElement = new PowerConsumptionSensor();                          if (TokenizedLine.Length == 4)                         {                              NewElement.PowerSensorName = TokenizedLine[0];                             NewElement.InitialPowerSensorValue = Convert.ToDouble(TokenizedLine[2]);                              NewElement.Corrector = Convert.ToDouble(TokenizedLine[3]);                                if (DateTime.TryParse(TokenizedLine[1].Replace('_''' ')' out NewElement.InitialPowerSensorDate))                              {                                  PowerConsumptionSensors.Add(NewElement);                              }                             else                                 throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber+" - Could not parse DateTime"));                         }                         else                             throw (new Exception("Power Sensor Configuration File - Error in line "+LineNumber));                     }                 }             }             else             {                 throw (new Exception("Power Sensor Configuration File not found!"));             }
Magic Number,hacs,MiataruThread,C:\repos\bietiekay_hacs\hacs\Devices\Miataru\MiataruThread.cs,Run,The following statement contains a magic number: while (!Shutdown) 			{ 				try 				{  					foreach(MiataruAccount Account in MiataruConfiguration.MiataruAccountConfigFile.MiataruAccounts) 					{  						// retrieve new data for this account... 						#region Retrieve Data 						List<MiataruLocation> Locations = client.GetLastLocationForDevice(Account.MiataruDeviceID'Account.MiataruServerURL); 						#endregion  						#region handle retrieved location data 						if (Locations != null) 						{ 							// create a MiataruDataObject out of the last known location 							MiataruDataObject retrievedData = new MiataruDataObject(Account.Name'Locations[0].Device'Locations[0].Timestamp'Locations[0].Latitude'Locations[0].Longitude'Locations[0].HorizontalAccuracy);   							if (CurrentLocations.ContainsKey(retrievedData.DeviceID)) 							{ 								// check if the coordinates have been updated... 								MiataruDataObject alreadyStored = CurrentLocations[Account.MiataruDeviceID];  								if ((alreadyStored.Latitude != retrievedData.Latitude)||(alreadyStored.Longitude != retrievedData.Longitude)) 								{ 									CurrentLocations[Account.MiataruDeviceID] = retrievedData; 									// store to disk 									miatarustore.Write(retrievedData.Serialize()); 									ConsoleOutputLogger.WriteLine("Miataru: "+retrievedData.AccountName+" - "+retrievedData.Latitude+"'"+retrievedData.Longitude+"'"+retrievedData.AccuracyInMeters); 								}  							} 							else 							{ 								// it's new! add it! 								CurrentLocations.Add(retrievedData.DeviceID' retrievedData); 								miatarustore.Write(retrievedData.Serialize());                                  ConsoleOutputLogger.WriteLine("Miataru: " + retrievedData.AccountName + " - " + retrievedData.Latitude + "'" + retrievedData.Longitude + "'" + retrievedData.AccuracyInMeters); 							} 						} 						else 						{ 							ConsoleOutputLogger.WriteLine("Miataru returned NULL for "+Account.MiataruDeviceID+" on "+Account.MiataruServerURL); 						} 						#endregion  					} 				} 				catch (Exception e) 				{                      ConsoleOutputLogger.WriteLine(e.Message+" - "+e.StackTrace); 					Thread.Sleep(100); 				} 				 				Thread.Sleep(MiataruUpdateTime); 			}
Magic Number,hacs.Devices.MQTTBinding,MQTT_Handling,C:\repos\bietiekay_hacs\hacs\Devices\MQTTBinding\MQTT_HandlingThread.cs,Run,The following statement contains a magic number: while (!Shutdown)              {                  Thread.Sleep(100);              }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,HandleXS1_TSV,C:\repos\bietiekay_hacs\hacs\Devices\XS1\HandleXS1_TSV.cs,HandleValue,The following statement contains a magic number: try              {              String[] SplittedLine = DataLine.Split(new char[1] { '\t' });                if (SplittedLine.Length != 14)                  return null;                XS1_DataObject newObject = new XS1_DataObject();                newObject.Name = SplittedLine[11];              newObject.Timecode = new DateTime(Convert.ToInt32(SplittedLine[1])' Convert.ToInt32(SplittedLine[2])' Convert.ToInt32(SplittedLine[3])' Convert.ToInt32(SplittedLine[5])' Convert.ToInt32(SplittedLine[6])' Convert.ToInt32(SplittedLine[7]));                            switch (SplittedLine[9])              {                  case "A":                      newObject.Type = ObjectTypes.Actor;                      break;                  case "S":                      newObject.Type = ObjectTypes.Sensor;                      break;                  default:                      newObject.Type = ObjectTypes.Unknown;                      break;              }                newObject.TypeName = SplittedLine[12];              newObject.Value = Convert.ToDouble(SplittedLine[13]'System.Globalization.CultureInfo.InvariantCulture.NumberFormat);              newObject.XS1ObjectID = Convert.ToInt32(SplittedLine[10]);                return newObject;              }              catch(Exception)              {                            }
Magic Number,hacs.xs1,XS1_DataObject,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1_DataObject.cs,Serialize,The following statement contains a magic number: if (Type == ObjectTypes.Actor)                 writer.WriteObject((byte)0);             else             if (Type == ObjectTypes.Sensor)                 writer.WriteObject((byte)1);             else             if (Type == ObjectTypes.Unknown)                 writer.WriteObject((byte)2);
Magic Number,hacs.xs1,XS1_DataObject,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1_DataObject.cs,Deserialize,The following statement contains a magic number: if (_Type == 0)                 Type = ObjectTypes.Actor;             else                 if (_Type == 1)                     Type = ObjectTypes.Sensor;                 else                     if (_Type == 2)                         Type = ObjectTypes.Unknown;
Magic Number,hacs.xs1.configuration,XS1Configuration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1-Configuration.cs,getXS1ActuatorList,The following statement contains a magic number: ser.MaxJsonLength = 20000000;
Magic Number,hacs.xs1.configuration,XS1Configuration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1-Configuration.cs,getXS1ActuatorList,The following statement contains a magic number: actuator_config_json = actuator_config_json.Remove(actuator_config_json.Length - 4' 4);
Magic Number,hacs.xs1.configuration,XS1Configuration,C:\repos\bietiekay_hacs\hacs\Devices\XS1\XS1-Configuration.cs,getXS1ActuatorList,The following statement contains a magic number: actuator_config_json = actuator_config_json.Remove(actuator_config_json.Length - 4' 4);
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,process,The following statement contains a magic number: try 			{ 				// Increment the number of current connections 				Interlocked.Increment(ref threads); 				// Bundle up our sockets nice and tight in various streams 				ns = new NetworkStream(s' FileAccess.ReadWrite); 				// It looks like these streams buffer 				sr = new StreamReader(ns); 				sw = new StreamWriter(ns); 				// Parse the request' if that succeeds' read the headers' if that 				// succeeds' then write the given URL to the stream' if possible. 				while (parseRequest()) 				{ 					if (readHeaders()) 					{  						AuthenticatedSuccessfully = true; 						#region Authentification 						if (AuthorizationEnabled) 						{ 							AuthenticatedSuccessfully = false; 							if (headers.ContainsKey("Authorization")) 							{ 								String encodedInputPW = (String)headers["Authorization"]; 								// remove first 6 bytes..."Basic asfasfasfasfdsdf==" 								encodedInputPW = encodedInputPW.Remove(0'6);  								string decoded = Encoding.UTF8.GetString(Convert.FromBase64String(encodedInputPW)); 								int position = decoded.IndexOf(':'); 								if (position == -1) 								{ 									AuthenticatedSuccessfully = false; 									writeError(401'"Authorization header not correct set"); 								}  								string password = decoded.Substring(position + 1' decoded.Length - position - 1); 								string userName = decoded.Substring(0' position);  								if ((Username == userName) && (Password == password)) 									AuthenticatedSuccessfully = true; 							} 							else 							{ 								AuthenticatedSuccessfully = false; 							} 						} 						#endregion  						// This makes sure we don't have too many persistent connections and also 						// checks to see if the client can maintain keep-alive' if so then we will 						// keep this http processor around to process again. 						if (threads <= 100 && "Keep-Alive".Equals(headers["Connection"])) 						{ 							keepAlive = true; 						} 						// Copy the file to the socket 						writeURL(); 						// If keep alive is not active then we want to close down the streams 						// and shutdown the socket 						if (!keepAlive) 						{ 							ns.Close(); 							try 							{ 								s.Shutdown(SocketShutdown.Both); 							} 							catch (Exception) { } 							break; 						} 					} 				} 			} 			finally 			{ 				// Always decrement the number of connections 				Interlocked.Decrement(ref threads); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,process,The following statement contains a magic number: try 			{ 				// Increment the number of current connections 				Interlocked.Increment(ref threads); 				// Bundle up our sockets nice and tight in various streams 				ns = new NetworkStream(s' FileAccess.ReadWrite); 				// It looks like these streams buffer 				sr = new StreamReader(ns); 				sw = new StreamWriter(ns); 				// Parse the request' if that succeeds' read the headers' if that 				// succeeds' then write the given URL to the stream' if possible. 				while (parseRequest()) 				{ 					if (readHeaders()) 					{  						AuthenticatedSuccessfully = true; 						#region Authentification 						if (AuthorizationEnabled) 						{ 							AuthenticatedSuccessfully = false; 							if (headers.ContainsKey("Authorization")) 							{ 								String encodedInputPW = (String)headers["Authorization"]; 								// remove first 6 bytes..."Basic asfasfasfasfdsdf==" 								encodedInputPW = encodedInputPW.Remove(0'6);  								string decoded = Encoding.UTF8.GetString(Convert.FromBase64String(encodedInputPW)); 								int position = decoded.IndexOf(':'); 								if (position == -1) 								{ 									AuthenticatedSuccessfully = false; 									writeError(401'"Authorization header not correct set"); 								}  								string password = decoded.Substring(position + 1' decoded.Length - position - 1); 								string userName = decoded.Substring(0' position);  								if ((Username == userName) && (Password == password)) 									AuthenticatedSuccessfully = true; 							} 							else 							{ 								AuthenticatedSuccessfully = false; 							} 						} 						#endregion  						// This makes sure we don't have too many persistent connections and also 						// checks to see if the client can maintain keep-alive' if so then we will 						// keep this http processor around to process again. 						if (threads <= 100 && "Keep-Alive".Equals(headers["Connection"])) 						{ 							keepAlive = true; 						} 						// Copy the file to the socket 						writeURL(); 						// If keep alive is not active then we want to close down the streams 						// and shutdown the socket 						if (!keepAlive) 						{ 							ns.Close(); 							try 							{ 								s.Shutdown(SocketShutdown.Both); 							} 							catch (Exception) { } 							break; 						} 					} 				} 			} 			finally 			{ 				// Always decrement the number of connections 				Interlocked.Decrement(ref threads); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,process,The following statement contains a magic number: try 			{ 				// Increment the number of current connections 				Interlocked.Increment(ref threads); 				// Bundle up our sockets nice and tight in various streams 				ns = new NetworkStream(s' FileAccess.ReadWrite); 				// It looks like these streams buffer 				sr = new StreamReader(ns); 				sw = new StreamWriter(ns); 				// Parse the request' if that succeeds' read the headers' if that 				// succeeds' then write the given URL to the stream' if possible. 				while (parseRequest()) 				{ 					if (readHeaders()) 					{  						AuthenticatedSuccessfully = true; 						#region Authentification 						if (AuthorizationEnabled) 						{ 							AuthenticatedSuccessfully = false; 							if (headers.ContainsKey("Authorization")) 							{ 								String encodedInputPW = (String)headers["Authorization"]; 								// remove first 6 bytes..."Basic asfasfasfasfdsdf==" 								encodedInputPW = encodedInputPW.Remove(0'6);  								string decoded = Encoding.UTF8.GetString(Convert.FromBase64String(encodedInputPW)); 								int position = decoded.IndexOf(':'); 								if (position == -1) 								{ 									AuthenticatedSuccessfully = false; 									writeError(401'"Authorization header not correct set"); 								}  								string password = decoded.Substring(position + 1' decoded.Length - position - 1); 								string userName = decoded.Substring(0' position);  								if ((Username == userName) && (Password == password)) 									AuthenticatedSuccessfully = true; 							} 							else 							{ 								AuthenticatedSuccessfully = false; 							} 						} 						#endregion  						// This makes sure we don't have too many persistent connections and also 						// checks to see if the client can maintain keep-alive' if so then we will 						// keep this http processor around to process again. 						if (threads <= 100 && "Keep-Alive".Equals(headers["Connection"])) 						{ 							keepAlive = true; 						} 						// Copy the file to the socket 						writeURL(); 						// If keep alive is not active then we want to close down the streams 						// and shutdown the socket 						if (!keepAlive) 						{ 							ns.Close(); 							try 							{ 								s.Shutdown(SocketShutdown.Both); 							} 							catch (Exception) { } 							break; 						} 					} 				} 			} 			finally 			{ 				// Always decrement the number of connections 				Interlocked.Decrement(ref threads); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (threads > 500) 			{ 				writeError(502' "Server temporarily overloaded"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (threads > 500) 			{ 				writeError(502' "Server temporarily overloaded"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (tokens.Length != 3) 			{ 				writeError(400' "Bad request"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (tokens.Length != 3) 			{ 				writeError(400' "Bad request"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (!method.Equals("GET")) 			{ 				writeError(501' method + " not implemented"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (!url.StartsWith("/")) 			{ 				writeError(400' "Bad URL"); 				return false; 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: protocol = tokens[2];
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,parseRequest,The following statement contains a magic number: if (!protocol.StartsWith("HTTP/")) 			{ 				writeError(400' "Bad protocol: " + protocol); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,readHeaders,The following statement contains a magic number: while ((line = sr.ReadLine()) != null && line != "") 			{ 				// If the value begins with a space or a hard tab then this 				// is an extension of the value of the previous header and 				// should be appended 				if (name != null && Char.IsWhiteSpace(line[0])) 				{ 					headers[name] += line; 					continue; 				} 				// Headers consist of [NAME]: [VALUE] + possible extension lines 				int firstColon = line.IndexOf(":"); 				if (firstColon != -1) 				{ 					name = line.Substring(0' firstColon); 					String value = line.Substring(firstColon + 1).Trim(); 					//if (internalSettings.WebServer.verboseLogging) ConsoleOutputLogger.WriteLine(name + ": " + value); 					headers[name] = value; 				} 				else 				{ 					writeError(400' "Bad header: " + line); 					return false; 				} 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The following statement contains a magic number: try 			{                 // set this to true when implementing and reaching a new method                 bool method_found = false;  				// first check if the request is actually authenticated 				IPEndPoint AC_endpoint = (IPEndPoint)s.RemoteEndPoint;                  ConsoleOutputLogger.WriteLine(AC_endpoint.Address.ToString() + " GET " + original_url);  				//if (!HTTPAuthProcessor.AllowedToAccessThisServer(AC_endpoint.Address)) 				//{ 				//    // now give the user a 403 and break... 				//    writeForbidden(); 				//    ns.Flush(); 				//    return; 				//}  				//querystring = ""; 				url = original_url;  				#region Authentification                  if (AC_endpoint.Address.ToString().StartsWith(AuthDisabledForAdressesThatStartWith))                      AuthenticatedSuccessfully = true;  				if (AuthorizationEnabled) 				{ 					if (!AuthenticatedSuccessfully) 					{ 						writeNotAuthorized("hacs"); 					} 				} 				#endregion  				if (internal_proxy.isThisAProxyURL(url)) 				{ 					ProxyResponse proxy_response = internal_proxy.Proxy(url);  					if (proxy_response == null) 					{ 						writeError(500' "Proxy Activation URL not found"); 						return; 					}  					int left = new UTF8Encoding().GetByteCount(proxy_response.Content); 					writeSuccess(left' "text/html"); 					byte[] buffer = new UTF8Encoding().GetBytes(proxy_response.Content); 					ns.Write(buffer' 0' left); 					ns.Flush();                      return; 				}                    #region NUMERICS JSON data implementation                  if (url.ToUpper().StartsWith("/NUMERICS/"))                  {                      #region data request                      // remove the /data/ stuff                      url = url.Remove(0' 10);                        #region Sensor Data                      if (url.ToUpper().StartsWith("SENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 6);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            String ObjectTypeName = "";                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true;                          }                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");                            if (ObjectTypeName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                          String Output;                          if (!JustLastEntry)                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName' start' end);                          else                              Output = NumericsJSON_Data.GenerateDataNumericsJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);                            int left = new UTF8Encoding().GetByteCount(Output);                          //writeSuccess(left' "application/json");                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;                            if (OutputType.ToUpper() == "CALCWEEKLYKWH")                              Outputs = PowerSensorOutputs.CalculateWeeklykWh;                            if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = NumericsJSON_Data.GeneratePowerSensorNumericsJSONOutput(Outputs' ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion                        #region Actor Data                      if (url.ToUpper().StartsWith("ACTOR"))                      {                          method_found = true;                          url = url.Remove(0' 5);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String ObjectName = "";                          String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;                            foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "OUTPUTTYPE")                                  OutputType = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                            if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          }                            // now we should have a name we need to look up                          //bool foundactor = false;                            // get the XS1 Actuator List to find the ID and the Preset ID                          XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password);                            foreach (XS1Actuator _actuator in actuatorlist.actuator)                          {                              if (_actuator.name.ToUpper() == ObjectName.ToUpper())                              {                                  // we found one!                                  //foundactor = true;                                    // TODO: we need to output a JSON dataset here                                  //                                bool Status = false;                                  //                                  //                                if (_actuator.value == 0.0)                                  //                                    Status = false;                                  //                                else                                  //                                    Status = true;                                    String Output = NumericsJSON_Data.GenerateNumericsJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return;                              }                          }                        }                      #endregion                        if (!method_found)                      {                          // nothing to do...                          writeError(404' "No Method found");                      }                      #endregion                  }                  #endregion                    #region JSON data implementation                  if (url.ToUpper().StartsWith("/DATA/")) 				{ 					#region data request 					// remove the /data/ stuff 					url = url.Remove(0' 6);  					#region Swimlane - All Sensors 					// this is a swimlane diagram containing for now containing all switches in the given household 					// TODO: do something more useful here 					if (url.ToUpper().StartsWith("SWIMLANE")) 					{ 						String ObjectTypeName = ""; 						String ObjectName = ""; 						String StartDate = ""; 						String EndDate = ""; 						DateTime start = DateTime.Now; 						DateTime end = DateTime.Now;  						method_found = true; 						#region Querystring Handling 						url = url.Remove(0'8); 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key]; 							if (Key.ToUpper() == "START") 								StartDate = nvcollection[Key]; 							if (Key.ToUpper() == "END") 								EndDate = nvcollection[Key]; 						}  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (StartDate == "") // defaults 						{ 							start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = StartDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								start = new DateTime(year' month' day); 							} 							else 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						} 						 						if (EndDate == "") 						{ 							end = DateTime.Now; 						} 						else 						{ 							// parse the date and set it... 							// since we are only interested in the day' month and year it's necessary to only parse that 							// we expect the following format: day-month-year 							// for example: 12-01-2012 will be 12th of January 2012 							String[] Splitted = EndDate.Split(new char[1] { '-' }); 							 							if (Splitted.Length == 3) 							{ 								Int32 year = Convert.ToInt32(Splitted[2]); 								Int32 month = Convert.ToInt32(Splitted[1]); 								Int32 day = Convert.ToInt32(Splitted[0]); 								 								end = new DateTime(year' month' day); 							} 							else 							{ 								end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 						}  						#endregion  						String Output = GenerateSwimlane.Generate(ELVMAX'SensorDataStore'ObjectName'ObjectTypeName'start'end);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return;  					} 					#endregion  					#region Sensor Data 					if (url.ToUpper().StartsWith("SENSOR")) 					{ 						method_found = true; 						url = url.Remove(0'6); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 						String ObjectTypeName = ""; 						String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          Boolean JustLastEntry = false;                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "TYPE") 								ObjectTypeName = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                              if (Key.ToUpper() == "LASTENTRY")                                  JustLastEntry = true; 						}                          //ConsoleOutputLogger.WriteLineToScreenOnly("...");  						if (ObjectTypeName == "") 						{ 							writeError(404' "No Method found"); 							return; 						} 						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            //ConsoleOutputLogger.WriteLineToScreenOnly("...");                         String Output;                         if (!JustLastEntry) 						    Output = JSON_Data.GenerateDataJSONOutput(ObjectTypes.Sensor' ObjectTypeName' ObjectName'start'end);                         else                              Output = JSON_Data.GenerateDataJSONOutput_LastEntryOnly(ObjectTypes.Sensor' ObjectTypeName' ObjectName);  						int left = new UTF8Encoding().GetByteCount(Output); 						//writeSuccess(left' "application/json"); 						writeSuccess(left' "text/html"); 						byte[] buffer = new UTF8Encoding().GetBytes(Output); 						ns.Write(buffer' 0' left); 						ns.Flush(); 						return; 					} 					#endregion   					/*					#region Google Latitude 					if (hacs.Properties.Settings.Default.GoogleLatitudeEnabled) 					{ 						if (url.ToUpper().StartsWith("GEOLOCATION")) 						{ 							method_found = true; 							url = url.Remove(0' 11); 							 							NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 							 							// TODO: ADD handling and calculation here 							String ObjectName = ""; 							String StartDate = ""; 							String EndDate = ""; 							//String OutputType = ""; 							DateTime start = DateTime.Now; 							DateTime end = DateTime.Now; 							Boolean JustLastEntry = false;  							#region Querystring handling 							foreach (String Key in nvcollection.AllKeys) 							{ 								if (Key.ToUpper() == "NAME") 									ObjectName = nvcollection[Key]; 								if (Key.ToUpper() == "START") 									StartDate = nvcollection[Key]; 								if (Key.ToUpper() == "END") 									EndDate = nvcollection[Key]; 								if (Key.ToUpper() == "LASTENTRY") 									JustLastEntry = true; 							} 							 							if (ObjectName == "") 							{ 								writeError(404' "No Method found"); 								return; 							} 							if (StartDate == "") // defaults 							{ 								start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = StartDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									start = new DateTime(year' month' day); 								} 								else 								{ 									start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							 							if (EndDate == "") 							{ 								end = DateTime.Now; 							} 							else 							{ 								// parse the date and set it... 								// since we are only interested in the day' month and year it's necessary to only parse that 								// we expect the following format: day-month-year 								// for example: 12-01-2012 will be 12th of January 2012 								String[] Splitted = EndDate.Split(new char[1] { '-' }); 								 								if (Splitted.Length == 3) 								{ 									Int32 year = Convert.ToInt32(Splitted[2]); 									Int32 month = Convert.ToInt32(Splitted[1]); 									Int32 day = Convert.ToInt32(Splitted[0]); 									 									end = new DateTime(year' month' day); 								} 								else 								{ 									end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0)); 								} 							} 							#endregion  							String Output = "";  							if (JustLastEntry) 								Output = LatitudeGeoLocation.GenerateJSON_LastEntry(ObjectName); 							 							int left = new UTF8Encoding().GetByteCount(Output); 							writeSuccess(left' "text/html"); 							byte[] buffer = new UTF8Encoding().GetBytes(Output); 							ns.Write(buffer' 0' left); 							ns.Flush();  							return; 						} 					} 					#endregion */                      #region Power Sensor Data                      if (url.ToUpper().StartsWith("POWERSENSOR"))                      {                          method_found = true;                          url = url.Remove(0' 11);                            NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                            // TODO: ADD handling and calculation here                          String ObjectName = "";                          String StartDate = "";                          String EndDate = "";                          String OutputType = "";                          DateTime start = DateTime.Now;                          DateTime end = DateTime.Now;                          PowerSensorOutputs Outputs = PowerSensorOutputs.HourkWh;                                                    foreach (String Key in nvcollection.AllKeys)                          {                              if (Key.ToUpper() == "NAME")                                  ObjectName = nvcollection[Key];                              if (Key.ToUpper() == "TYPE")                                  OutputType = nvcollection[Key];                              if (Key.ToUpper() == "START")                                  StartDate = nvcollection[Key];                              if (Key.ToUpper() == "END")                                  EndDate = nvcollection[Key];                          }                            if (ObjectName == "")                          {                              writeError(404' "No Method found");                              return;                          }                          if (StartDate == "") // defaults                          {                              start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = StartDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    start = new DateTime(year' month' day);                              }                              else                              {                                  start = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                            if (EndDate == "")                          {                              end = DateTime.Now;                          }                          else                          {                              // parse the date and set it...                              // since we are only interested in the day' month and year it's necessary to only parse that                              // we expect the following format: day-month-year                              // for example: 12-01-2012 will be 12th of January 2012                              String[] Splitted = EndDate.Split(new char[1] { '-' });                                if (Splitted.Length == 3)                              {                                  Int32 year = Convert.ToInt32(Splitted[2]);                                  Int32 month = Convert.ToInt32(Splitted[1]);                                  Int32 day = Convert.ToInt32(Splitted[0]);                                    end = new DateTime(year' month' day);                              }                              else                              {                                  end = DateTime.Now - (new TimeSpan(hacs.Properties.Settings.Default.DefaultSensorOutputPeriod' 0' 0' 0));                              }                          }                              if (OutputType.ToUpper() == "HOUR")                              Outputs = PowerSensorOutputs.HourkWh;                            if (OutputType.ToUpper() == "HOURPEAK")                              Outputs = PowerSensorOutputs.HourPeakkWh;                            if (OutputType.ToUpper() == "CALCKWH")                              Outputs = PowerSensorOutputs.CalculatedkWhCounterTotal;   						if (OutputType.ToUpper() == "CALCWEEKLYKWH") 							Outputs = PowerSensorOutputs.CalculateWeeklykWh;                           if (OutputType.ToUpper() == "CALCDAILYKWH")                              Outputs = PowerSensorOutputs.CalculatedDailykWh;                            if (OutputType.ToUpper() == "CALCHOURLYKWH")                              Outputs = PowerSensorOutputs.CalculatedHourlykWh;                            String Output = JSON_Data.GeneratePowerSensorJSONOutput(Outputs'ObjectName' start' end);                            int left = new UTF8Encoding().GetByteCount(Output);                          writeSuccess(left' "text/html");                          byte[] buffer = new UTF8Encoding().GetBytes(Output);                          ns.Write(buffer' 0' left);                          ns.Flush();                          return;                      }                      #endregion  					#region Actor Data 					if (url.ToUpper().StartsWith("ACTOR")) 					{ 						method_found = true; 						url = url.Remove(0'5); 						 						NameValueCollection nvcollection = HttpUtility.ParseQueryString(url); 						String ObjectName = ""; 						String OutputType = "";                          ActorsStatusOutputTypes ActorOutputType = ActorsStatusOutputTypes.Binary;  						foreach (String Key in nvcollection.AllKeys) 						{ 							if (Key.ToUpper() == "NAME") 								ObjectName = nvcollection[Key]; 							if (Key.ToUpper() == "OUTPUTTYPE") 								OutputType = nvcollection[Key]; 						}  						if (ObjectName == "") 						{ 							writeError(404' "No Method found"); 							return; 						}                          if (OutputType != "")                          {                              if (OutputType.ToUpper() == "BINARY")                                  ActorOutputType = ActorsStatusOutputTypes.Binary;                                if (OutputType.ToUpper() == "TRUEFALSE")                                  ActorOutputType = ActorsStatusOutputTypes.TrueFalse;                                if (OutputType.ToUpper() == "ONOFF")                                  ActorOutputType = ActorsStatusOutputTypes.OnOff;                          } 						 						// now we should have a name we need to look up 						//bool foundactor = false; 						 						// get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);  						foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == ObjectName.ToUpper())                             { 								// we found one! 								//foundactor = true; 								 								// TODO: we need to output a JSON dataset here  //                                bool Status = false;  //  //                                if (_actuator.value == 0.0)  //                                    Status = false;  //                                else  //                                    Status = true;                                    String Output = JSON_Data.GenerateJSONDataActorStatus(ActorOutputType' _actuator.name);                                    int left = new UTF8Encoding().GetByteCount(Output);                                  writeSuccess(left' "text/html");                                  byte[] buffer = new UTF8Encoding().GetBytes(Output);                                  ns.Write(buffer' 0' left);                                  ns.Flush();                                  return; 							} 						} 						 					} 					#endregion  					if (!method_found) 					{ 						// nothing to do... 						writeError(404' "No Method found"); 					} 					#endregion                  }                  #endregion                    #region ACTOR switching requests                  if (url.ToUpper().StartsWith("/ACTOR/")) 				{ 					#region actor switching request                     // /actor/preset?name=[actor_name]&preset=[preset_function_name]                     // /actor/direct?name=[actor_name]&value=[new_actor_value]                      // remove the /actor/ stuff                     url = url.Remove(0' 7);                      #region Preset Mode                     if (url.ToUpper().StartsWith("PRESET"))                     {                         method_found = true;                         url = url.Remove(0' 6);                          NameValueCollection nvcollection = HttpUtility.ParseQueryString(url);                          String actorname = "";                         String preset = "";                          foreach (String Key in nvcollection.AllKeys)                         {                             if (Key.ToUpper() == "NAME")                                 actorname = nvcollection[Key];                             if (Key.ToUpper() == "PRESET")                                 preset = nvcollection[Key];                         }                          Int32 foundActorID = 0;                         Int32 foundPresetID = 0;                          #region error handling                         if (actorname == "")                         {                             writeError(404' "No Method found");                             return;                         }                         if (preset == "")                         {                             writeError(404' "No Method found");                             return;                         }                         #endregion                          // get the XS1 Actuator List to find the ID and the Preset ID                         XS1ActuatorList actuatorlist = XS1_Configuration.getXS1ActuatorList(hacs.Properties.Settings.Default.XS1'hacs.Properties.Settings.Default.Username'hacs.Properties.Settings.Default.Password);                          bool foundatleastoneactuator = false;                         //                         foreach (XS1Actuator _actuator in actuatorlist.actuator)                         {                             if (_actuator.name.ToUpper() == actorname.ToUpper())                             {                                 foundActorID = _actuator.id;                                  bool foundpreset = false;                                  foreach (actuator_function actorfunction in _actuator.function)                                 {                                     foundPresetID++;                                      if (actorfunction.type.ToUpper() == preset.ToUpper())                                     {                                         foundpreset = true;                                         break;                                     }                                 }                                  #region error handling                                 if (foundpreset)                                 {                                     if (foundActorID != 0)                                     {                                         // so we obviously got the actor and the preset id... now lets do the call                                         set_state_actuator ssa = new set_state_actuator();                                         ssa.SetStateActuatorPreset(hacs.Properties.Settings.Default.XS1' hacs.Properties.Settings.Default.Username' hacs.Properties.Settings.Default.Password' foundActorID' foundPresetID);                                         foundatleastoneactuator = true;                                         break;                                     }                                 }                                 #endregion                             }                         }                         if (!foundatleastoneactuator)                         {                             writeError(404' "actor or function not found");                             return;                         }                     }                     else                         if (url.ToUpper().StartsWith("DIRECT"))                         {                          }                     #endregion                      if (!method_found)                     {                         // nothing to do...                         writeError(404' "No Method found");                         return;                     } 					#endregion                  }                  #endregion                  else 				{ 					#region File request (everything else...)  					#region default page 					if (url == "/") 					{ 						url = "/index.html"; 					} 					#endregion  					// check if we have some querystring parameters 					if (url.Contains("?")) 					{ 						// yes' remove everything after the ? from the url but save it to querystring 						//querystring = url.Substring(url.IndexOf('?') + 1); 						url = url.Remove(url.IndexOf('?')); 					}  					// Replace the forward slashes with back-slashes to make a file name 					string filename = url.Replace('/'' Path.DirectorySeparatorChar); //you have different path separators in unix and windows 					try 					{ 						// Construct a filename from the doc root and the filename 						FileInfo file = new FileInfo(docRootFile + filename); 						// Make sure they aren't trying in funny business by checking that the 						// resulting canonical name of the file has the doc root as a subset. 						filename = file.FullName; 						if (!filename.StartsWith(docRootFile.FullName)) 						{ 							writeForbidden(); 						} 						else 						{ 							FileStream fs = null; 							BufferedStream bs = null; 							long bytesSent = 0; 							//bool resumed = false;  							try 							{ 								if (filename.EndsWith(".log")) 								{ 									// now give the user a 403 and break... 									writeForbidden(); 									ns.Flush(); 								} 								else 									if (filename.EndsWith(".html") | (filename.EndsWith(".htm"))) 									{ 										//  										String Output = File.ReadAllText(filename);  										int left = new UTF8Encoding().GetByteCount(Output); 										writeSuccess(left' "text/html"); 										byte[] buffer = new UTF8Encoding().GetBytes(Output); 										ns.Write(buffer' 0' left); 										ns.Flush(); 									} 									else 									{ 										// Open the file for binary transfer 										fs = new FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  										long left = file.Length; 										//bool isThisARecordingRecording = false;  										#region different mime-type-handling 										switch (getFileExtension(filename)) 										{ 											case ".css": 												writeSuccess(left' "text/css"); 												break; 											case ".gif": 												writeSuccess(left' "image/gif"); 												break; 											case ".png": 												writeSuccess(left' "image/png"); 												break; 											case ".jpg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".jpeg": 												writeSuccess(left' "image/jpeg"); 												break; 											case ".ico": 												writeSuccess(left' "image/ico"); 												break; 											default: 												// Write the content length and the success header to the stream; it's binary...so treat it as binary 												writeSuccess(left' "application/octet-stream"); 												break; 										} 										#endregion  										// Copy the contents of the file to the stream' ensure that we never write 										// more than the content length we specified.  Just in case the file somehow 										// changes out from under us' although I don't know if that is possible. 										bs = new BufferedStream(fs); 										left = file.Length;  										// for performance reasons... 										int read; 										while (left > 0 && (read = bs.Read(bytes' 0' (int)Math.Min(left' bytes.Length))) != 0) 										{ 											ns.Write(bytes' 0' read); 											bytesSent = bytesSent + read; 											left -= read; 										} 										ns.Flush(); 										bs.Close(); 										fs.Close(); 									} 							} 							catch (Exception e) 							{ 								ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 								try 								{ 									writeFailure(); 								} 								catch (Exception) 								{ 									ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] connection lost to client"); 								} 								if (bs != null) bs.Close(); 								if (bs != null) fs.Close(); 							}  						} 					} 					catch (Exception e) 					{ 						ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message); 						writeFailure(); 					} 					#endregion 				} 			} 			catch (Exception e) 			{ 				ConsoleOutputLogger.WriteLineToScreenOnly("[FEHLER@HTTP] " + e.Message+" ## "+e.StackTrace); 				writeFailure(); 			}
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeSuccess,The following statement contains a magic number: writeResult(200' "OK"' length' mimetype);
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeSuccess,The following statement contains a magic number: writeResult(200' "OK"' length);
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeFailure,The following statement contains a magic number: writeError(404' "File not found");
Magic Number,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeForbidden,The following statement contains a magic number: writeError(403' "Forbidden");
Magic Number,HTTP,HttpServer,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPServer.cs,listen,The following statement contains a magic number: try             {                 // Create a new server socket' set up all the endpoints' bind the socket and then listen                 listener.Bind(endpoint);                 listener.Blocking = true;                 listener.Listen(-1);                 ConsoleOutputLogger.WriteLineToScreenOnly("[HTTP] AdministrationsoberflÃ¤che unter http://" + HTTPServer_ListeningIP+ ":" + HTTPServer_Port+ " erreichbar.");                 while (true)                 {                     try                     {                         // Accept a new connection from the net' blocking till one comes in                         Socket s = listener.Accept();                          // Create a new processor for this request                         HttpProcessor processor = new HttpProcessor(s' HTTPServer_DocumentRoot'Storage'LatitudeStorage'XS1_Configuration' ConsoleOutputLogger' ELVMAXMonitoringThread' AuthorizationEnabled'Username'Password' AuthDisabledForAdressesThatStartWith);                          // Dispatch that processor in its own thread                         Thread thread = new Thread(new ThreadStart(processor.process));                         thread.Start();                         Thread.Sleep(10);                         //processor.process();                      }                     catch (NullReferenceException)                     {                         // Don't even ask me why they throw this exception when this happens                         ConsoleOutputLogger.WriteLine("[FEHLER@HTTP] Kann nicht auf TCP-Port " + HTTPServer_Port+ " verbinden - wird vermutlich schon benutzt.");                     }                 }             }             catch (Exception e)             {                 ConsoleOutputLogger.WriteLine("[FEHLER@HTTP] " + e.Message);             }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.HourkWh)              {                  #region Hour kWh                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  UInt64 SerializerCounter = 0;                    lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          { 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{  	                                            Output2.Clear();  	                                            Output2.Append("[");  	                                            Output2.Append(dataobject.Timecode.JavaScriptTimestamp());  	                                            Output2.Append("'");  	                                            //Double Value = dataobject.Value / 1000;  	                                            Output2.Append(dataobject.Value.ToString().Replace('''' '.'));  	                                            Output2.Append("]"); 											}                                          }                                        }                                  }                              }                          }                      }                  }                  Output.Append(Output2.ToString());                  #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.HourPeakkWh)              {                  #region Hour Peak kWh                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  UInt64 SerializerCounter = 0;                    lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_peak")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  Output2.Clear();                                                  Output2.Append("[");                                                  Output2.Append(dataobject.Timecode.JavaScriptTimestamp());                                                  Output2.Append("'");                                                  //Double Value = dataobject.Value / 1000;                                                    Output2.Append(dataobject.Value.ToString().Replace('''' '.'));                                                  Output2.Append("]");                                              }                                          }                                      }                                  }                              }                          }                      }                  }                  Output.Append(Output2.ToString());                  #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.HourkWh)              {                  #region Hour kWh                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  UInt64 SerializerCounter = 0;                    lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          { 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{  	                                            Output2.Clear();  	                                            Output2.Append("[");  	                                            Output2.Append(dataobject.Timecode.JavaScriptTimestamp());  	                                            Output2.Append("'");  	                                            //Double Value = dataobject.Value / 1000;  	                                            Output2.Append(dataobject.Value.ToString().Replace('''' '.'));  	                                            Output2.Append("]"); 											}                                          }                                        }                                  }                              }                          }                      }                  }                  Output.Append(Output2.ToString());                  #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.HourPeakkWh)              {                  #region Hour Peak kWh                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  UInt64 SerializerCounter = 0;                    lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_peak")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  Output2.Clear();                                                  Output2.Append("[");                                                  Output2.Append(dataobject.Timecode.JavaScriptTimestamp());                                                  Output2.Append("'");                                                  //Double Value = dataobject.Value / 1000;                                                    Output2.Append(dataobject.Value.ToString().Replace('''' '.'));                                                  Output2.Append("]");                                              }                                          }                                      }                                  }                              }                          }                      }                  }                  Output.Append(Output2.ToString());                  #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedkWhCounterTotal)              {                  #region Calculated kWh Counter (based on last known manual reading)                  UInt64 SerializerCounter = 0;                    // find the right sensor manual reading...                  foreach (PowerConsumptionSensor _manual_reading in PowerSensorConfiguration.PowerConsumptionSensors)                  {                      DateTime ManualMeasurementDate = DateTime.MinValue;                      Double ManualMeasurementValue = Double.MinValue;                        Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                          if (_manual_reading.PowerSensorName == ObjectName)                      {                          ManualMeasurementDate = _manual_reading.InitialPowerSensorDate;                          ManualMeasurementValue = _manual_reading.InitialPowerSensorValue;                            // here comes the fun                          StartDateTime = ManualMeasurementDate;                          Double PowerSensorCalculatedValue = ManualMeasurementValue;                          DateTime CurrentHourStart = StartDateTime;                          Double CurrentHourMeanValue = Double.MinValue;                          #region the lock                          lock (sensor_data.InMemoryIndex)                          {                              foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                              {                                  if (ondisc.CreationTime >= StartDateTime.Ticks)                                  {                                      if (ondisc.CreationTime <= EndDateTime.Ticks)                                      {  										XS1_DataObject dataobject = ReadFromCache(ondisc); 										SerializerCounter++;                                            if (dataobject.Type == ObjectTypes.Sensor)                                          {                                              if (dataobject.TypeName == "pwr_consump")                                              {                                                  if (dataobject.Name == ObjectName)                                                  {                                                      // only up to a certain amount we consider this a valid value... 											        if (dataobject.Value < 15000) 											        {                                                      // okay' we got the right sensor data element type with the right name...                                                             // calculate the time difference between hour start and current data object                                                          TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                            if (ts.TotalMinutes >= 60)                                                          {                                                              // we have a full hour...add to the calculated value and reset hour values                                                              CurrentHourStart = dataobject.Timecode;                                                              PowerSensorCalculatedValue += CurrentHourMeanValue / 1000;                                                              //Console.WriteLine(" -> " + PowerSensorCalculatedValue + " : "+CurrentHourMeanValue + "("+dataobject.Timecode.ToShortDateString()+")");                                                              CurrentHourMeanValue = Double.MinValue;                                                          }                                                          else                                                          {                                                              if (CurrentHourMeanValue == Double.MinValue)                                                                  CurrentHourMeanValue = dataobject.Value;                                                              else                                                              {                                                                  CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                              }                                                          }                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                          #endregion                          // add the corrector value                          PowerSensorCalculatedValue = PowerSensorCalculatedValue + _manual_reading.Corrector;                            Output.Append("[");                          Output.Append(DateTime.Now.JavaScriptTimestamp());                          Output.Append("'");                          Output.Append(PowerSensorCalculatedValue.ToString().Replace('''' '.'));                          Output.Append("]");                                          }                  }                 #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedDailykWh)              {                  #region Calculated Daily kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      Double DailyMeanValue = Double.MinValue;                      Int32 HourNumber = 0;                        foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        HourNumber++;                                                        if (HourNumber >= 24)                                                      {                                                          if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                          HourNumber = 0;                                                      }                                                      else                                                      {                                                          if (DailyMeanValue == Double.MinValue)                                                              DailyMeanValue = CurrentHourMeanValue;                                                          else                                                              DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2;                                                      }                                                        CurrentHourMeanValue = Double.MinValue;                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 			                    }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculatedHourlykWh)              {                  #region Calculated Hourly kWh Counter                  Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": [");                  bool firstdataset = true;                  UInt64 SerializerCounter = 0;                  DateTime CurrentHourStart = StartDateTime;                  Double CurrentHourMeanValue = Double.MinValue;                    // TODO: there should be an appropriate caching algorithm in the sensor data...                   lock (sensor_data.InMemoryIndex)                  {                      foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex)                      {                          if (ondisc.CreationTime >= StartDateTime.Ticks)                          {                              if (ondisc.CreationTime <= EndDateTime.Ticks)                              {  								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++;                                    if (dataobject.Type == ObjectTypes.Sensor)                                  {                                      if (dataobject.TypeName == "pwr_consump")                                      {                                          if (dataobject.Name == ObjectName)                                          {                                              // only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{                                                  // calculate the time difference between hour start and current data object                                                  TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks);                                                    if (ts.TotalMinutes >= 60)                                                  {                                                      // we have a full hour...add to the calculated value and reset hour values                                                      CurrentHourStart = dataobject.Timecode;                                                        if (CurrentHourMeanValue > 0)                                                      {                                                            if (!firstdataset)                                                              Output.Append("'");                                                          else                                                              firstdataset = false;                                                            // we have 24 hours completed                                                          Output.Append("[");                                                          Output.Append(dataobject.Timecode.JavaScriptTimestamp());                                                          Output.Append("'");                                                          //CurrentHourMeanValue = CurrentHourMeanValue / 100;                                                          Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.'));                                                          Output.Append("]");                                                      }                                                      CurrentHourMeanValue = Double.MinValue;                                                                                                  }                                                  else                                                  {                                                      if (CurrentHourMeanValue == Double.MinValue)                                                          CurrentHourMeanValue = dataobject.Value;                                                      else                                                      {                                                          CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2;                                                      }                                                  }                                              }                                          }                                      }                                  }                              }                          }                      }                      ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements");                      }                    #endregion              }
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The following statement contains a magic number: if (OutputType == PowerSensorOutputs.CalculateWeeklykWh) 			{ 				#region Calculated Weekly kWh Counter 				Output.Append("{ \"label\": \"" + ObjectName + "\"' \"data\": ["); 				bool firstdataset = true; 				UInt64 SerializerCounter = 0; 				DateTime CurrentHourStart = StartDateTime; 				Double CurrentHourMeanValue = Double.MinValue; 				 				// TODO: there should be an appropriate caching algorithm in the sensor data...  				lock (sensor_data.InMemoryIndex) 				{ 					Double DailyMeanValue = Double.MinValue; 					Int32 HourNumber = 0; 					 					foreach (OnDiscAdress ondisc in sensor_data.InMemoryIndex) 					{ 						if (ondisc.CreationTime >= StartDateTime.Ticks) 						{ 							if (ondisc.CreationTime <= EndDateTime.Ticks) 							{ 								XS1_DataObject dataobject = ReadFromCache(ondisc); 								SerializerCounter++; 								 								if (dataobject.Type == ObjectTypes.Sensor) 								{ 									if (dataobject.TypeName == "pwr_consump") 									{ 										if (dataobject.Name == ObjectName) 										{ 											// only up to a certain amount we consider this a valid value... 											if (dataobject.Value < 15000) 											{ 												// calculate the time difference between hour start and current data object 												TimeSpan ts = new TimeSpan(dataobject.Timecode.Ticks - CurrentHourStart.Ticks); 												 												if (ts.TotalMinutes >= 60) 												{ 													// we have a full hour...add to the calculated value and reset hour values 													CurrentHourStart = dataobject.Timecode; 													 													HourNumber++; 													 													if (HourNumber >= 168) 													{ 														if (!firstdataset) 															Output.Append("'"); 														else 															firstdataset = false; 														 														// we have 24 hours completed 														Output.Append("["); 														Output.Append(dataobject.Timecode.JavaScriptTimestamp()); 														Output.Append("'"); 														//CurrentHourMeanValue = CurrentHourMeanValue / 100; 														Output.Append(CurrentHourMeanValue.ToString().Replace('''' '.')); 														Output.Append("]"); 														HourNumber = 0; 													} 													else 													{ 														if (DailyMeanValue == Double.MinValue) 															DailyMeanValue = CurrentHourMeanValue; 														else 															DailyMeanValue = (DailyMeanValue + CurrentHourMeanValue) / 2; 													} 													 													CurrentHourMeanValue = Double.MinValue; 												} 												else 												{ 													if (CurrentHourMeanValue == Double.MinValue) 														CurrentHourMeanValue = dataobject.Value; 													else 													{ 														CurrentHourMeanValue = (CurrentHourMeanValue + dataobject.Value) / 2; 													} 												} 											} 										} 									} 								} 							} 						} 					} 					ConsoleOutputLogger_.WriteLineToScreenOnly("Generated JSON Dataset with " + SerializerCounter + " Elements"); 				} 				 			#endregion 			}
Magic Number,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The following statement contains a magic number: ser.MaxJsonLength = 20000000;
Magic Number,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The following statement contains a magic number: actuator_config_json = actuator_config_json.Remove(actuator_config_json.Length - 4' 4);
Magic Number,hacs.set_state_actuator,set_state_actuator,C:\repos\bietiekay_hacs\hacs\Devices\XS1\set_state_actuator\set_state_actuator.cs,SetStateActuatorPreset,The following statement contains a magic number: actuator_config_json = actuator_config_json.Remove(actuator_config_json.Length - 4' 4);
Duplicate Code,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 115)' (172' 223))
Duplicate Code,hacs,MAXMonitoringThread,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\MAXMonitoringThread.cs,Run,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 82)' (121' 146))
Duplicate Code,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The method contains a code clone-set at the following line numbers (starting from the method definition): ((75' 132)' (163' 220))
Duplicate Code,hacs,L_Message,C:\repos\bietiekay_hacs\hacs\Devices\ELVMAX\ELVMAX_Data\Messages\L_Message.cs,L_Message,The method contains a code clone-set at the following line numbers (starting from the method definition): ((58' 115)' (144' 201))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((97' 153)' (200' 256)' (727' 783))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((200' 265)' (727' 792))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((101' 120)' (204' 223)' (522' 541)' (731' 750))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((101' 153)' (522' 574)' (204' 256)' (731' 783))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((171' 218)' (698' 745))
Duplicate Code,HTTP,HttpProcessor,C:\repos\bietiekay_hacs\hacs\HTTP\HTTPProcessor.cs,writeURL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((409' 464)' (624' 679))
Duplicate Code,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((123' 142)' (290' 309))
Duplicate Code,hacs.JSONHandlers,JSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\JSONData.cs,GeneratePowerSensorJSONOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((202' 227)' (292' 317))
Duplicate Code,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((123' 142)' (290' 309))
Duplicate Code,hacs.JSONHandlers,NumericsJSONData,C:\repos\bietiekay_hacs\hacs\HTTP\JSONHandlers\Numerics\NumericsJSONData.cs,GeneratePowerSensorNumericsJSONOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((202' 227)' (292' 317))
Missing Default,hacs,AlarmingThread,C:\repos\bietiekay_hacs\hacs\Alarming\AlarmingThread.cs,Run,The following switch statement is missing a default case: switch(_activator.comparison) 											{ 												case "==": 													if (comp_value == xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case "<=": 													if (comp_value <= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 												case ">=": 													if (comp_value >= xs1_data.Value) 													{ 														// hurray' everything matches! Activate this event!!! 														alarm_activated = true; 													} 													break; 											}
