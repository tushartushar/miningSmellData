Implementation smell,Namespace,Class,File,Method,Description
Long Method,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The method has 130 lines of code.
Long Method,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The method has 128 lines of code.
Long Method,LibNoise.Renderer,ImageRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\ImageRenderer.cs,Render,The method has 154 lines of code.
Complex Method,LibNoise.Builder,NoiseMapBuilderCylinder,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderCylinder.cs,Build,Cyclomatic complexity of the method is 11
Complex Method,LibNoise.Builder,NoiseMapBuilderPlane,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderPlane.cs,Build,Cyclomatic complexity of the method is 12
Complex Method,LibNoise.Builder,NoiseMapBuilderSphere,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderSphere.cs,Build,Cyclomatic complexity of the method is 11
Complex Method,LibNoise.Primitive,BevinsGradient,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsGradient.cs,GradientCoherentNoise3D,Cyclomatic complexity of the method is 15
Complex Method,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise3D,Cyclomatic complexity of the method is 15
Complex Method,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise2D,Cyclomatic complexity of the method is 12
Complex Method,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise1D,Cyclomatic complexity of the method is 9
Complex Method,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,Cyclomatic complexity of the method is 9
Complex Method,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,Cyclomatic complexity of the method is 12
Complex Method,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,Cyclomatic complexity of the method is 15
Complex Method,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,Cyclomatic complexity of the method is 10
Complex Method,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,Cyclomatic complexity of the method is 12
Complex Method,LibNoise.Renderer,AbstractHeightmapRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\AbstractHeightmapRenderer.cs,Render,Cyclomatic complexity of the method is 14
Complex Method,LibNoise.Renderer,ImageRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\ImageRenderer.cs,Render,Cyclomatic complexity of the method is 22
Complex Method,LibNoise.Renderer,NormalMapRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\NormalMapRenderer.cs,Render,Cyclomatic complexity of the method is 12
Long Parameter List,LibNoise.Builder,NoiseMapBuilderPlane,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderPlane.cs,NoiseMapBuilderPlane,The method has 5 parameters.
Long Parameter List,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,LatLonToXYZ,The method has 5 parameters.
Long Parameter List,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,Cerp,The method has 5 parameters.
Long Parameter List,LibNoise.Modifier,Select,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Selector\Select.cs,Select,The method has 6 parameters.
Long Parameter List,LibNoise.Primitive,BevinsGradient,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsGradient.cs,GradientCoherentNoise3D,The method has 5 parameters.
Long Parameter List,LibNoise.Primitive,BevinsGradient,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsGradient.cs,GradientNoise3D,The method has 7 parameters.
Long Parameter List,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise3D,The method has 5 parameters.
Long Parameter List,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,Dot,The method has 5 parameters.
Long Parameter List,LibNoise.Renderer,ImageRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\ImageRenderer.cs,CalcLightIntensity,The method has 5 parameters.
Long Parameter List,LibNoise.Transformer,Turbulence,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Transformer\Turbulence.cs,Turbulence,The method has 5 parameters.
Long Statement,LibNoise.Builder,NoiseMapBuilderCylinder,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderCylinder.cs,SetBounds,The length of the statement  "		throw new ArgumentException ("Incoherent bounds : lowerAngleBound >= upperAngleBound or lowerZBound >= upperHeightBound"); " is 122.
Long Statement,LibNoise.Builder,NoiseMapBuilderCylinder,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMapBuilderCylinder.cs,Build,The length of the statement  "		throw new ArgumentException ("Incoherent bounds : lowerAngleBound >= upperAngleBound or lowerZBound >= upperHeightBound"); " is 122.
Long Statement,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The length of the statement  "	return value + (_displacement * _source3D.GetValue ((int)(Math.Floor (xCandidate))' (int)(Math.Floor (yCandidate))' (int)(Math.Floor (zCandidate)))); " is 149.
Long Statement,LibNoise.Modifier,Curve,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Modifier\Curve.cs,AddControlPoint,The length of the statement  "		throw new ArgumentException (String.Format ("Cannont insert ControlPoint({0}' {1}) : Each control point is required to contain a unique input value"' point.Input' point.Output)); " is 178.
Long Statement,LibNoise.Modifier,Curve,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Modifier\Curve.cs,GetValue,The length of the statement  "	return Libnoise.Cerp (_controlPoints [index0].Output' _controlPoints [index1].Output' _controlPoints [index2].Output' _controlPoints [index3].Output' alpha); " is 157.
Long Statement,LibNoise.Modifier,Terrace,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Modifier\Terrace.cs,AddControlPoint,The length of the statement  "		throw new ArgumentException (String.Format ("Cannont insert ControlPoint({0}) : Each control point is required to contain a unique input value"' input)); " is 153.
Long Statement,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,The length of the statement  "	return Libnoise.Lerp (Libnoise.Lerp (Grad (_random [A]' x' y)' Grad (_random [B]' x - 1' y)' u)' Libnoise.Lerp (Grad (_random [A + 1]' x' y - 1)' Grad (_random [B + 1]' x - 1' y - 1)' u)' v); " is 191.
Long Statement,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,The length of the statement  "	return Libnoise.Lerp (Libnoise.Lerp (Libnoise.Lerp (Grad (_random [aa]' x' y' z)' Grad (_random [ba]' x - 1' y' z)' u)' Libnoise.Lerp (Grad (_random [ab]' x' y - 1' z)' Grad (_random [bb]' x - 1' y - 1' z)' u)' v)' Libnoise.Lerp (Libnoise.Lerp (Grad (_random [aa + 1]' x' y' z - 1)' Grad (_random [ba + 1]' x - 1' y' z - 1)' u)' Libnoise.Lerp (Grad (_random [ab + 1]' x' y - 1' z - 1)' Grad (_random [bb + 1]' x - 1' y - 1' z - 1)' u)' v)' w); " is 443.
Long Statement,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,GrayscaleLightnessStrategy,The length of the statement  "	return (byte)((Math.Max (color.Red' Math.Max (color.Green' color.Blue)) + Math.Min (color.Red' Math.Max (color.Green' color.Blue))) / 2); " is 137.
Long Statement,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,Equals,The length of the statement  "		return _red == ((IColor)other).Red && _green == ((IColor)other).Green && _blue == ((IColor)other).Blue && _alpha == ((IColor)other).Alpha; " is 138.
Long Statement,LibNoise.Renderer,GradientColor,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\GradientColor.cs,AddGradientPoint,The length of the statement  "		throw new ArgumentException (String.Format ("Cannont insert GradientPoint({0}' {1}) : Each GradientPoint is required to contain a unique position"' point.Position' point.Color)); " is 178.
Long Statement,LibNoise.Renderer,ImageRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\ImageRenderer.cs,CalcDestColor,The length of the statement  "	return new Color ((byte)((uint)(red * 255.0f) & 0xff)' (byte)((uint)(green * 255.0f) & 0xff)' (byte)((uint)(blue * 255.0f) & 0xff)' Math.Max (sourceColor.Alpha' backgroundColor.Alpha)); " is 185.
Complex Conditional,LibNoise.Modifier,Cache,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Modifier\Cache.cs,GetValue,The conditional expression  "!_isCached || x != _xCache || y != _yCache || z != _zCache"  is complex.
Complex Conditional,LibNoise.Utils,DataMap,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Utils\DataMap.cs,GetValue,The conditional expression  "_data != null && (x >= 0 && x < _width) && (y >= 0 && y < _height)"  is complex.
Complex Conditional,LibNoise.Utils,DataMap,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Utils\DataMap.cs,SetValue,The conditional expression  "_data != null && (x >= 0 && x < _width) && (y >= 0 && y < _height)"  is complex.
Magic Number,LibNoise.Builder,NoiseMap,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Builder\NoiseMap.cs,SizeofT,The following statement contains a magic number: return 32;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value >= 1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value >= 1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value >= 1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value >= 1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) - 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value <= -1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value <= -1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value <= -1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: if (value <= -1073741824.0)  	return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,ToInt32Range,The following statement contains a magic number: return (2.0 * Math.IEEERemainder (value' 1073741824.0)) + 1073741824.0;  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: if (buffer.Length < 4)  	Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: if (buffer.Length < 4)  	Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: buffer [0] = (byte)(value >> 24);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: buffer [1] = (byte)(value >> 16);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: buffer [2] = (byte)(value >> 8);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: buffer [2] = (byte)(value >> 8);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint32,The following statement contains a magic number: buffer [3] = (byte)(value);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint16,The following statement contains a magic number: if (buffer.Length < 2)  	Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint16,The following statement contains a magic number: if (buffer.Length < 2)  	Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint16,The following statement contains a magic number: Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackBigUint16,The following statement contains a magic number: buffer [0] = (byte)(value >> 8);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint16,The following statement contains a magic number: if (buffer.Length < 2)  	Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint16,The following statement contains a magic number: if (buffer.Length < 2)  	Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint16,The following statement contains a magic number: Array.Resize (ref buffer' 2);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint16,The following statement contains a magic number: buffer [1] = (byte)((value & 0xff00) >> 8);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: if (buffer.Length < 4)  	Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: if (buffer.Length < 4)  	Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: Array.Resize (ref buffer' 4);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: buffer [1] = (byte)((value & 0xff00) >> 8);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: buffer [2] = (byte)((value & 0x00ff0000) >> 16);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: buffer [2] = (byte)((value & 0x00ff0000) >> 16);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: buffer [3] = (byte)((value & 0xff000000) >> 24);  
Magic Number,LibNoise,Libnoise,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Libnoise.cs,UnpackLittleUint32,The following statement contains a magic number: buffer [3] = (byte)((value & 0xff000000) >> 24);  
Magic Number,LibNoise.Filter,HybridMultiFractal,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\HybridMultiFractal.cs,GetValue,The following statement contains a magic number: for (curOctave = 1; weight > 0.001 && curOctave < _octaveCount; curOctave++) {  	// prevent divergence  	if (weight > 1.0)  		weight = 1.0f;  	// get next higher frequency  	signal = (_offset + _source2D.GetValue (x' y)) * _spectralWeights [curOctave];  	// The weighting from the previous octave is applied to the signal.  	signal *= weight;  	// Add the signal to the output value.  	value += signal;  	// update the (monotonically decreasing) weighting value  	weight *= _gain * signal;  	// Go to the next octave.  	x *= _lacunarity;  	y *= _lacunarity;  }  
Magic Number,LibNoise.Filter,HybridMultiFractal,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\HybridMultiFractal.cs,GetValue,The following statement contains a magic number: for (curOctave = 1; weight > 0.001 && curOctave < _octaveCount; curOctave++) {  	// prevent divergence  	if (weight > 1.0)  		weight = 1.0f;  	// get next higher frequency  	signal = (_offset + _source3D.GetValue (x' y' z)) * _spectralWeights [curOctave];  	// The weighting from the previous octave is applied to the signal.  	signal *= weight;  	// Add the signal to the output value.  	value += signal;  	// update the (monotonically decreasing) weighting value  	weight *= _gain * signal;  	// Go to the next octave.  	x *= _lacunarity;  	y *= _lacunarity;  	z *= _lacunarity;  }  
Magic Number,LibNoise.Filter,RidgedMultiFractal,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\RidgedMultiFractal.cs,GetValue,The following statement contains a magic number: for (curOctave = 1; weight > 0.001 && curOctave < _octaveCount; curOctave++) {  	x *= _lacunarity;  	y *= _lacunarity;  	// Weight successive contributions by the previous signal.  	weight = Libnoise.Clamp01 (signal * _gain);  	// Get the coherent-noise value.  	signal = _source2D.GetValue (x' y);  	// Make the ridges.  	if (signal < 0.0)  		signal = -signal;  	signal = _offset - signal;  	// Square the signal to increase the sharpness of the ridges.  	signal *= signal;  	// The weighting from the previous octave is applied to the signal.  	// Larger values have higher weights' producing sharp points along the  	// ridges.  	signal *= weight;  	// Add the signal to the output value.  	value += (signal * _spectralWeights [curOctave]);  }  
Magic Number,LibNoise.Filter,RidgedMultiFractal,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\RidgedMultiFractal.cs,GetValue,The following statement contains a magic number: for (curOctave = 1; weight > 0.001 && curOctave < _octaveCount; curOctave++) {  	x *= _lacunarity;  	y *= _lacunarity;  	z *= _lacunarity;  	// Weight successive contributions by the previous signal.  	weight = Libnoise.Clamp01 (signal * _gain);  	// Get the coherent-noise value.  	signal = _source3D.GetValue (x' y' z);  	// Make the ridges.  	if (signal < 0.0f)  		signal = -signal;  	signal = _offset - signal;  	// Square the signal to increase the sharpness of the ridges.  	signal *= signal;  	// The weighting from the previous octave is applied to the signal.  	// Larger values have higher weights' producing sharp points along the  	// ridges.  	signal *= weight;  	// Add the signal to the output value.  	value += (signal * _spectralWeights [curOctave]);  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int zCur = zInt - 2; zCur <= zInt + 2; zCur++) {  	for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  		for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  			// Calculate the position and distance to the seed point inside of  			// this unit cube.  			float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  			float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  			float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  			float xDist = xPos - x;  			float yDist = yPos - y;  			float zDist = zPos - z;  			float dist = xDist * xDist + yDist * yDist + zDist * zDist;  			if (dist < minDist) {  				// This seed point is closer to any others found so far' so record  				// this seed point.  				minDist = dist;  				xCandidate = xPos;  				yCandidate = yPos;  				zCandidate = zPos;  			}  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  	for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  		// Calculate the position and distance to the seed point inside of  		// this unit cube.  		float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  		float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  		float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  		float xDist = xPos - x;  		float yDist = yPos - y;  		float zDist = zPos - z;  		float dist = xDist * xDist + yDist * yDist + zDist * zDist;  		if (dist < minDist) {  			// This seed point is closer to any others found so far' so record  			// this seed point.  			minDist = dist;  			xCandidate = xPos;  			yCandidate = yPos;  			zCandidate = zPos;  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  	for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  		// Calculate the position and distance to the seed point inside of  		// this unit cube.  		float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  		float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  		float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  		float xDist = xPos - x;  		float yDist = yPos - y;  		float zDist = zPos - z;  		float dist = xDist * xDist + yDist * yDist + zDist * zDist;  		if (dist < minDist) {  			// This seed point is closer to any others found so far' so record  			// this seed point.  			minDist = dist;  			xCandidate = xPos;  			yCandidate = yPos;  			zCandidate = zPos;  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  	for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  		// Calculate the position and distance to the seed point inside of  		// this unit cube.  		float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  		float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  		float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  		float xDist = xPos - x;  		float yDist = yPos - y;  		float zDist = zPos - z;  		float dist = xDist * xDist + yDist * yDist + zDist * zDist;  		if (dist < minDist) {  			// This seed point is closer to any others found so far' so record  			// this seed point.  			minDist = dist;  			xCandidate = xPos;  			yCandidate = yPos;  			zCandidate = zPos;  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int yCur = yInt - 2; yCur <= yInt + 2; yCur++) {  	for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  		// Calculate the position and distance to the seed point inside of  		// this unit cube.  		float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  		float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  		float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  		float xDist = xPos - x;  		float yDist = yPos - y;  		float zDist = zPos - z;  		float dist = xDist * xDist + yDist * yDist + zDist * zDist;  		if (dist < minDist) {  			// This seed point is closer to any others found so far' so record  			// this seed point.  			minDist = dist;  			xCandidate = xPos;  			yCandidate = yPos;  			zCandidate = zPos;  		}  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  	// Calculate the position and distance to the seed point inside of  	// this unit cube.  	float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  	float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  	float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  	float xDist = xPos - x;  	float yDist = yPos - y;  	float zDist = zPos - z;  	float dist = xDist * xDist + yDist * yDist + zDist * zDist;  	if (dist < minDist) {  		// This seed point is closer to any others found so far' so record  		// this seed point.  		minDist = dist;  		xCandidate = xPos;  		yCandidate = yPos;  		zCandidate = zPos;  	}  }  
Magic Number,LibNoise.Filter,Voronoi,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Filter\Voronoi.cs,GetValue,The following statement contains a magic number: for (int xCur = xInt - 2; xCur <= xInt + 2; xCur++) {  	// Calculate the position and distance to the seed point inside of  	// this unit cube.  	float xPos = xCur + _source3D.GetValue (xCur' yCur' zCur);  	float yPos = yCur + _source3D.GetValue (xCur' yCur' zCur);  	float zPos = zCur + _source3D.GetValue (xCur' yCur' zCur);  	float xDist = xPos - x;  	float yDist = yPos - y;  	float zDist = zPos - z;  	float dist = xDist * xDist + yDist * yDist + zDist * zDist;  	if (dist < minDist) {  		// This seed point is closer to any others found so far' so record  		// this seed point.  		minDist = dist;  		xCandidate = xPos;  		yCandidate = yPos;  		zCandidate = zPos;  	}  }  
Magic Number,LibNoise.Modifier,Terrace,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Modifier\Terrace.cs,MakeControlPoints,The following statement contains a magic number: if (controlPointCount < 2)  	throw new ArgumentException ("Two or more control points must be specified.");  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise3D,The following statement contains a magic number: n = (n >> 13) ^ n;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise3D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise3D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise3D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise2D,The following statement contains a magic number: n = (n >> 13) ^ n;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise2D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise2D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise2D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise1D,The following statement contains a magic number: n = (n >> 13) ^ n;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise1D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise1D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,IntValueNoise1D,The following statement contains a magic number: return (int)(n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: _random = new int[RandomSize * 2];  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: if (seed != 0) {  	// Shuffle the array using the given seed  	// Unpack the seed into 4 bytes then perform a bitwise XOR operation  	// with each byte  	var F = new byte[4];  	Libnoise.UnpackLittleUint32 (seed' ref F);  	for (int i = 0; i < Source.Length; i++) {  		/* 					_random[i] =  (F[0] > 0) ? _source[i] ^ F[0] : _source[i]; 					_random[i] =  (F[1] > 0) ? _source[i] ^ F[1] : _random[i]; 					_random[i] =  (F[2] > 0) ? _source[i] ^ F[2] : _random[i]; 					_random[i] =  (F[3] > 0) ? _source[i] ^ F[3] : _random[i]; 					*/_random [i] = Source [i] ^ F [0];  		_random [i] ^= F [1];  		_random [i] ^= F [2];  		_random [i] ^= F [3];  		_random [i + RandomSize] = _random [i];  	}  	#if NOISE_RANDOM_PARANOIA  	#warning NOISE_RANDOM_PARANOIA is on  	// Test if Random has unique values' a sorted Random array  	// must have values from 0 to 255   	var __sorted = new int[RandomSize];  	Array.Copy (Random' __sorted' RandomSize);  	Array.Sort (__sorted);  	for (int _j = 0; _j < RandomSize; _j++) {  		if (_j != __sorted [_j])  			throw new Exception ("Unconsistent random value at " + _j + " : " + __sorted [_j]);  	}  	#endif  }  else {  	for (int i = 0; i < RandomSize; i++)  		_random [i + RandomSize] = _random [i] = Source [i];  }  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: if (seed != 0) {  	// Shuffle the array using the given seed  	// Unpack the seed into 4 bytes then perform a bitwise XOR operation  	// with each byte  	var F = new byte[4];  	Libnoise.UnpackLittleUint32 (seed' ref F);  	for (int i = 0; i < Source.Length; i++) {  		/* 					_random[i] =  (F[0] > 0) ? _source[i] ^ F[0] : _source[i]; 					_random[i] =  (F[1] > 0) ? _source[i] ^ F[1] : _random[i]; 					_random[i] =  (F[2] > 0) ? _source[i] ^ F[2] : _random[i]; 					_random[i] =  (F[3] > 0) ? _source[i] ^ F[3] : _random[i]; 					*/_random [i] = Source [i] ^ F [0];  		_random [i] ^= F [1];  		_random [i] ^= F [2];  		_random [i] ^= F [3];  		_random [i + RandomSize] = _random [i];  	}  	#if NOISE_RANDOM_PARANOIA  	#warning NOISE_RANDOM_PARANOIA is on  	// Test if Random has unique values' a sorted Random array  	// must have values from 0 to 255   	var __sorted = new int[RandomSize];  	Array.Copy (Random' __sorted' RandomSize);  	Array.Sort (__sorted);  	for (int _j = 0; _j < RandomSize; _j++) {  		if (_j != __sorted [_j])  			throw new Exception ("Unconsistent random value at " + _j + " : " + __sorted [_j]);  	}  	#endif  }  else {  	for (int i = 0; i < RandomSize; i++)  		_random [i + RandomSize] = _random [i] = Source [i];  }  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: if (seed != 0) {  	// Shuffle the array using the given seed  	// Unpack the seed into 4 bytes then perform a bitwise XOR operation  	// with each byte  	var F = new byte[4];  	Libnoise.UnpackLittleUint32 (seed' ref F);  	for (int i = 0; i < Source.Length; i++) {  		/* 					_random[i] =  (F[0] > 0) ? _source[i] ^ F[0] : _source[i]; 					_random[i] =  (F[1] > 0) ? _source[i] ^ F[1] : _random[i]; 					_random[i] =  (F[2] > 0) ? _source[i] ^ F[2] : _random[i]; 					_random[i] =  (F[3] > 0) ? _source[i] ^ F[3] : _random[i]; 					*/_random [i] = Source [i] ^ F [0];  		_random [i] ^= F [1];  		_random [i] ^= F [2];  		_random [i] ^= F [3];  		_random [i + RandomSize] = _random [i];  	}  	#if NOISE_RANDOM_PARANOIA  	#warning NOISE_RANDOM_PARANOIA is on  	// Test if Random has unique values' a sorted Random array  	// must have values from 0 to 255   	var __sorted = new int[RandomSize];  	Array.Copy (Random' __sorted' RandomSize);  	Array.Sort (__sorted);  	for (int _j = 0; _j < RandomSize; _j++) {  		if (_j != __sorted [_j])  			throw new Exception ("Unconsistent random value at " + _j + " : " + __sorted [_j]);  	}  	#endif  }  else {  	for (int i = 0; i < RandomSize; i++)  		_random [i + RandomSize] = _random [i] = Source [i];  }  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: for (int i = 0; i < Source.Length; i++) {  	/* 					_random[i] =  (F[0] > 0) ? _source[i] ^ F[0] : _source[i]; 					_random[i] =  (F[1] > 0) ? _source[i] ^ F[1] : _random[i]; 					_random[i] =  (F[2] > 0) ? _source[i] ^ F[2] : _random[i]; 					_random[i] =  (F[3] > 0) ? _source[i] ^ F[3] : _random[i]; 					*/_random [i] = Source [i] ^ F [0];  	_random [i] ^= F [1];  	_random [i] ^= F [2];  	_random [i] ^= F [3];  	_random [i + RandomSize] = _random [i];  }  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: for (int i = 0; i < Source.Length; i++) {  	/* 					_random[i] =  (F[0] > 0) ? _source[i] ^ F[0] : _source[i]; 					_random[i] =  (F[1] > 0) ? _source[i] ^ F[1] : _random[i]; 					_random[i] =  (F[2] > 0) ? _source[i] ^ F[2] : _random[i]; 					_random[i] =  (F[3] > 0) ? _source[i] ^ F[3] : _random[i]; 					*/_random [i] = Source [i] ^ F [0];  	_random [i] ^= F [1];  	_random [i] ^= F [2];  	_random [i] ^= F [3];  	_random [i + RandomSize] = _random [i];  }  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: _random [i] ^= F [2];  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Randomize,The following statement contains a magic number: _random [i] ^= F [3];  
Magic Number,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,Grad,The following statement contains a magic number: return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t0 > 0) {  	t0 *= t0;  	int gi0 = Random [ii + Random [jj]] % 12;  	n0 = t0 * t0 * Dot (Grad3 [gi0]' x0' y0);  	// (x'y) of grad3 used for  	// 2D gradient  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t1 > 0) {  	t1 *= t1;  	int gi1 = Random [ii + i1 + Random [jj + j1]] % 12;  	n1 = t1 * t1 * Dot (Grad3 [gi1]' x1' y1);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t2 > 0) {  	t2 *= t2;  	int gi2 = Random [ii + 1 + Random [jj + 1]] % 12;  	n2 = t2 * t2 * Dot (Grad3 [gi2]' x2' y2);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t0 > 0) {  	t0 *= t0;  	int gi0 = Random [ii + Random [jj + Random [kk]]] % 12;  	n0 = t0 * t0 * Dot (Grad3 [gi0]' x0' y0' z0);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t1 > 0) {  	t1 *= t1;  	int gi1 = Random [ii + i1 + Random [jj + j1 + Random [kk + k1]]] % 12;  	n1 = t1 * t1 * Dot (Grad3 [gi1]' x1' y1' z1);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t2 > 0) {  	t2 *= t2;  	int gi2 = Random [ii + i2 + Random [jj + j2 + Random [kk + k2]]] % 12;  	n2 = t2 * t2 * Dot (Grad3 [gi2]' x2' y2' z2);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t3 > 0) {  	t3 *= t3;  	int gi3 = Random [ii + 1 + Random [jj + 1 + Random [kk + 1]]] % 12;  	n3 = t3 * t3 * Dot (Grad3 [gi3]' x3' y3' z3);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: i1 = sc [0] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: j1 = sc [1] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: k1 = sc [2] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: k1 = sc [2] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: l1 = sc [3] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: l1 = sc [3] >= 3 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: i2 = sc [0] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: j2 = sc [1] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: k2 = sc [2] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: k2 = sc [2] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: l2 = sc [3] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: l2 = sc [3] >= 2 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: k3 = sc [2] >= 1 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: l3 = sc [3] >= 1 ? 1 : 0;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t0 > 0) {  	t0 *= t0;  	int gi0 = Random [ii + Random [jj + Random [kk + Random [ll]]]] % 32;  	n0 = t0 * t0 * Dot (Grad4 [gi0]' x0' y0' z0' w0);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t1 > 0) {  	t1 *= t1;  	int gi1 = Random [ii + i1 + Random [jj + j1 + Random [kk + k1 + Random [ll + l1]]]] % 32;  	n1 = t1 * t1 * Dot (Grad4 [gi1]' x1' y1' z1' w1);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t2 > 0) {  	t2 *= t2;  	int gi2 = Random [ii + i2 + Random [jj + j2 + Random [kk + k2 + Random [ll + l2]]]] % 32;  	n2 = t2 * t2 * Dot (Grad4 [gi2]' x2' y2' z2' w2);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t3 > 0) {  	t3 *= t3;  	int gi3 = Random [ii + i3 + Random [jj + j3 + Random [kk + k3 + Random [ll + l3]]]] % 32;  	n3 = t3 * t3 * Dot (Grad4 [gi3]' x3' y3' z3' w3);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,GetValue,The following statement contains a magic number: if (t4 > 0) {  	t4 *= t4;  	int gi4 = Random [ii + 1 + Random [jj + 1 + Random [kk + 1 + Random [ll + 1]]]] % 32;  	n4 = t4 * t4 * Dot (Grad4 [gi4]' x4' y4' z4' w4);  }  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,Dot,The following statement contains a magic number: return g [0] * x + g [1] * y + g [2] * z + g [3] * t;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,Dot,The following statement contains a magic number: return g [0] * x + g [1] * y + g [2] * z + g [3] * t;  
Magic Number,LibNoise.Primitive,SimplexPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\SimplexPerlin.cs,Dot,The following statement contains a magic number: return g [0] * x + g [1] * y + g [2] * z;  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,Color,The following statement contains a magic number: _alpha = 255;  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,Lerp,The following statement contains a magic number: color.Alpha = (withAlphaChannel) ? Libnoise.Lerp (color0.Alpha' color1.Alpha' t) : (byte)255;  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,Grayscale,The following statement contains a magic number: returnColor.Alpha = 255;  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,Grayscale,The following statement contains a magic number: returnColor.Alpha = 255;  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,GrayscaleLightnessStrategy,The following statement contains a magic number: return (byte)((Math.Max (color.Red' Math.Max (color.Green' color.Blue)) + Math.Min (color.Red' Math.Max (color.Green' color.Blue))) / 2);  
Magic Number,LibNoise.Renderer,Color,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Color.cs,GrayscaleAverageStrategy,The following statement contains a magic number: return (byte)((color.Red + color.Green + color.Blue) / 3);  
Magic Number,LibNoise.Renderer,Heightmap16,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Heightmap16.cs,SizeofT,The following statement contains a magic number: return 16;  
Magic Number,LibNoise.Renderer,Heightmap8,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Heightmap8.cs,SizeofT,The following statement contains a magic number: return 8;  
Magic Number,LibNoise.Renderer,Image,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\Image.cs,SizeofT,The following statement contains a magic number: return 64;  
Magic Number,LibNoise.Renderer,ImageRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\ImageRenderer.cs,Render,The following statement contains a magic number: if (_gradient.CountGradientPoints () < 2)  	throw new ArgumentException ("Not enought points in the gradient");  
Magic Number,LibNoise.Renderer,NormalMapRenderer,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Renderer\NormalMapRenderer.cs,CalcNormalColor,The following statement contains a magic number: return new Color (xc' yc' zc' 255);  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: try {  	_writer.Write (b2);  	//BM Magic number 424D   	_writer.Write (Libnoise.UnpackLittleUint32 (destSize + BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (40' ref b4));  	// Palette offset  	_writer.Write (Libnoise.UnpackLittleUint32 (width' ref b4));  	// width  	_writer.Write (Libnoise.UnpackLittleUint32 (height' ref b4));  	// height  	_writer.Write (Libnoise.UnpackLittleUint16 (1' ref b2));  	// Planes per pixel  	_writer.Write (Libnoise.UnpackLittleUint16 (24' ref b2));  	// Bits per plane  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	// Compression (0 = none)  	_writer.Write (Libnoise.UnpackLittleUint32 (destSize' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// X pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// Y pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (b4);  	// Build and write each horizontal line to the file.  	for (int y = 0; y < height; y++) {  		int i = 0;  		// Each line is aligned to a 32-bit boundary (\0 padding)  		Array.Clear (pLineBuffer' 0' pLineBuffer.Length);  		Color pSource;  		for (int x = 0; x < width; x++) {  			pSource = _image.GetValue (x' y);  			// Little endian order : B G R  			pLineBuffer [i++] = pSource.Blue;  			pLineBuffer [i++] = pSource.Green;  			pLineBuffer [i++] = pSource.Red;  		}  		_writer.Write (pLineBuffer);  	}  }  catch (Exception e) {  	throw new IOException ("Unknown IO exception"' e);  }  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: try {  	_writer.Write (b2);  	//BM Magic number 424D   	_writer.Write (Libnoise.UnpackLittleUint32 (destSize + BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (40' ref b4));  	// Palette offset  	_writer.Write (Libnoise.UnpackLittleUint32 (width' ref b4));  	// width  	_writer.Write (Libnoise.UnpackLittleUint32 (height' ref b4));  	// height  	_writer.Write (Libnoise.UnpackLittleUint16 (1' ref b2));  	// Planes per pixel  	_writer.Write (Libnoise.UnpackLittleUint16 (24' ref b2));  	// Bits per plane  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	// Compression (0 = none)  	_writer.Write (Libnoise.UnpackLittleUint32 (destSize' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// X pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// Y pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (b4);  	// Build and write each horizontal line to the file.  	for (int y = 0; y < height; y++) {  		int i = 0;  		// Each line is aligned to a 32-bit boundary (\0 padding)  		Array.Clear (pLineBuffer' 0' pLineBuffer.Length);  		Color pSource;  		for (int x = 0; x < width; x++) {  			pSource = _image.GetValue (x' y);  			// Little endian order : B G R  			pLineBuffer [i++] = pSource.Blue;  			pLineBuffer [i++] = pSource.Green;  			pLineBuffer [i++] = pSource.Red;  		}  		_writer.Write (pLineBuffer);  	}  }  catch (Exception e) {  	throw new IOException ("Unknown IO exception"' e);  }  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: try {  	_writer.Write (b2);  	//BM Magic number 424D   	_writer.Write (Libnoise.UnpackLittleUint32 (destSize + BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (40' ref b4));  	// Palette offset  	_writer.Write (Libnoise.UnpackLittleUint32 (width' ref b4));  	// width  	_writer.Write (Libnoise.UnpackLittleUint32 (height' ref b4));  	// height  	_writer.Write (Libnoise.UnpackLittleUint16 (1' ref b2));  	// Planes per pixel  	_writer.Write (Libnoise.UnpackLittleUint16 (24' ref b2));  	// Bits per plane  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	// Compression (0 = none)  	_writer.Write (Libnoise.UnpackLittleUint32 (destSize' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// X pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// Y pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (b4);  	// Build and write each horizontal line to the file.  	for (int y = 0; y < height; y++) {  		int i = 0;  		// Each line is aligned to a 32-bit boundary (\0 padding)  		Array.Clear (pLineBuffer' 0' pLineBuffer.Length);  		Color pSource;  		for (int x = 0; x < width; x++) {  			pSource = _image.GetValue (x' y);  			// Little endian order : B G R  			pLineBuffer [i++] = pSource.Blue;  			pLineBuffer [i++] = pSource.Green;  			pLineBuffer [i++] = pSource.Red;  		}  		_writer.Write (pLineBuffer);  	}  }  catch (Exception e) {  	throw new IOException ("Unknown IO exception"' e);  }  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: try {  	_writer.Write (b2);  	//BM Magic number 424D   	_writer.Write (Libnoise.UnpackLittleUint32 (destSize + BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (BMP_HEADER_SIZE' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (40' ref b4));  	// Palette offset  	_writer.Write (Libnoise.UnpackLittleUint32 (width' ref b4));  	// width  	_writer.Write (Libnoise.UnpackLittleUint32 (height' ref b4));  	// height  	_writer.Write (Libnoise.UnpackLittleUint16 (1' ref b2));  	// Planes per pixel  	_writer.Write (Libnoise.UnpackLittleUint16 (24' ref b2));  	// Bits per plane  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	// Compression (0 = none)  	_writer.Write (Libnoise.UnpackLittleUint32 (destSize' ref b4));  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// X pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  	// Y pixels per meter  	_writer.Write (Libnoise.UnpackLittleUint32 (0' ref b4));  	_writer.Write (b4);  	// Build and write each horizontal line to the file.  	for (int y = 0; y < height; y++) {  		int i = 0;  		// Each line is aligned to a 32-bit boundary (\0 padding)  		Array.Clear (pLineBuffer' 0' pLineBuffer.Length);  		Color pSource;  		for (int x = 0; x < width; x++) {  			pSource = _image.GetValue (x' y);  			// Little endian order : B G R  			pLineBuffer [i++] = pSource.Blue;  			pLineBuffer [i++] = pSource.Green;  			pLineBuffer [i++] = pSource.Red;  		}  		_writer.Write (pLineBuffer);  	}  }  catch (Exception e) {  	throw new IOException ("Unknown IO exception"' e);  }  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: _writer.Write (Libnoise.UnpackLittleUint32 (40' ref b4));  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: _writer.Write (Libnoise.UnpackLittleUint16 (24' ref b2));  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: _writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,WriteFile,The following statement contains a magic number: _writer.Write (Libnoise.UnpackLittleUint32 (2834' ref b4));  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,CalcWidthByteCount,The following statement contains a magic number: return ((width * 3) + 3) & ~0x03;  
Magic Number,LibNoise.Writer,BMPWriter,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Writer\BMPWriter.cs,CalcWidthByteCount,The following statement contains a magic number: return ((width * 3) + 3) & ~0x03;  
Missing Default,LibNoise.Primitive,BevinsGradient,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsGradient.cs,GradientCoherentNoise3D,The following switch statement is missing a default case: switch (quality) {  case NoiseQuality.Fast:  	xs = (x - x0);  	ys = (y - y0);  	zs = (z - z0);  	break;  case NoiseQuality.Standard:  	xs = Libnoise.SCurve3 (x - x0);  	ys = Libnoise.SCurve3 (y - y0);  	zs = Libnoise.SCurve3 (z - z0);  	break;  case NoiseQuality.Best:  	xs = Libnoise.SCurve5 (x - x0);  	ys = Libnoise.SCurve5 (y - y0);  	zs = Libnoise.SCurve5 (z - z0);  	break;  }  
Missing Default,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise3D,The following switch statement is missing a default case: switch (quality) {  case NoiseQuality.Fast:  	xs = (x - x0);  	ys = (y - y0);  	zs = (z - z0);  	break;  case NoiseQuality.Standard:  	xs = Libnoise.SCurve3 (x - x0);  	ys = Libnoise.SCurve3 (y - y0);  	zs = Libnoise.SCurve3 (z - z0);  	break;  case NoiseQuality.Best:  	xs = Libnoise.SCurve5 (x - x0);  	ys = Libnoise.SCurve5 (y - y0);  	zs = Libnoise.SCurve5 (z - z0);  	break;  }  
Missing Default,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise2D,The following switch statement is missing a default case: switch (quality) {  case NoiseQuality.Fast:  	xs = (x - x0);  	ys = (y - y0);  	break;  case NoiseQuality.Standard:  	xs = Libnoise.SCurve3 (x - x0);  	ys = Libnoise.SCurve3 (y - y0);  	break;  case NoiseQuality.Best:  	xs = Libnoise.SCurve5 (x - x0);  	ys = Libnoise.SCurve5 (y - y0);  	break;  }  
Missing Default,LibNoise.Primitive,BevinsValue,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\BevinsValue.cs,ValueCoherentNoise1D,The following switch statement is missing a default case: switch (quality) {  case NoiseQuality.Fast:  	xs = (x - x0);  	break;  case NoiseQuality.Standard:  	xs = Libnoise.SCurve3 (x - x0);  	break;  case NoiseQuality.Best:  	xs = Libnoise.SCurve5 (x - x0);  	break;  }  
Missing Default,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,The following switch statement is missing a default case: switch (Quality) {  case NoiseQuality.Fast:  	u = x;  	break;  case NoiseQuality.Standard:  	u = Libnoise.SCurve3 (x);  	break;  case NoiseQuality.Best:  	u = Libnoise.SCurve5 (x);  	break;  }  
Missing Default,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,The following switch statement is missing a default case: switch (Quality) {  case NoiseQuality.Fast:  	u = x;  	v = y;  	break;  case NoiseQuality.Standard:  	u = Libnoise.SCurve3 (x);  	v = Libnoise.SCurve3 (y);  	break;  case NoiseQuality.Best:  	u = Libnoise.SCurve5 (x);  	v = Libnoise.SCurve5 (y);  	break;  }  
Missing Default,LibNoise.Primitive,ImprovedPerlin,C:\repos\Taggersoft_LibNoise\src\LibNoise.NET45\..\LibNoise.NET35\Primitive\ImprovedPerlin.cs,GetValue,The following switch statement is missing a default case: switch (Quality) {  case NoiseQuality.Fast:  	u = x;  	v = y;  	w = z;  	break;  case NoiseQuality.Standard:  	u = Libnoise.SCurve3 (x);  	v = Libnoise.SCurve3 (y);  	w = Libnoise.SCurve3 (z);  	break;  case NoiseQuality.Best:  	u = Libnoise.SCurve5 (x);  	v = Libnoise.SCurve5 (y);  	w = Libnoise.SCurve5 (z);  	break;  }  
