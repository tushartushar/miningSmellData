Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.ConnectTheDots.Gateway,BatchSenderThread<TQueueItem;TMessage>,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\Queue\BatchSenderThread.cs,ThreadJob,The method has 115 lines of code.
Long Parameter List,Microsoft.ConnectTheDots.Gateway,BatchSenderThread<TQueueItem;TMessage>,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\Queue\BatchSenderThread.cs,BatchSenderThread,The method has 5 parameters. Parameters: dataSource' dataTarget' dataTransform' serializedData' logger
Long Statement,Microsoft.ConnectTheDots.Gateway,OperationStatusFactory,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\OperationStatus\OperationStatusFactory.cs,CreateError,The length of the statement  "            return new OperationStatus<T> { OperationCode = errorCode' ErrorMessage = exception.Message + exception.StackTrace' Result = default( T ) }; " is 140.
Long Statement,Microsoft.ConnectTheDots.Gateway,OperationStatusFactory,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\OperationStatus\OperationStatusFactory.cs,CreateError,The length of the statement  "            return new OperationStatus<T> { OperationCode = errorCode' ErrorMessage = errorMessage + exception.Message + exception.StackTrace' Result = default( T ) }; " is 155.
Long Statement,Microsoft.ConnectTheDots.Gateway,OperationStatusFactory,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\OperationStatus\OperationStatusFactory.cs,CopyFrom,The length of the statement  "            return new OperationStatus<TOut> { OperationCode = source.OperationCode' ErrorMessage = source.ErrorMessage' Result = default( TOut ) }; " is 136.
Long Statement,Microsoft.ConnectTheDots.Gateway,OperationStatusFactory,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\OperationStatus\OperationStatusFactory.cs,CopyFrom,The length of the statement  "            return new OperationStatus<TOut> { OperationCode = source.OperationCode' ErrorMessage = source.ErrorMessage' Result = result }; " is 127.
Magic Number,Microsoft.ConnectTheDots.Gateway,BatchSenderThread<TQueueItem;TMessage>,C:\repos\MSOpenTech_connectthedots\Devices\Gateways\GatewayService\Gateway\Utils\Queue\BatchSenderThread.cs,ThreadJob,The following statement contains a magic number: try              {                  const int WAIT_TIMEOUT = 50; // millisecods                    // run until Stop() is called                  while( _running == true )                  {                      try                      {                          // If there are no tasks to be served' wait for some events to process                          // Use a timeout to prevent race conditions on the outstanding tasks count                          // and the actual queue count                          _doWork.WaitOne( WAIT_TIMEOUT );                            _logger.Flush( );                            // Fish from the queue and accumulate' keep track of outstanding tasks to                           // avoid accumulating too many competing tasks. Note that we are going to schedule                          // one more tasks than strictly needed' so that we prevent tasks to sit in the queue                          // because of the race condition on the outstanding task count (_outstandingTasks)                           // and the tasks actually sitting in the queue.  (*)                          // To prevent this race condition' we will wait with a timeout                          int count = _dataSource.Count - _outstandingTasks;                            if( count == 0 )                          {                              continue;                          }                            // check if we have been woken up to actually stop processing                           EventBatchProcessedEventHandler eventBatchProcessed = null;                            lock( _syncRoot )                          {                              if( _running == false )                              {                                  return;                              }                                // take a snapshot of event handlers to invoke                              eventBatchProcessed = OnEventsBatchProcessed;                          }                            // allocate a container to keep track of tasks for events in the queue                          var tasks = new List<TaskWrapper>( );                            // process all messages that have not been processed yet                           while( --count >= 0 )                          {                              TaskWrapper<OperationStatus<TQueueItem>> t = null;                                try                              {                                  t = _dataSource.TryPop( );                              }                              catch                              {                                  Interlocked.Decrement( ref _outstandingTasks );                                                                     continue;                              }                                // increment outstanding task count                               Interlocked.Increment( ref _outstandingTasks );                                t.ContinueWith<TaskWrapper>( popped =>                              {                                  // Decrement the numbers of outstanding tasks.                                   // (*) Note that there is a race  condition because at this point in time the tasks                                   // is already out of the queue but we did not decrement the outstanding task count                                   // yet. This race condition may cause tasks to be left sitting in the queue.                                   // To deal with this race condition' we will wait with a timeout                                  Interlocked.Decrement( ref _outstandingTasks );                                    // because the outstanding task counter is incremented before                                   // adding' we should never incur a negative count                                   Debug.Assert( _outstandingTasks >= 0 );                                    if ( popped?.Result != null && popped.Result.IsSuccess )                                  {                                      if( _dataTransform != null )                                      {                                          return _dataTarget.SendMessage( _dataTransform( popped.Result.Result ) );                                      }                                      if( _serializedData != null )                                      {                                          return _dataTarget.SendSerialized( _serializedData( popped.Result.Result ) );                                      }                                  }                                    return null;                              } );                                AddToProcessed( tasks' t );                          }                            // alert any client about outstanding message tasks                          if( eventBatchProcessed != null )                          {                              var sh = new SafeAction<List<TaskWrapper>>( allScheduledTasks => eventBatchProcessed( allScheduledTasks )' Logger );                                TaskWrapper.Run( ( ) => sh.SafeInvoke( tasks ) );                          }                      }                      catch( StackOverflowException ex )                      {                          Logger.LogError( _logMessagePrefix + ex.Message );                            // do not hide stack overflow exceptions                          throw;                      }                      catch( OutOfMemoryException ex )                      {                          Logger.LogError( _logMessagePrefix + ex.Message );                            // do not hide memory exceptions                          throw;                      }                      catch( Exception ex )                      {                          Logger.LogError( _logMessagePrefix + ex.Message );                            // catch all other exceptions                      }                        // go and check for more events                  }              }              finally              {                  // signal stop                  _operational.Set( );              }
