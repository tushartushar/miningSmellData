Implementation smell,Namespace,Class,File,Method,Description
Long Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The method has 146 lines of code.
Long Method,Aerospike.Client,ResultCode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\ResultCode.cs,GetResultString,The method has 138 lines of code.
Long Method,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The method has 188 lines of code.
Complex Method,Aerospike.Client,Privilege,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\Privilege.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,Privilege,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\Privilege.cs,PrivilegeCodeToString,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,SocketHandler,Cyclomatic complexity of the method is 18
Complex Method,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ReceiveEvent,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,Cyclomatic complexity of the method is 20
Complex Method,Aerospike.Client,MapPolicy,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapPolicy.cs,MapPolicy,Cyclomatic complexity of the method is 12
Complex Method,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,InitTendThread,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,Tend,Cyclomatic complexity of the method is 12
Complex Method,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,Cyclomatic complexity of the method is 16
Complex Method,Aerospike.Client,Node,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Node.cs,RefreshPeers,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,Node,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Node.cs,GetConnection,Cyclomatic complexity of the method is 14
Complex Method,Aerospike.Client,NodeValidator,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\NodeValidator.cs,SetFeatures,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,Cyclomatic complexity of the method is 18
Complex Method,Aerospike.Client,TlsConnection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\TlsConnection.cs,ValidateServerCertificate,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToParticle,Cyclomatic complexity of the method is 16
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetOperate,Cyclomatic complexity of the method is 30
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,Cyclomatic complexity of the method is 12
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,Cyclomatic complexity of the method is 12
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,Cyclomatic complexity of the method is 27
Complex Method,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,Cyclomatic complexity of the method is 26
Complex Method,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,Cyclomatic complexity of the method is 14
Complex Method,Aerospike.Client,RegisterCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\RegisterCommand.cs,Register,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Get,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,ParseMultiResponse,Cyclomatic complexity of the method is 9
Complex Method,Aerospike.Client,ResultCode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\ResultCode.cs,KeepConnection,Cyclomatic complexity of the method is 9
Complex Method,Aerospike.Client,ResultCode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\ResultCode.cs,GetResultString,Cyclomatic complexity of the method is 67
Complex Method,Aerospike.Client,Value,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Value.cs,Get,Cyclomatic complexity of the method is 21
Complex Method,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackObject,Cyclomatic complexity of the method is 11
Complex Method,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,Cyclomatic complexity of the method is 9
Complex Method,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackBlob,Cyclomatic complexity of the method is 15
Complex Method,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,Cyclomatic complexity of the method is 66
Complex Method,Aerospike.Client,LuaAerospike,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,LuaInstance,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,BytesToLua,Cyclomatic complexity of the method is 15
Complex Method,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,Cyclomatic complexity of the method is 8
Complex Method,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,Cyclomatic complexity of the method is 9
Complex Method,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,Cyclomatic complexity of the method is 8
Long Parameter List,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,CreateUser,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchReadListCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchReadListCommand,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchReadSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchReadSequenceCommand,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayExecutor,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayCommand,The method has 8 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayDirect,The method has 9 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceExecutor,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceCommand,The method has 8 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceDirect,The method has 9 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchExistsArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsArrayCommand,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchExistsArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsArrayDirect,The method has 7 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchExistsSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsSequenceCommand,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncBatchExistsSequenceDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsSequenceDirect,The method has 7 parameters.
Long Parameter List,Aerospike.Client,AsyncClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncClient.cs,ScanAll,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncClient.cs,Execute,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncClient.cs,Execute,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncExecute,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncExecute.cs,AsyncExecute,The method has 7 parameters.
Long Parameter List,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,AsyncMultiCommand,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncOperate,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncOperate.cs,AsyncOperate,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncQuery,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncQuery.cs,AsyncQuery,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,AsyncRead,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AsyncScan,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncScan.cs,AsyncScan,The method has 9 parameters.
Long Parameter List,Aerospike.Client,AsyncScanExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncScanExecutor.cs,AsyncScanExecutor,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AsyncWrite,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncWrite.cs,AsyncWrite,The method has 6 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The method has 5 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 6 parameters.
Long Parameter List,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The method has 6 parameters.
Long Parameter List,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,PartitionParser,The method has 5 parameters.
Long Parameter List,Aerospike.Client,TlsConnection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\TlsConnection.cs,TlsConnection,The method has 6 parameters.
Long Parameter List,Aerospike.Client,BatchGetArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,BatchGetArrayCommand,The method has 6 parameters.
Long Parameter List,Aerospike.Client,BatchGetArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,BatchGetArrayDirect,The method has 7 parameters.
Long Parameter List,Aerospike.Client,BatchExistsArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,BatchExistsArrayDirect,The method has 5 parameters.
Long Parameter List,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,The method has 7 parameters.
Long Parameter List,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,ExecuteNode,The method has 7 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetUdf,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchReadDirect,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The method has 5 parameters.
Long Parameter List,Aerospike.Client,ExecuteCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ExecuteCommand.cs,ExecuteCommand,The method has 6 parameters.
Long Parameter List,Aerospike.Client,RegisterCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\RegisterCommand.cs,Register,The method has 5 parameters.
Long Parameter List,Aerospike.Client,ScanCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ScanCommand.cs,ScanCommand,The method has 7 parameters.
Long Parameter List,Aerospike.Client,WriteCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\WriteCommand.cs,WriteCommand,The method has 5 parameters.
Long Parameter List,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,FindFrom,The method has 5 parameters.
Long Parameter List,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,Range,The method has 5 parameters.
Long Parameter List,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,Range,The method has 6 parameters.
Long Parameter List,Aerospike.Client,LargeMap,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeMap.cs,LargeMap,The method has 5 parameters.
Long Parameter List,Aerospike.Client,LargeSet,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeSet.cs,LargeSet,The method has 5 parameters.
Long Parameter List,Aerospike.Client,LargeStack,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeStack.cs,LargeStack,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,ScanAll,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Register,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Execute,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Execute,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,QueryAggregate,The method has 5 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,CreateIndex,The method has 6 parameters.
Long Parameter List,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,CreateIndex,The method has 7 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanAll,The method has 5 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanNode,The method has 6 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanNode,The method has 6 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,Register,The method has 5 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,Execute,The method has 5 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,Execute,The method has 5 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,QueryAggregate,The method has 5 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,CreateIndex,The method has 6 parameters.
Long Parameter List,Aerospike.Client,IAerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\IAerospikeClient.cs,CreateIndex,The method has 7 parameters.
Long Parameter List,Aerospike.Client,Key,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Key.cs,Key,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,Filter,The method has 5 parameters.
Long Parameter List,Aerospike.Client,QueryAggregateCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateCommand.cs,QueryAggregateCommand,The method has 5 parameters.
Long Parameter List,Aerospike.Client,Statement,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Statement.cs,SetAggregateFunction,The method has 5 parameters.
Long Statement,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The length of the statement  "			if (!(privilege.setName == null || privilege.setName.Length == 0) && (privilege.ns == null || privilege.ns.Length == 0)) { " is 122.
Long Statement,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The length of the statement  "				throw new AerospikeException (ResultCode.INVALID_PRIVILEGE' "Admin privilege '" + privilege.PrivilegeCodeToString () + "' has a set scope with an empty namespace."); " is 165.
Long Statement,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The length of the statement  "			if (!(privilege.ns == null || privilege.ns.Length == 0) || !(privilege.setName == null || privilege.setName.Length == 0)) { " is 123.
Long Statement,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The length of the statement  "				throw new AerospikeException (ResultCode.INVALID_PRIVILEGE' "Admin global privilege '" + privilege.PrivilegeCodeToString () + "' has namespace/set scope which is invalid."); " is 173.
Long Statement,Aerospike.Client,Role,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\Role.cs,isPredefined,The length of the statement  "	return name.Equals (ReadWrite) || name.Equals (ReadWriteUdf) || name.Equals (Read) || name.Equals (SysAdmin) || name.Equals (UserAdmin) || name.Equals (DataAdmin); " is 163.
Long Statement,Aerospike.Client,AsyncBatchReadListCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchReadSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchGetArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchGetArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,AsyncBatchGetSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchGetSequenceDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,AsyncBatchExistsArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchExistsArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,AsyncBatchExistsSequenceCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,AsyncBatchExistsSequenceDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,AsyncClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncClient.cs,GetHeader,The length of the statement  "	new AsyncBatchGetSequenceExecutor (cluster' policy' listener' keys' null' Command.INFO1_READ | Command.INFO1_NOBINDATA); " is 120.
Long Statement,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ShouldRetry,The length of the statement  "	return iterations < policy.maxRetries && (policy.retryOnTimeout || watch == null || watch.ElapsedMilliseconds < policy.timeout); " is 128.
Long Statement,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,AlreadyCompleted,The length of the statement  "		AerospikeException.Timeout timeoutException = new AerospikeException.Timeout (node' policy.timeout' iterations + 1' 0' 0); " is 122.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByKeyRange,The length of the statement  "	return MapBase.CreateRangeOperation (MapBase.REMOVE_BY_KEY_INTERVAL' Operation.Type.MAP_MODIFY' binName' keyBegin' keyEnd' returnType); " is 135.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByValueRange,The length of the statement  "	return MapBase.CreateRangeOperation (MapBase.REMOVE_BY_VALUE_INTERVAL' Operation.Type.MAP_MODIFY' binName' valueBegin' valueEnd' returnType); " is 141.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByIndexRange,The length of the statement  "	return MapBase.CreateOperation (MapBase.REMOVE_BY_INDEX_RANGE' Operation.Type.MAP_MODIFY' binName' index' count' returnType); " is 125.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByRankRange,The length of the statement  "	return MapBase.CreateOperation (MapBase.REMOVE_BY_RANK_RANGE' Operation.Type.MAP_MODIFY' binName' rank' count' returnType); " is 123.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,GetByKeyRange,The length of the statement  "	return MapBase.CreateRangeOperation (MapBase.GET_BY_KEY_INTERVAL' Operation.Type.MAP_READ' binName' keyBegin' keyEnd' returnType); " is 130.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,GetByValueRange,The length of the statement  "	return MapBase.CreateRangeOperation (MapBase.GET_BY_VALUE_INTERVAL' Operation.Type.MAP_READ' binName' valueBegin' valueEnd' returnType); " is 136.
Long Statement,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,GetByIndexRange,The length of the statement  "	return MapBase.CreateOperation (MapBase.GET_BY_INDEX_RANGE' Operation.Type.MAP_READ' binName' index' count' returnType); " is 120.
Long Statement,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,CreateConnection,The length of the statement  "	return tlsPolicy != null ? new TlsConnection (tlsPolicy' tlsName' address' timeout' maxSocketIdleMillis' pool) : new Connection (address' timeout' maxSocketIdleMillis' pool); " is 174.
Long Statement,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,GetHostAddresses,The length of the statement  "		// See: https://social.msdn.microsoft.com/Forums/en-US/313cf28c-2a6d-498e-8188-7a0639dbd552/tcpclientbeginconnect-issue?forum=netfxnetcom " is 137.
Long Statement,Aerospike.Client,Node,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Node.cs,RefreshPartitions,The length of the statement  "		PartitionParser parser = new PartitionParser (tendConnection' this' cluster.partitionMap' Node.PARTITIONS' cluster.requestProleReplicas); " is 137.
Long Statement,Aerospike.Client,Node,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Node.cs,GetConnection,The length of the statement  "	throw new AerospikeException.Connection (ResultCode.NO_MORE_CONNECTIONS' "Node " + this + " max connections " + cluster.connectionQueueSize + " would be exceeded."); " is 165.
Long Statement,Aerospike.Client,NodeValidator,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\NodeValidator.cs,ValidateAlias,The length of the statement  "				throw new AerospikeException.InvalidNode ("Node " + nodeName + ' ' + alias + ' ' + " expected cluster name '" + cluster.clusterName + "' received '" + id + "'"); " is 161.
Long Statement,Aerospike.Client,BatchReadListCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,BatchGetArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,BatchGetArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,BatchExistsArrayCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + batchIndex); " is 146.
Long Statement,Aerospike.Client,BatchExistsArrayDirect,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "		throw new AerospikeException.Parse ("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString (key.digest) + ''' + index + ''' + offset); " is 156.
Long Statement,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,The length of the statement  "						MultiCommand command = new BatchGetArrayDirect (batchNode.node' batchNamespace' policy' keys' binNames' records' readAttr); " is 123.
Long Statement,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,ExecuteNode,The length of the statement  "				MultiCommand command = new BatchGetArrayDirect (batchNode.node' batchNamespace' policy' keys' binNames' records' readAttr); " is 123.
Long Statement,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The length of the statement  "	return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0)); " is 295.
Long Statement,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The length of the statement  "	return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56)); " is 295.
Long Statement,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The length of the statement  "	return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3]))); " is 136.
Long Statement,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The length of the statement  "		if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) { " is 175.
Long Statement,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The length of the statement  "		if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) { " is 175.
Long Statement,Aerospike.Client,RegisterCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\RegisterCommand.cs,Register,The length of the statement  "			throw new AerospikeException ("Registration failed: " + error + Environment.NewLine + "File: " + file + Environment.NewLine + "Line: " + line + Environment.NewLine + "Message: " + message); " is 189.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,FindThenFilter,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "find_then_filter"' binName' value' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 166.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,FindFirst,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "find_first"' binName' Value.Get (count)' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 172.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,FindLast,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "find_last"' binName' Value.Get (count)' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 171.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,FindFrom,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "find_from"' binName' begin' Value.Get (count)' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 178.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,Range,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "range"' binName' begin' end' Value.Get (filterModule)' Value.Get (filterModule)' Value.Get (filterArgs)); " is 162.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,Range,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "find_range"' binName' begin' end' Value.Get (count)' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 184.
Long Statement,Aerospike.Client,LargeList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeList.cs,Filter,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "filter"' binName' Value.AsNull' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 163.
Long Statement,Aerospike.Client,LargeMap,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeMap.cs,Filter,The length of the statement  "	return (IDictionary)client.Execute (policy' key' PackageName' "filter"' binName' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 155.
Long Statement,Aerospike.Client,LargeSet,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeSet.cs,Filter,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "filter"' binName' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 149.
Long Statement,Aerospike.Client,LargeStack,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Large\LargeStack.cs,Filter,The length of the statement  "	return (IList)client.Execute (policy' key' PackageName' "filter"' binName' Value.Get (peekCount)' Value.Get (filterModule)' Value.Get (filterName)' Value.Get (filterArgs)); " is 172.
Long Statement,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Get,The length of the statement  "				throw new AerospikeException (ResultCode.PARAMETER_ERROR' "Requested command requires a server that supports new batch index protocol."); " is 137.
Long Statement,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,Get,The length of the statement  "				throw new AerospikeException (ResultCode.PARAMETER_ERROR' "Requested command requires a server that supports new batch index protocol."); " is 137.
Long Statement,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The length of the statement  "	string rgnstr = string.Format ("{{ \"type\": \"AeroCircle\"' " + "\"coordinates\": [[{0:F8}' {1:F8}]' {2:F}] }}"' lng' lat' radius); " is 132.
Long Statement,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The length of the statement  "	string rgnstr = string.Format ("{{ \"type\": \"AeroCircle\"' " + "\"coordinates\": [[{0:F8}' {1:F8}]' {2:F}] }}"' lng' lat' radius); " is 132.
Long Statement,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The length of the statement  "		throw new ArgumentOutOfRangeException ("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)"); " is 121.
Complex Conditional,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The conditional expression  "!(privilege.setName == null || privilege.setName.Length == 0) && (privilege.ns == null || privilege.ns.Length == 0)"  is complex.
Complex Conditional,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The conditional expression  "!(privilege.ns == null || privilege.ns.Length == 0) || !(privilege.setName == null || privilege.setName.Length == 0)"  is complex.
Complex Conditional,Aerospike.Client,Node,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Node.cs,RefreshPartitions,The conditional expression  "failures > 0 || !active || (peersCount == 0 && peers.refreshCount > 1)"  is complex.
Complex Conditional,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins"  is complex.
Complex Conditional,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins"  is complex.
Complex Conditional,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)"  is complex.
Complex Conditional,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)"  is complex.
Virtual Method Call from Constructor,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,AerospikeClient,The constructor "AerospikeClient" calls a virtual method "InitTendThread".
Virtual Method Call from Constructor,Aerospike.Client,Key,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Key.cs,Key,The constructor "Key" calls a virtual method "ValidateKeyType".
Empty Catch Block,Aerospike.Client,AsyncConnection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,Close,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,NodeValidator,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\NodeValidator.cs,SetFeatures,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,QueryAggregateCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,Sleep,The method has an empty catch block.
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: dataBuffer = new byte[8096];  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: dataOffset = 8;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: this.dataOffset = dataOffset + 8;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,SetAuthenticate,The following statement contains a magic number: WriteHeader (AUTHENTICATE' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,CreateUser,The following statement contains a magic number: WriteHeader (CREATE_USER' 3);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,SetPassword,The following statement contains a magic number: WriteHeader (SET_PASSWORD' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,ChangePassword,The following statement contains a magic number: WriteHeader (CHANGE_PASSWORD' 3);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,GrantRoles,The following statement contains a magic number: WriteHeader (GRANT_ROLES' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,RevokeRoles,The following statement contains a magic number: WriteHeader (REVOKE_ROLES' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,CreateRole,The following statement contains a magic number: WriteHeader (CREATE_ROLE' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,GrantPrivileges,The following statement contains a magic number: WriteHeader (GRANT_PRIVILEGES' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,RevokePrivileges,The following statement contains a magic number: WriteHeader (REVOKE_PRIVILEGES' 2);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: Array.Clear (dataBuffer' dataOffset' 16);  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataBuffer [dataOffset + 2] = command;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataBuffer [dataOffset + 3] = fieldCount;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataOffset += 16;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,WriteFieldHeader,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,ReadBlocks,The following statement contains a magic number: while (status == 0) {  	conn.ReadFully (dataBuffer' 8);  	long size = ByteUtil.BytesToLong (dataBuffer' 0);  	int receiveSize = ((int)(size & 0xFFFFFFFFFFFFL));  	if (receiveSize > 0) {  		if (receiveSize > dataBuffer.Length) {  			dataBuffer = ThreadLocalData.ResizeBuffer (receiveSize);  		}  		conn.ReadFully (dataBuffer' receiveSize);  		status = ParseBlock (receiveSize);  	}  }  
Magic Number,Aerospike.Client,AdminCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Admin\AdminCommand.cs,ReadBlocks,The following statement contains a magic number: conn.ReadFully (dataBuffer' 8);  
Magic Number,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ConnectionCreated,The following statement contains a magic number: if (cluster.user != null) {  	inAuthenticate = true;  	// Authentication messages are small.  Set a reasonable upper bound.  	dataOffset = 200;  	SizeBuffer ();  	AdminCommand command = new AdminCommand (dataBuffer' dataOffset);  	dataLength = command.SetAuthenticate (cluster.user' cluster.password);  	eventArgs.SetBuffer (dataBuffer' dataOffset' dataLength - dataOffset);  	Send ();  	return;  }  
Magic Number,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ConnectionCreated,The following statement contains a magic number: dataOffset = 200;  
Magic Number,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ReceiveBegin,The following statement contains a magic number: dataLength = dataOffset + 8;  
Magic Number,Aerospike.Client,AsyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncCommand.cs,ReceiveBegin,The following statement contains a magic number: eventArgs.SetBuffer (dataOffset' 8);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength) {  	resultCode = dataBuffer [dataOffset + 5];  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return true;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	// If this is the end marker of the response' do not proceed further  	if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  		return true;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  	dataOffset += Command.MSG_REMAINING_HEADER_SIZE;  	if (!valid) {  		throw new AerospikeException.QueryTerminated ();  	}  	Key key = ParseKey ();  	ParseRow (key);  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: resultCode = dataBuffer [dataOffset + 5];  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: if ((dataBuffer [dataOffset + 3] & Command.INFO3_LAST) != 0) {  	return true;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: batchIndex = ByteUtil.BytesToInt (dataBuffer' dataOffset + 14);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: fieldCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 18);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: opCount = ByteUtil.BytesToShort (dataBuffer' dataOffset + 20);  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++) {  	int fieldlen = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	dataOffset += 4;  	int fieldtype = dataBuffer [dataOffset++];  	int size = fieldlen - 1;  	switch (fieldtype) {  	case FieldType.DIGEST_RIPE:  		digest = new byte[size];  		Array.Copy (dataBuffer' dataOffset' digest' 0' size);  		dataOffset += size;  		break;  	case FieldType.NAMESPACE:  		ns = ByteUtil.Utf8ToString (dataBuffer' dataOffset' size);  		dataOffset += size;  		break;  	case FieldType.TABLE:  		setName = ByteUtil.Utf8ToString (dataBuffer' dataOffset' size);  		dataOffset += size;  		break;  	case FieldType.KEY:  		int type = dataBuffer [dataOffset++];  		size--;  		userKey = ByteUtil.BytesToKeyValue (type' dataBuffer' dataOffset' size);  		dataOffset += size;  		break;  	}  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: dataOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: dataOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: if (fieldCount > 0) {  	// Just skip over all the fields  	for (int i = 0; i < fieldCount; i++) {  		int fieldSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  		dataOffset += 4 + fieldSize;  	}  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++) {  	int fieldSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	dataOffset += 4 + fieldSize;  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: dataOffset += 4 + fieldSize;  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' dataOffset);  	byte particleType = dataBuffer [dataOffset + 5];  	byte nameSize = dataBuffer [dataOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' dataOffset + 8' nameSize);  	dataOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' dataOffset' particleBytesSize);  	dataOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: dataOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,AsyncRead,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: dataOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,AsyncReadHeader,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncReadHeader.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0) {  	int generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	int expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	record = new Record (null' generation' expiration);  } else {  	if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  		record = null;  	} else {  		throw new AerospikeException (resultCode);  	}  }  
Magic Number,Aerospike.Client,AsyncReadHeader,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncReadHeader.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0) {  	int generation = ByteUtil.BytesToInt (dataBuffer' dataOffset + 6);  	int expiration = ByteUtil.BytesToInt (dataBuffer' dataOffset + 10);  	record = new Record (null' generation' expiration);  } else {  	if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  		record = null;  	} else {  		throw new AerospikeException (resultCode);  	}  }  
Magic Number,Aerospike.Client,BufferPool,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\BufferPool.cs,BufferPool,The following statement contains a magic number: if (rem > 0) {  	size += 8192 - rem;  }  
Magic Number,Aerospike.Client,BufferPool,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\BufferPool.cs,BufferPool,The following statement contains a magic number: size += 8192 - rem;  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,Insert,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,InsertItems,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,PopRange,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,RemoveRange,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,Set,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,Trim,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,ListOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\ListOperation.cs,GetRange,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: if (command == MapBase.REPLACE) {  	// Replace doesn't allow map attributes because it does not create on non-existing key.  	packer.PackArrayBegin (2);  	value1.Pack (packer);  	value2.Pack (packer);  } else {  	packer.PackArrayBegin (3);  	value1.Pack (packer);  	value2.Pack (packer);  	packer.PackNumber (attributes);  }  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: if (command == MapBase.REPLACE) {  	// Replace doesn't allow map attributes because it does not create on non-existing key.  	packer.PackArrayBegin (2);  	value1.Pack (packer);  	value2.Pack (packer);  } else {  	packer.PackArrayBegin (3);  	value1.Pack (packer);  	value2.Pack (packer);  	packer.PackNumber (attributes);  }  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: packer.PackArrayBegin (3);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin (3);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin (3);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: if (end == null) {  	packer.PackArrayBegin (2);  	packer.PackNumber ((int)returnType);  	begin.Pack (packer);  } else {  	packer.PackArrayBegin (3);  	packer.PackNumber ((int)returnType);  	begin.Pack (packer);  	end.Pack (packer);  }  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: if (end == null) {  	packer.PackArrayBegin (2);  	packer.PackNumber ((int)returnType);  	begin.Pack (packer);  } else {  	packer.PackArrayBegin (3);  	packer.PackNumber ((int)returnType);  	begin.Pack (packer);  	end.Pack (packer);  }  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,MapBase,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: packer.PackArrayBegin (3);  
Magic Number,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,PutItems,The following statement contains a magic number: if (policy.itemsCommand == MapBase.REPLACE_ITEMS) {  	// Replace doesn't allow map attributes because it does not create on non-existing key.  	packer.PackArrayBegin (1);  	packer.PackMap (map);  } else {  	packer.PackArrayBegin (2);  	packer.PackMap (map);  	packer.PackNumber (policy.attributes);  }  
Magic Number,Aerospike.Client,MapOperation,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapOperation.cs,PutItems,The following statement contains a magic number: packer.PackArrayBegin (2);  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,Cluster,The following statement contains a magic number: if (policy.user != null && policy.user.Length > 0) {  	this.user = ByteUtil.StringToUtf8 (policy.user);  	string pass = policy.password;  	if (pass == null) {  		pass = "";  	}  	if (!(pass.Length == 60 && pass.StartsWith ("$2a$"))) {  		pass = AdminCommand.HashPassword (pass);  	}  	this.password = ByteUtil.StringToUtf8 (pass);  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,Cluster,The following statement contains a magic number: if (!(pass.Length == 60 && pass.StartsWith ("$2a$"))) {  	pass = AdminCommand.HashPassword (pass);  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,Cluster,The following statement contains a magic number: maxSocketIdleMillis = 1000 * ((policy.maxSocketIdle <= MaxSocketIdleSecondLimit) ? policy.maxSocketIdle : MaxSocketIdleSecondLimit);  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,SeedNodes,The following statement contains a magic number: if (nodesToAdd.Count > 0) {  	AddNodes (nodesToAdd);  	return true;  } else if (failIfNotConnected) {  	StringBuilder sb = new StringBuilder (500);  	sb.AppendLine ("Failed to connect to host(s): ");  	for (int i = 0; i < seedArray.Length; i++) {  		sb.Append (seedArray [i]);  		sb.Append (' ');  		Exception ex = exceptions [i];  		if (ex != null) {  			sb.AppendLine (ex.Message);  		}  	}  	throw new AerospikeException.Connection (sb.ToString ());  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,SeedNodes,The following statement contains a magic number: if (failIfNotConnected) {  	StringBuilder sb = new StringBuilder (500);  	sb.AppendLine ("Failed to connect to host(s): ");  	for (int i = 0; i < seedArray.Length; i++) {  		sb.Append (seedArray [i]);  		sb.Append (' ');  		Exception ex = exceptions [i];  		if (ex != null) {  			sb.AppendLine (ex.Message);  		}  	}  	throw new AerospikeException.Connection (sb.ToString ());  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: foreach (Node node in nodes) {  	if (!node.Active) {  		// Inactive nodes must be removed.  		removeList.Add (node);  		continue;  	}  	switch (nodes.Length) {  	case 1:  		// Single node clusters rely on whether it responded to info requests.  		if (node.failures >= 5) {  			// 5 consecutive info requests failed.  			// Remove node.  Seeds will be tried in next cluster tend iteration.  			removeList.Add (node);  		}  		break;  	case 2:  		// Two node clusters require at least one successful refresh before removing.  		if (refreshCount == 1 && node.referenceCount == 0 && node.failures > 0) {  			// Node is not referenced nor did it respond.  			removeList.Add (node);  		}  		break;  	default:  		// Multi-node clusters require at least one successful refresh before removing.  		if (refreshCount >= 1 && node.referenceCount == 0) {  			// Node is not referenced by other nodes.  			// Check if node responded to info request.  			if (node.failures == 0) {  				// Node is alive' but not referenced by other nodes.  Check if mapped.  				if (!FindNodeInPartitionMap (node)) {  					// Node doesn't have any partitions mapped to it.  					// There is no point in keeping it in the cluster.  					removeList.Add (node);  				}  			} else {  				// Node not responding. Remove it.  				removeList.Add (node);  			}  		}  		break;  	}  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: foreach (Node node in nodes) {  	if (!node.Active) {  		// Inactive nodes must be removed.  		removeList.Add (node);  		continue;  	}  	switch (nodes.Length) {  	case 1:  		// Single node clusters rely on whether it responded to info requests.  		if (node.failures >= 5) {  			// 5 consecutive info requests failed.  			// Remove node.  Seeds will be tried in next cluster tend iteration.  			removeList.Add (node);  		}  		break;  	case 2:  		// Two node clusters require at least one successful refresh before removing.  		if (refreshCount == 1 && node.referenceCount == 0 && node.failures > 0) {  			// Node is not referenced nor did it respond.  			removeList.Add (node);  		}  		break;  	default:  		// Multi-node clusters require at least one successful refresh before removing.  		if (refreshCount >= 1 && node.referenceCount == 0) {  			// Node is not referenced by other nodes.  			// Check if node responded to info request.  			if (node.failures == 0) {  				// Node is alive' but not referenced by other nodes.  Check if mapped.  				if (!FindNodeInPartitionMap (node)) {  					// Node doesn't have any partitions mapped to it.  					// There is no point in keeping it in the cluster.  					removeList.Add (node);  				}  			} else {  				// Node not responding. Remove it.  				removeList.Add (node);  			}  		}  		break;  	}  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: switch (nodes.Length) {  case 1:  	// Single node clusters rely on whether it responded to info requests.  	if (node.failures >= 5) {  		// 5 consecutive info requests failed.  		// Remove node.  Seeds will be tried in next cluster tend iteration.  		removeList.Add (node);  	}  	break;  case 2:  	// Two node clusters require at least one successful refresh before removing.  	if (refreshCount == 1 && node.referenceCount == 0 && node.failures > 0) {  		// Node is not referenced nor did it respond.  		removeList.Add (node);  	}  	break;  default:  	// Multi-node clusters require at least one successful refresh before removing.  	if (refreshCount >= 1 && node.referenceCount == 0) {  		// Node is not referenced by other nodes.  		// Check if node responded to info request.  		if (node.failures == 0) {  			// Node is alive' but not referenced by other nodes.  Check if mapped.  			if (!FindNodeInPartitionMap (node)) {  				// Node doesn't have any partitions mapped to it.  				// There is no point in keeping it in the cluster.  				removeList.Add (node);  			}  		} else {  			// Node not responding. Remove it.  			removeList.Add (node);  		}  	}  	break;  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: switch (nodes.Length) {  case 1:  	// Single node clusters rely on whether it responded to info requests.  	if (node.failures >= 5) {  		// 5 consecutive info requests failed.  		// Remove node.  Seeds will be tried in next cluster tend iteration.  		removeList.Add (node);  	}  	break;  case 2:  	// Two node clusters require at least one successful refresh before removing.  	if (refreshCount == 1 && node.referenceCount == 0 && node.failures > 0) {  		// Node is not referenced nor did it respond.  		removeList.Add (node);  	}  	break;  default:  	// Multi-node clusters require at least one successful refresh before removing.  	if (refreshCount >= 1 && node.referenceCount == 0) {  		// Node is not referenced by other nodes.  		// Check if node responded to info request.  		if (node.failures == 0) {  			// Node is alive' but not referenced by other nodes.  Check if mapped.  			if (!FindNodeInPartitionMap (node)) {  				// Node doesn't have any partitions mapped to it.  				// There is no point in keeping it in the cluster.  				removeList.Add (node);  			}  		} else {  			// Node not responding. Remove it.  			removeList.Add (node);  		}  	}  	break;  }  
Magic Number,Aerospike.Client,Cluster,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: if (node.failures >= 5) {  	// 5 consecutive info requests failed.  	// Remove node.  Seeds will be tried in next cluster tend iteration.  	removeList.Add (node);  }  
Magic Number,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,Connection,The following statement contains a magic number: try {  	socket.NoDelay = true;  	if (timeoutMillis > 0) {  		socket.SendTimeout = timeoutMillis;  		socket.ReceiveTimeout = timeoutMillis;  	} else {  		// Never allow timeoutMillis of zero (no timeout) because WaitOne returns   		// immediately when that happens!  		// Retry functionality will attempt to reconnect later.  		timeoutMillis = 2000;  	}  	#if NETFRAMEWORK  	IAsyncResult result = socket.BeginConnect (address' null' null);  	WaitHandle wait = result.AsyncWaitHandle;  	if (wait.WaitOne (timeoutMillis)) {  		// Connection succeeded.  		// EndConnect will automatically close AsyncWaitHandle.  		socket.EndConnect (result);  	} else {  		// Connection timed out.  		// Do not close AsyncWaitHandle. If AsyncWaitHandle is closed'  		// the disposed handle can be referenced after the timeout exception is thrown.  		// The handle will eventually get closed by the garbage collector.  		// See: https://social.msdn.microsoft.com/Forums/en-US/313cf28c-2a6d-498e-8188-7a0639dbd552/tcpclientbeginconnect-issue?forum=netfxnetcom  		throw new SocketException ((int)SocketError.TimedOut);  	}  	#else  					System.Threading.Tasks.Task task = socket.ConnectAsync(address);  				if (! task.Wait(timeoutMillis)) 				{ 					// Connection timed out. 					throw new SocketException((int)SocketError.TimedOut); 				} #endif  	timestamp = DateTime.UtcNow;  } catch (Exception e) {  	//socket.Close();  	socket.Dispose ();  	throw new AerospikeException.Connection (e);  }  
Magic Number,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,Connection,The following statement contains a magic number: if (timeoutMillis > 0) {  	socket.SendTimeout = timeoutMillis;  	socket.ReceiveTimeout = timeoutMillis;  } else {  	// Never allow timeoutMillis of zero (no timeout) because WaitOne returns   	// immediately when that happens!  	// Retry functionality will attempt to reconnect later.  	timeoutMillis = 2000;  }  
Magic Number,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,Connection,The following statement contains a magic number: timeoutMillis = 2000;  
Magic Number,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,ReadFully,The following statement contains a magic number: if (socket.ReceiveTimeout > 0) {  	// Check if data is available for reading.  	// Poll is used because the timeout value is respected under 500ms.  	// The Receive method does not timeout until after 500ms.  	if (!socket.Poll (socket.ReceiveTimeout * 1000' SelectMode.SelectRead)) {  		throw new SocketException ((int)SocketError.TimedOut);  	}  }  
Magic Number,Aerospike.Client,Connection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\Connection.cs,ReadFully,The following statement contains a magic number: if (!socket.Poll (socket.ReceiveTimeout * 1000' SelectMode.SelectRead)) {  	throw new SocketException ((int)SocketError.TimedOut);  }  
Magic Number,Aerospike.Client,NodeValidator,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\NodeValidator.cs,SetAliases,The following statement contains a magic number: aliases = new List<Host> (addresses.Length + 2);  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,The following statement contains a magic number: while (offset < length) {  	if (buffer [offset] == ':') {  		// Parse namespace.  		string ns = ByteUtil.Utf8ToString (buffer' begin' offset - begin).Trim ();  		if (ns.Length <= 0 || ns.Length >= 32) {  			string response = GetTruncatedResponse ();  			throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  		}  		begin = ++offset;  		// Parse partition bitmap.  		while (offset < length) {  			byte b = buffer [offset];  			if (b == ';' || b == '\n') {  				break;  			}  			offset++;  		}  		if (offset == begin) {  			string response = GetTruncatedResponse ();  			throw new AerospikeException.Parse ("Empty partition id for namespace " + ns + ". Response=" + response);  		}  		Node[][] replicaArray;  		if (!map.TryGetValue (ns' out replicaArray)) {  			replicaArray = new Node[1][];  			replicaArray [0] = new Node[partitionCount];  			CopyPartitionMap ();  			map [ns] = replicaArray;  		}  		// Log.info("Map: " + namespace + "[0] " + node);  		DecodeBitmap (node' replicaArray [0]' begin);  		begin = ++offset;  	} else {  		offset++;  	}  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,The following statement contains a magic number: if (buffer [offset] == ':') {  	// Parse namespace.  	string ns = ByteUtil.Utf8ToString (buffer' begin' offset - begin).Trim ();  	if (ns.Length <= 0 || ns.Length >= 32) {  		string response = GetTruncatedResponse ();  		throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  	}  	begin = ++offset;  	// Parse partition bitmap.  	while (offset < length) {  		byte b = buffer [offset];  		if (b == ';' || b == '\n') {  			break;  		}  		offset++;  	}  	if (offset == begin) {  		string response = GetTruncatedResponse ();  		throw new AerospikeException.Parse ("Empty partition id for namespace " + ns + ". Response=" + response);  	}  	Node[][] replicaArray;  	if (!map.TryGetValue (ns' out replicaArray)) {  		replicaArray = new Node[1][];  		replicaArray [0] = new Node[partitionCount];  		CopyPartitionMap ();  		map [ns] = replicaArray;  	}  	// Log.info("Map: " + namespace + "[0] " + node);  	DecodeBitmap (node' replicaArray [0]' begin);  	begin = ++offset;  } else {  	offset++;  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,The following statement contains a magic number: if (ns.Length <= 0 || ns.Length >= 32) {  	string response = GetTruncatedResponse ();  	throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,The following statement contains a magic number: while (offset < length) {  	if (buffer [offset] == ':') {  		// Parse namespace.  		string ns = ByteUtil.Utf8ToString (buffer' begin' offset - begin).Trim ();  		if (ns.Length <= 0 || ns.Length >= 32) {  			string response = GetTruncatedResponse ();  			throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  		}  		begin = ++offset;  		// Parse replica count.  		while (offset < length) {  			byte b = buffer [offset];  			if (b == ''') {  				break;  			}  			offset++;  		}  		int replicaCount = Convert.ToInt32 (Encoding.UTF8.GetString (buffer' begin' offset - begin));  		// Ensure replicaArray is correct size.  		Node[][] replicaArray;  		if (!map.TryGetValue (ns' out replicaArray)) {  			// Create new replica array.   			replicaArray = new Node[replicaCount][];  			for (int i = 0; i < replicaCount; i++) {  				replicaArray [i] = new Node[partitionCount];  			}  			CopyPartitionMap ();  			map [ns] = replicaArray;  		} else if (replicaArray.Length != replicaCount) {  			if (Log.InfoEnabled ()) {  				Log.Info ("Namespace " + ns + " replication factor changed from " + replicaArray.Length + " to " + replicaCount);  			}  			// Resize replica array.   			Node[][] replicaTarget = new Node[replicaCount][];  			if (replicaArray.Length < replicaCount) {  				int i = 0;  				// Copy existing entries.  				for (; i < replicaArray.Length; i++) {  					replicaTarget [i] = replicaArray [i];  				}  				// Create new entries.  				for (; i < replicaCount; i++) {  					replicaTarget [i] = new Node[partitionCount];  				}  			} else {  				// Copy existing entries.  				for (int i = 0; i < replicaCount; i++) {  					replicaTarget [i] = replicaArray [i];  				}  			}  			CopyPartitionMap ();  			replicaArray = replicaTarget;  			map [ns] = replicaArray;  		}  		// Parse partition bitmaps.  		for (int i = 0; i < replicaCount; i++) {  			begin = ++offset;  			// Find bitmap endpoint  			while (offset < length) {  				byte b = buffer [offset];  				if (b == ''' || b == ';') {  					break;  				}  				offset++;  			}  			if (offset == begin) {  				string response = GetTruncatedResponse ();  				throw new AerospikeException.Parse ("Empty partition id for namespace " + ns + ". Response=" + response);  			}  			// Log.info("Map: " + namespace + '[' + i + "] " + node);  			DecodeBitmap (node' replicaArray [i]' begin);  		}  		begin = ++offset;  	} else {  		offset++;  	}  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,The following statement contains a magic number: if (buffer [offset] == ':') {  	// Parse namespace.  	string ns = ByteUtil.Utf8ToString (buffer' begin' offset - begin).Trim ();  	if (ns.Length <= 0 || ns.Length >= 32) {  		string response = GetTruncatedResponse ();  		throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  	}  	begin = ++offset;  	// Parse replica count.  	while (offset < length) {  		byte b = buffer [offset];  		if (b == ''') {  			break;  		}  		offset++;  	}  	int replicaCount = Convert.ToInt32 (Encoding.UTF8.GetString (buffer' begin' offset - begin));  	// Ensure replicaArray is correct size.  	Node[][] replicaArray;  	if (!map.TryGetValue (ns' out replicaArray)) {  		// Create new replica array.   		replicaArray = new Node[replicaCount][];  		for (int i = 0; i < replicaCount; i++) {  			replicaArray [i] = new Node[partitionCount];  		}  		CopyPartitionMap ();  		map [ns] = replicaArray;  	} else if (replicaArray.Length != replicaCount) {  		if (Log.InfoEnabled ()) {  			Log.Info ("Namespace " + ns + " replication factor changed from " + replicaArray.Length + " to " + replicaCount);  		}  		// Resize replica array.   		Node[][] replicaTarget = new Node[replicaCount][];  		if (replicaArray.Length < replicaCount) {  			int i = 0;  			// Copy existing entries.  			for (; i < replicaArray.Length; i++) {  				replicaTarget [i] = replicaArray [i];  			}  			// Create new entries.  			for (; i < replicaCount; i++) {  				replicaTarget [i] = new Node[partitionCount];  			}  		} else {  			// Copy existing entries.  			for (int i = 0; i < replicaCount; i++) {  				replicaTarget [i] = replicaArray [i];  			}  		}  		CopyPartitionMap ();  		replicaArray = replicaTarget;  		map [ns] = replicaArray;  	}  	// Parse partition bitmaps.  	for (int i = 0; i < replicaCount; i++) {  		begin = ++offset;  		// Find bitmap endpoint  		while (offset < length) {  			byte b = buffer [offset];  			if (b == ''' || b == ';') {  				break;  			}  			offset++;  		}  		if (offset == begin) {  			string response = GetTruncatedResponse ();  			throw new AerospikeException.Parse ("Empty partition id for namespace " + ns + ". Response=" + response);  		}  		// Log.info("Map: " + namespace + '[' + i + "] " + node);  		DecodeBitmap (node' replicaArray [i]' begin);  	}  	begin = ++offset;  } else {  	offset++;  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,The following statement contains a magic number: if (ns.Length <= 0 || ns.Length >= 32) {  	string response = GetTruncatedResponse ();  	throw new AerospikeException.Parse ("Invalid partition namespace " + ns + ". Response=" + response);  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: for (int i = 0; i < partitionCount; i++) {  	Node nodeOld = nodeArray [i];  	if ((restoreBuffer [i >> 3] & (0x80 >> (i & 7))) != 0) {  		// Node owns this partition.  		// Log.info("Map: " + i);  		if (nodeOld != null && nodeOld != node) {  			// Force previously mapped node to refresh it's partition map on next cluster tend.  			nodeOld.partitionGeneration = -1;  		}  		nodeArray [i] = node;  	} else {  		// Node does not own partition.  		if (node == nodeOld) {  			// Must erase previous map.  			nodeArray [i] = null;  		}  	}  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: for (int i = 0; i < partitionCount; i++) {  	Node nodeOld = nodeArray [i];  	if ((restoreBuffer [i >> 3] & (0x80 >> (i & 7))) != 0) {  		// Node owns this partition.  		// Log.info("Map: " + i);  		if (nodeOld != null && nodeOld != node) {  			// Force previously mapped node to refresh it's partition map on next cluster tend.  			nodeOld.partitionGeneration = -1;  		}  		nodeArray [i] = node;  	} else {  		// Node does not own partition.  		if (node == nodeOld) {  			// Must erase previous map.  			nodeArray [i] = null;  		}  	}  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: if ((restoreBuffer [i >> 3] & (0x80 >> (i & 7))) != 0) {  	// Node owns this partition.  	// Log.info("Map: " + i);  	if (nodeOld != null && nodeOld != node) {  		// Force previously mapped node to refresh it's partition map on next cluster tend.  		nodeOld.partitionGeneration = -1;  	}  	nodeArray [i] = node;  } else {  	// Node does not own partition.  	if (node == nodeOld) {  		// Must erase previous map.  		nodeArray [i] = null;  	}  }  
Magic Number,Aerospike.Client,PartitionParser,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: if ((restoreBuffer [i >> 3] & (0x80 >> (i & 7))) != 0) {  	// Node owns this partition.  	// Log.info("Map: " + i);  	if (nodeOld != null && nodeOld != node) {  		// Force previously mapped node to refresh it's partition map on next cluster tend.  		nodeOld.partitionGeneration = -1;  	}  	nodeArray [i] = node;  } else {  	// Node does not own partition.  	if (node == nodeOld) {  		// Must erase previous map.  		nodeArray [i] = null;  	}  }  
Magic Number,Aerospike.Client,TlsConnection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\TlsConnection.cs,ReadFully,The following statement contains a magic number: if (!sslStream.CanRead && socket.ReceiveTimeout > 0) {  	// Check if data is available for reading.  	// Poll is used because the timeout value is respected under 500ms.  	// The read method does not timeout until after 500ms.  	if (!socket.Poll (socket.ReceiveTimeout * 1000' SelectMode.SelectRead)) {  		throw new SocketException ((int)SocketError.TimedOut);  	}  }  
Magic Number,Aerospike.Client,TlsConnection,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Cluster\TlsConnection.cs,ReadFully,The following statement contains a magic number: if (!socket.Poll (socket.ReceiveTimeout * 1000' SelectMode.SelectRead)) {  	throw new SocketException ((int)SocketError.TimedOut);  }  
Magic Number,Aerospike.Client,BatchExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,The following statement contains a magic number: if (policy.maxConcurrentThreads == 1 || batchNodes.Count <= 1) {  	// Run batch requests sequentially in same thread.  	foreach (BatchNode batchNode in batchNodes) {  		ExecuteNode (batchNode' policy' keys' existsArray' records' binNames' readAttr);  	}  } else {  	// Run batch requests in parallel in separate threads.  	//  	// Multiple threads write to the record/exists array' so one might think that  	// volatile or memory barriers are needed on the write threads and this read thread.  	// This should not be necessary here because it happens in Executor which does a   	// volatile write (Interlocked.Increment(ref completedCount)) at the end of write threads  	// and a synchronized WaitTillComplete() in this thread.  	Executor executor = new Executor (batchNodes.Count * 2);  	// Initialize threads.    	foreach (BatchNode batchNode in batchNodes) {  		if (batchNode.node.UseNewBatch (policy)) {  			// New batch  			if (records != null) {  				MultiCommand command = new BatchGetArrayCommand (batchNode' policy' keys' binNames' records' readAttr);  				executor.AddCommand (command);  			} else {  				MultiCommand command = new BatchExistsArrayCommand (batchNode' policy' keys' existsArray);  				executor.AddCommand (command);  			}  		} else {  			// There may be multiple threads for a single node because the  			// wire protocol only allows one namespace per command.  Multiple namespaces   			// require multiple threads per node.  			batchNode.SplitByNamespace (keys);  			foreach (BatchNode.BatchNamespace batchNamespace in batchNode.batchNamespaces) {  				if (records != null) {  					MultiCommand command = new BatchGetArrayDirect (batchNode.node' batchNamespace' policy' keys' binNames' records' readAttr);  					executor.AddCommand (command);  				} else {  					MultiCommand command = new BatchExistsArrayDirect (batchNode.node' batchNamespace' policy' keys' existsArray);  					executor.AddCommand (command);  				}  			}  		}  	}  	executor.Execute (policy.maxConcurrentThreads);  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode += (int)((uint)keysPerNode >> 2);  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10) {  	keysPerNode = 10;  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10) {  	keysPerNode = 10;  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode = 10;  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode += (int)((uint)keysPerNode >> 2);  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10) {  	keysPerNode = 10;  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10) {  	keysPerNode = 10;  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode = 10;  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,AddKey,The following statement contains a magic number: if (offsetsSize >= offsets.Length) {  	int[] copy = new int[offsetsSize * 2];  	Array.Copy (offsets' 0' copy' 0' offsetsSize);  	offsets = copy;  }  
Magic Number,Aerospike.Client,BatchNode,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\BatchNode.cs,SplitByNamespace,The following statement contains a magic number: batchNamespaces = new List<BatchNamespace> (4);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: for (int i = end - 1; i >= begin; i--) {  	val += ((uint)buf [i] - 48) * mult;  	mult *= 10;  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: for (int i = end - 1; i >= begin; i--) {  	val += ((uint)buf [i] - 48) * mult;  	mult *= 10;  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: val += ((uint)buf [i] - 48) * mult;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: mult *= 10;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len == 8) {  	return BytesToLong (buf' offset);  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len < 8) {  	// Handle variable length long.   	long val = 0;  	for (int i = 0; i < len; i++) {  		val <<= 8;  		val |= buf [offset + i];  	}  	return val;  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len < 8) {  	// Handle variable length long.   	long val = 0;  	for (int i = 0; i < len; i++) {  		val <<= 8;  		val |= buf [offset + i];  	}  	return val;  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	val <<= 8;  	val |= buf [offset + i];  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: val <<= 8;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLongValue,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	val <<= 8;  	val |= buf [offset + i];  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLongValue,The following statement contains a magic number: val <<= 8;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: buf [offset++] = bytes [3];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: buf [offset++] = bytes [2];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: return 4;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes [0] = buf [offset + 3];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes [1] = buf [offset + 2];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes [2] = buf [offset + 1];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes [3] = buf [offset];  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 56);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 48);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 40);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 32);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 24);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 16);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: return 8;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 16);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 24);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 32);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 40);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 48);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf [offset] = (byte)(v >> 56);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: return 8;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 56) | ((ulong)(buf [offset + 1]) << 48) | ((ulong)(buf [offset + 2]) << 40) | ((ulong)(buf [offset + 3]) << 32) | ((ulong)(buf [offset + 4]) << 24) | ((ulong)(buf [offset + 5]) << 16) | ((ulong)(buf [offset + 6]) << 8) | ((ulong)(buf [offset + 7]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(((ulong)(buf [offset]) << 0) | ((ulong)(buf [offset + 1]) << 8) | ((ulong)(buf [offset + 2]) << 16) | ((ulong)(buf [offset + 3]) << 24) | ((ulong)(buf [offset + 4]) << 32) | ((ulong)(buf [offset + 5]) << 40) | ((ulong)(buf [offset + 6]) << 48) | ((ulong)(buf [offset + 7]) << 56));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 24);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 16);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: return 4;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 16);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf [offset] = (byte)(v >> 24);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: return 4;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf [offset]) << 24) | ((buf [offset + 1]) << 16) | ((buf [offset + 2]) << 8) | (buf [offset + 3]));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf [offset]) << 24) | ((buf [offset + 1]) << 16) | ((buf [offset + 2]) << 8) | (buf [offset + 3]));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf [offset]) << 24) | ((buf [offset + 1]) << 16) | ((buf [offset + 2]) << 8) | (buf [offset + 3]));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf [offset]) << 24) | ((buf [offset + 1]) << 16) | ((buf [offset + 2]) << 8) | (buf [offset + 3]));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf [offset]) << 24) | ((buf [offset + 1]) << 16) | ((buf [offset + 2]) << 8) | (buf [offset + 3]));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf [offset]) | ((buf [offset + 1]) << 8) | ((buf [offset + 2]) << 16) | ((buf [offset + 3]) << 24));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf [offset]) | ((buf [offset + 1]) << 8) | ((buf [offset + 2]) << 16) | ((buf [offset + 3]) << 24));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf [offset]) | ((buf [offset + 1]) << 8) | ((buf [offset + 2]) << 16) | ((buf [offset + 3]) << 24));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf [offset]) | ((buf [offset + 1]) << 8) | ((buf [offset + 2]) << 16) | ((buf [offset + 3]) << 24));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf [offset]) | ((buf [offset + 1]) << 8) | ((buf [offset + 2]) << 16) | ((buf [offset + 3]) << 24));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3])));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3])));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3])));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3])));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (((uint)(buf [offset]) << 24) | ((uint)(buf [offset + 1]) << 16) | ((uint)(buf [offset + 2]) << 8) | ((uint)(buf [offset + 3])));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,ShortToBytes,The following statement contains a magic number: buf [offset++] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,ShortToBytes,The following statement contains a magic number: return 2;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,ShortToLittleBytes,The following statement contains a magic number: buf [offset] = (byte)(v >> 8);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,ShortToLittleBytes,The following statement contains a magic number: return 2;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,BytesToShort,The following statement contains a magic number: return (((buf [offset]) << 8) | ((buf [offset + 1]) << 0));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToShort,The following statement contains a magic number: return (((buf [offset]) << 0) | ((buf [offset + 1]) << 8));  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToVarBytes,The following statement contains a magic number: while (i < buf.Length && v >= 0x80) {  	buf [i++] = (byte)(v | 0x80);  	v >>= 7;  }  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,IntToVarBytes,The following statement contains a magic number: v >>= 7;  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,VarBytesToInt,The following statement contains a magic number: do {  	b = buf [i++];  	val |= (b & 0x7F) << shift;  	shift += 7;  } while ((b & 0x80) != 0);  
Magic Number,Aerospike.Client,ByteUtil,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ByteUtil.cs,VarBytesToInt,The following statement contains a magic number: shift += 7;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += FIELD_HEADER_SIZE + 5;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	BatchRead record = records [offsets [i]];  	Key key = record.key;  	string[] binNames = record.binNames;  	dataOffset += key.digest.Length + 4;  	// Avoid relatively expensive full equality checks for performance reasons.  	// Use reference equality only in hope that common namespaces/bin names are set from   	// fixed variables.  It's fine if equality not determined correctly because it just   	// results in more space used. The batch will still be correct.  	if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) {  		// Can set repeat previous namespace/bin names to save space.  		dataOffset++;  	} else {  		// Estimate full header' namespace and bin names.  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  		if (policy.sendSetName) {  			dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  		}  		if (binNames != null) {  			foreach (string binName in binNames) {  				EstimateOperationSize (binName);  			}  		}  		prev = record;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	BatchRead record = records [offsets [i]];  	Key key = record.key;  	string[] binNames = record.binNames;  	dataOffset += key.digest.Length + 4;  	// Avoid relatively expensive full equality checks for performance reasons.  	// Use reference equality only in hope that common namespaces/bin names are set from   	// fixed variables.  It's fine if equality not determined correctly because it just   	// results in more space used. The batch will still be correct.  	if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) {  		// Can set repeat previous namespace/bin names to save space.  		dataOffset++;  	} else {  		// Estimate full header' namespace and bin names.  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  		if (policy.sendSetName) {  			dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  		}  		if (binNames != null) {  			foreach (string binName in binNames) {  				EstimateOperationSize (binName);  			}  		}  		prev = record;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += key.digest.Length + 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) {  	// Can set repeat previous namespace/bin names to save space.  	dataOffset++;  } else {  	// Estimate full header' namespace and bin names.  	dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  	if (policy.sendSetName) {  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  	}  	if (binNames != null) {  		foreach (string binName in binNames) {  			EstimateOperationSize (binName);  		}  	}  	prev = record;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	int index = offsets [i];  	ByteUtil.IntToBytes ((uint)index' dataBuffer' dataOffset);  	dataOffset += 4;  	BatchRead record = records [index];  	Key key = record.key;  	string[] binNames = record.binNames;  	byte[] digest = key.digest;  	Array.Copy (digest' 0' dataBuffer' dataOffset' digest.Length);  	dataOffset += digest.Length;  	// Avoid relatively expensive full equality checks for performance reasons.  	// Use reference equality only in hope that common namespaces/bin names are set from   	// fixed variables.  It's fine if equality not determined correctly because it just   	// results in more space used. The batch will still be correct.		  	if (prev != null && prev.key.ns == key.ns && (!policy.sendSetName || prev.key.setName == key.setName) && prev.binNames == binNames && prev.readAllBins == record.readAllBins) {  		// Can set repeat previous namespace/bin names to save space.  		dataBuffer [dataOffset++] = 1;  		// repeat  	} else {  		// Write full header' namespace and bin names.  		dataBuffer [dataOffset++] = 0;  		// do not repeat  		if (binNames != null && binNames.Length != 0) {  			dataBuffer [dataOffset++] = (byte)readAttr;  			dataOffset += ByteUtil.ShortToBytes (fieldCount' dataBuffer' dataOffset);  			dataOffset += ByteUtil.ShortToBytes ((ushort)binNames.Length' dataBuffer' dataOffset);  			WriteField (key.ns' FieldType.NAMESPACE);  			if (policy.sendSetName) {  				WriteField (key.setName' FieldType.TABLE);  			}  			foreach (string binName in binNames) {  				WriteOperation (binName' Operation.Type.READ);  			}  		} else {  			dataBuffer [dataOffset++] = (byte)(readAttr | (record.readAllBins ? Command.INFO1_GET_ALL : Command.INFO1_NOBINDATA));  			dataOffset += ByteUtil.ShortToBytes (fieldCount' dataBuffer' dataOffset);  			dataOffset += ByteUtil.ShortToBytes (0' dataBuffer' dataOffset);  			WriteField (key.ns' FieldType.NAMESPACE);  			if (policy.sendSetName) {  				WriteField (key.setName' FieldType.TABLE);  			}  		}  		prev = record;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)(dataOffset - MSG_TOTAL_HEADER_SIZE - 4)' dataBuffer' fieldSizeOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += FIELD_HEADER_SIZE + 5;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	Key key = keys [offsets [i]];  	dataOffset += key.digest.Length + 4;  	// Try reference equality in hope that namespace for all keys is set from a fixed variable.  	if (prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)) {  		// Can set repeat previous namespace/bin names to save space.  		dataOffset++;  	} else {  		// Estimate full header' namespace and bin names.  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  		if (policy.sendSetName) {  			dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  		}  		dataOffset += binNameSize;  		prev = key;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	Key key = keys [offsets [i]];  	dataOffset += key.digest.Length + 4;  	// Try reference equality in hope that namespace for all keys is set from a fixed variable.  	if (prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)) {  		// Can set repeat previous namespace/bin names to save space.  		dataOffset++;  	} else {  		// Estimate full header' namespace and bin names.  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  		if (policy.sendSetName) {  			dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  		}  		dataOffset += binNameSize;  		prev = key;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += key.digest.Length + 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: if (prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)) {  	// Can set repeat previous namespace/bin names to save space.  	dataOffset++;  } else {  	// Estimate full header' namespace and bin names.  	dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  	if (policy.sendSetName) {  		dataOffset += ByteUtil.EstimateSizeUtf8 (key.setName) + FIELD_HEADER_SIZE;  	}  	dataOffset += binNameSize;  	prev = key;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += ByteUtil.EstimateSizeUtf8 (key.ns) + FIELD_HEADER_SIZE + 6;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++) {  	int index = offsets [i];  	ByteUtil.IntToBytes ((uint)index' dataBuffer' dataOffset);  	dataOffset += 4;  	Key key = keys [index];  	byte[] digest = key.digest;  	Array.Copy (digest' 0' dataBuffer' dataOffset' digest.Length);  	dataOffset += digest.Length;  	// Try reference equality in hope that namespace for all keys is set from a fixed variable.  	if (prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)) {  		// Can set repeat previous namespace/bin names to save space.  		dataBuffer [dataOffset++] = 1;  		// repeat  	} else {  		// Write full header' namespace and bin names.  		dataBuffer [dataOffset++] = 0;  		// do not repeat  		dataBuffer [dataOffset++] = (byte)readAttr;  		dataOffset += ByteUtil.ShortToBytes (fieldCount' dataBuffer' dataOffset);  		dataOffset += ByteUtil.ShortToBytes ((ushort)operationCount' dataBuffer' dataOffset);  		WriteField (key.ns' FieldType.NAMESPACE);  		if (policy.sendSetName) {  			WriteField (key.setName' FieldType.TABLE);  		}  		if (binNames != null) {  			foreach (string binName in binNames) {  				WriteOperation (binName' Operation.Type.READ);  			}  		}  		prev = key;  	}  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)(dataOffset - MSG_TOTAL_HEADER_SIZE - 4)' dataBuffer' fieldSizeOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetBatchReadDirect,The following statement contains a magic number: WriteHeader (policy' readAttr' 0' 2' operationCount);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 2 + FIELD_HEADER_SIZE;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 4 + FIELD_HEADER_SIZE;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 8 + FIELD_HEADER_SIZE;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader (2' FieldType.SCAN_OPTIONS);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: priority <<= 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader (4' FieldType.SCAN_TIMEOUT);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader (8' FieldType.TRAN_ID);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataOffset += 8 + FIELD_HEADER_SIZE;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null) {  	IndexCollectionType type = statement.filter.CollectionType;  	if (type != IndexCollectionType.DEFAULT) {  		dataOffset += FIELD_HEADER_SIZE + 1;  		fieldCount++;  	}  	dataOffset += FIELD_HEADER_SIZE;  	filterSize++;  	// num filters  	filterSize += statement.filter.EstimateSize ();  	dataOffset += filterSize;  	fieldCount++;  	// Query bin names are specified as a field (Scan bin names are specified later as operations)  	if (statement.binNames != null) {  		dataOffset += FIELD_HEADER_SIZE;  		binNameSize++;  		// num bin names  		foreach (string binName in statement.binNames) {  			binNameSize += ByteUtil.EstimateSizeUtf8 (binName) + 1;  		}  		dataOffset += binNameSize;  		fieldCount++;  	}  } else {  	// Calling query with no filters is more efficiently handled by a primary index scan.   	// Estimate scan options size.  	dataOffset += 2 + FIELD_HEADER_SIZE;  	fieldCount++;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataOffset += 2 + FIELD_HEADER_SIZE;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.functionName != null) {  	dataOffset += FIELD_HEADER_SIZE + 1;  	// udf type  	dataOffset += ByteUtil.EstimateSizeUtf8 (statement.packageName) + FIELD_HEADER_SIZE;  	dataOffset += ByteUtil.EstimateSizeUtf8 (statement.functionName) + FIELD_HEADER_SIZE;  	if (statement.functionArgs.Length > 0) {  		functionArgBuffer = Packer.Pack (statement.functionArgs);  	} else {  		functionArgBuffer = new byte[0];  	}  	dataOffset += FIELD_HEADER_SIZE + functionArgBuffer.Length;  	fieldCount += 4;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: fieldCount += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: WriteFieldHeader (8' FieldType.TRAN_ID);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataOffset += 8;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null) {  	IndexCollectionType type = statement.filter.CollectionType;  	if (type != IndexCollectionType.DEFAULT) {  		WriteFieldHeader (1' FieldType.INDEX_TYPE);  		dataBuffer [dataOffset++] = (byte)type;  	}  	WriteFieldHeader (filterSize' FieldType.INDEX_RANGE);  	dataBuffer [dataOffset++] = (byte)1;  	dataOffset = statement.filter.Write (dataBuffer' dataOffset);  	// Query bin names are specified as a field (Scan bin names are specified later as operations)  	if (statement.binNames != null) {  		WriteFieldHeader (binNameSize' FieldType.QUERY_BINLIST);  		dataBuffer [dataOffset++] = (byte)statement.binNames.Length;  		foreach (string binName in statement.binNames) {  			int len = ByteUtil.StringToUtf8 (binName' dataBuffer' dataOffset + 1);  			dataBuffer [dataOffset] = (byte)len;  			dataOffset += len + 1;  		}  	}  } else {  	// Calling query with no filters is more efficiently handled by a primary index scan.   	WriteFieldHeader (2' FieldType.SCAN_OPTIONS);  	byte priority = (byte)policy.priority;  	priority <<= 4;  	dataBuffer [dataOffset++] = priority;  	dataBuffer [dataOffset++] = (byte)100;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null) {  	IndexCollectionType type = statement.filter.CollectionType;  	if (type != IndexCollectionType.DEFAULT) {  		WriteFieldHeader (1' FieldType.INDEX_TYPE);  		dataBuffer [dataOffset++] = (byte)type;  	}  	WriteFieldHeader (filterSize' FieldType.INDEX_RANGE);  	dataBuffer [dataOffset++] = (byte)1;  	dataOffset = statement.filter.Write (dataBuffer' dataOffset);  	// Query bin names are specified as a field (Scan bin names are specified later as operations)  	if (statement.binNames != null) {  		WriteFieldHeader (binNameSize' FieldType.QUERY_BINLIST);  		dataBuffer [dataOffset++] = (byte)statement.binNames.Length;  		foreach (string binName in statement.binNames) {  			int len = ByteUtil.StringToUtf8 (binName' dataBuffer' dataOffset + 1);  			dataBuffer [dataOffset] = (byte)len;  			dataOffset += len + 1;  		}  	}  } else {  	// Calling query with no filters is more efficiently handled by a primary index scan.   	WriteFieldHeader (2' FieldType.SCAN_OPTIONS);  	byte priority = (byte)policy.priority;  	priority <<= 4;  	dataBuffer [dataOffset++] = priority;  	dataBuffer [dataOffset++] = (byte)100;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null) {  	IndexCollectionType type = statement.filter.CollectionType;  	if (type != IndexCollectionType.DEFAULT) {  		WriteFieldHeader (1' FieldType.INDEX_TYPE);  		dataBuffer [dataOffset++] = (byte)type;  	}  	WriteFieldHeader (filterSize' FieldType.INDEX_RANGE);  	dataBuffer [dataOffset++] = (byte)1;  	dataOffset = statement.filter.Write (dataBuffer' dataOffset);  	// Query bin names are specified as a field (Scan bin names are specified later as operations)  	if (statement.binNames != null) {  		WriteFieldHeader (binNameSize' FieldType.QUERY_BINLIST);  		dataBuffer [dataOffset++] = (byte)statement.binNames.Length;  		foreach (string binName in statement.binNames) {  			int len = ByteUtil.StringToUtf8 (binName' dataBuffer' dataOffset + 1);  			dataBuffer [dataOffset] = (byte)len;  			dataOffset += len + 1;  		}  	}  } else {  	// Calling query with no filters is more efficiently handled by a primary index scan.   	WriteFieldHeader (2' FieldType.SCAN_OPTIONS);  	byte priority = (byte)policy.priority;  	priority <<= 4;  	dataBuffer [dataOffset++] = priority;  	dataBuffer [dataOffset++] = (byte)100;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: WriteFieldHeader (2' FieldType.SCAN_OPTIONS);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: priority <<= 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataBuffer [dataOffset++] = (byte)100;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.functionName != null) {  	WriteFieldHeader (1' FieldType.UDF_OP);  	dataBuffer [dataOffset++] = (statement.returnData) ? (byte)1 : (byte)2;  	WriteField (statement.packageName' FieldType.UDF_PACKAGE_NAME);  	WriteField (statement.functionName' FieldType.UDF_FUNCTION);  	WriteField (functionArgBuffer' FieldType.UDF_ARGLIST);  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataBuffer [dataOffset++] = (statement.returnData) ? (byte)1 : (byte)2;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,EstimateUdfSize,The following statement contains a magic number: return 3;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: dataOffset += 8;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: dataOffset += 8;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: for (int i = 0; i < 11; i++) {  	dataBuffer [dataOffset++] = 0;  }  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)(nameLength + valueLength + 4)' dataBuffer' dataOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)(nameLength + valueLength + 4)' dataBuffer' dataOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)(nameLength + 4)' dataBuffer' dataOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes (4' dataBuffer' dataOffset);  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteFieldHeader,The following statement contains a magic number: dataOffset += 4;  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseResult,The following statement contains a magic number: bis = new BufferedStream (stream' 8192);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseResult,The following statement contains a magic number: while (status) {  	// Read header.  	ReadBytes (8);  	long size = ByteUtil.BytesToLong (dataBuffer' 0);  	int receiveSize = ((int)(size & 0xFFFFFFFFFFFFL));  	if (receiveSize > 0) {  		status = ParseGroup (receiveSize);  	}  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseResult,The following statement contains a magic number: ReadBytes (8);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize) {  	ReadBytes (MSG_REMAINING_HEADER_SIZE);  	resultCode = dataBuffer [5] & 0xFF;  	// The only valid server return codes are "ok" and "not found".  	// If other return codes are received' then abort the batch.  	if (resultCode != 0) {  		if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  			if (stopOnNotFound) {  				return false;  			}  		} else {  			throw new AerospikeException (resultCode);  		}  	}  	byte info3 = dataBuffer [3];  	// If this is the end marker of the response' do not proceed further  	if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST) {  		return false;  	}  	generation = ByteUtil.BytesToInt (dataBuffer' 6);  	expiration = ByteUtil.BytesToInt (dataBuffer' 10);  	batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  	fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  	opCount = ByteUtil.BytesToShort (dataBuffer' 20);  	Key key = ParseKey (fieldCount);  	ParseRow (key);  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: resultCode = dataBuffer [5] & 0xFF;  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: generation = ByteUtil.BytesToInt (dataBuffer' 6);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: expiration = ByteUtil.BytesToInt (dataBuffer' 10);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: batchIndex = ByteUtil.BytesToInt (dataBuffer' 14);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: fieldCount = ByteUtil.BytesToShort (dataBuffer' 18);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: opCount = ByteUtil.BytesToShort (dataBuffer' 20);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++) {  	ReadBytes (4);  	int fieldlen = ByteUtil.BytesToInt (dataBuffer' 0);  	ReadBytes (fieldlen);  	int fieldtype = dataBuffer [0];  	int size = fieldlen - 1;  	switch (fieldtype) {  	case FieldType.DIGEST_RIPE:  		digest = new byte[size];  		Array.Copy (dataBuffer' 1' digest' 0' size);  		break;  	case FieldType.NAMESPACE:  		ns = ByteUtil.Utf8ToString (dataBuffer' 1' size);  		break;  	case FieldType.TABLE:  		setName = ByteUtil.Utf8ToString (dataBuffer' 1' size);  		break;  	case FieldType.KEY:  		userKey = ByteUtil.BytesToKeyValue (dataBuffer [1]' dataBuffer' 2' size - 1);  		break;  	}  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++) {  	ReadBytes (4);  	int fieldlen = ByteUtil.BytesToInt (dataBuffer' 0);  	ReadBytes (fieldlen);  	int fieldtype = dataBuffer [0];  	int size = fieldlen - 1;  	switch (fieldtype) {  	case FieldType.DIGEST_RIPE:  		digest = new byte[size];  		Array.Copy (dataBuffer' 1' digest' 0' size);  		break;  	case FieldType.NAMESPACE:  		ns = ByteUtil.Utf8ToString (dataBuffer' 1' size);  		break;  	case FieldType.TABLE:  		setName = ByteUtil.Utf8ToString (dataBuffer' 1' size);  		break;  	case FieldType.KEY:  		userKey = ByteUtil.BytesToKeyValue (dataBuffer [1]' dataBuffer' 2' size - 1);  		break;  	}  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: ReadBytes (4);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: switch (fieldtype) {  case FieldType.DIGEST_RIPE:  	digest = new byte[size];  	Array.Copy (dataBuffer' 1' digest' 0' size);  	break;  case FieldType.NAMESPACE:  	ns = ByteUtil.Utf8ToString (dataBuffer' 1' size);  	break;  case FieldType.TABLE:  	setName = ByteUtil.Utf8ToString (dataBuffer' 1' size);  	break;  case FieldType.KEY:  	userKey = ByteUtil.BytesToKeyValue (dataBuffer [1]' dataBuffer' 2' size - 1);  	break;  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: userKey = ByteUtil.BytesToKeyValue (dataBuffer [1]' dataBuffer' 2' size - 1);  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte particleType = dataBuffer [5];  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	string name = ByteUtil.Utf8ToString (dataBuffer' 0' nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' 0' particleBytesSize);  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte particleType = dataBuffer [5];  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	string name = ByteUtil.Utf8ToString (dataBuffer' 0' nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' 0' particleBytesSize);  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte particleType = dataBuffer [5];  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	string name = ByteUtil.Utf8ToString (dataBuffer' 0' nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' 0' particleBytesSize);  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte particleType = dataBuffer [5];  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	string name = ByteUtil.Utf8ToString (dataBuffer' 0' nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' 0' particleBytesSize);  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	bins [name] = value;  }  
Magic Number,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: ReadBytes (8);  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: try {  	string[] list = ret.Split (':');  	code = Convert.ToInt32 (list [2].Trim ());  	if (code == ResultCode.LARGE_ITEM_NOT_FOUND) {  		record = null;  		return;  	}  	message = list [0] + ':' + list [1] + ' ' + list [3];  } catch (Exception) {  	// Use generic exception if parse error occurs.  	throw new AerospikeException (resultCode' ret);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: try {  	string[] list = ret.Split (':');  	code = Convert.ToInt32 (list [2].Trim ());  	if (code == ResultCode.LARGE_ITEM_NOT_FOUND) {  		record = null;  		return;  	}  	message = list [0] + ':' + list [1] + ' ' + list [3];  } catch (Exception) {  	// Use generic exception if parse error occurs.  	throw new AerospikeException (resultCode' ret);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: code = Convert.ToInt32 (list [2].Trim ());  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: message = list [0] + ':' + list [1] + ' ' + list [3];  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: if (fieldCount != 0) {  	// Just skip over all the fields  	for (int i = 0; i < fieldCount; i++) {  		int fieldSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  		receiveOffset += 4 + fieldSize;  	}  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++) {  	int fieldSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	receiveOffset += 4 + fieldSize;  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: receiveOffset += 4 + fieldSize;  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	int opSize = ByteUtil.BytesToInt (dataBuffer' receiveOffset);  	byte particleType = dataBuffer [receiveOffset + 5];  	byte nameSize = dataBuffer [receiveOffset + 7];  	string name = ByteUtil.Utf8ToString (dataBuffer' receiveOffset + 8' nameSize);  	receiveOffset += 4 + 4 + nameSize;  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	object value = ByteUtil.BytesToParticle (particleType' dataBuffer' receiveOffset' particleBytesSize);  	receiveOffset += particleBytesSize;  	if (bins == null) {  		bins = new Dictionary<string' object> ();  	}  	AddBin (bins' name' value);  }  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: receiveOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,ReadCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: receiveOffset += 4 + 4 + nameSize;  
Magic Number,Aerospike.Client,ReadHeaderCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadHeaderCommand.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0) {  	int generation = ByteUtil.BytesToInt (dataBuffer' 14);  	int expiration = ByteUtil.BytesToInt (dataBuffer' 18);  	record = new Record (null' generation' expiration);  } else {  	if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  		record = null;  	} else {  		throw new AerospikeException (resultCode);  	}  }  
Magic Number,Aerospike.Client,ReadHeaderCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\ReadHeaderCommand.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0) {  	int generation = ByteUtil.BytesToInt (dataBuffer' 14);  	int expiration = ByteUtil.BytesToInt (dataBuffer' 18);  	record = new Record (null' generation' expiration);  } else {  	if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR) {  		record = null;  	} else {  		throw new AerospikeException (resultCode);  	}  }  
Magic Number,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: while (true) {  	try {  		node = GetNode ();  		Connection conn = node.GetConnection (remainingMillis);  		try {  			// Set command buffer.  			WriteBuffer ();  			// Check if timeout needs to be changed in send buffer.  			if (remainingMillis != policy.timeout) {  				// Reset timeout in send buffer (destined for server) and socket.  				ByteUtil.IntToBytes ((uint)remainingMillis' dataBuffer' 22);  			}  			// Send command.  			conn.Write (dataBuffer' dataOffset);  			// Parse results.  			ParseResult (conn);  			// Put connection back in pool.  			node.PutConnection (conn);  			// Command has completed successfully.  Exit method.  			return;  		} catch (AerospikeException ae) {  			if (ae.KeepConnection ()) {  				// Put connection back in pool.  				node.PutConnection (conn);  			} else {  				// Close socket to flush out possible garbage.  Do not put back in pool.  				node.CloseConnection (conn);  			}  			throw;  		} catch (SocketException se) {  			// Socket errors are considered temporary anomalies.  			// Retry after closing connection.  			node.CloseConnection (conn);  			exception = se;  		} catch (Exception) {  			// All other exceptions are considered fatal.  Do not retry.  			// Close socket to flush out possible garbage.  Do not put back in pool.  			node.CloseConnection (conn);  			throw;  		}  	} catch (AerospikeException.InvalidNode ine) {  		// Node is currently inactive.  Retry.  		exception = ine;  		failedNodes++;  	} catch (AerospikeException.Connection ce) {  		// Socket connection error has occurred. Retry.  		exception = ce;  		failedConns++;  	}  	if (++iterations > policy.maxRetries) {  		break;  	}  	// Check for client timeout.  	if (policy.timeout > 0 && !policy.retryOnTimeout) {  		// Timeout is absolute.  Stop if timeout has been reached.  		remainingMillis = (int)limit.Subtract (DateTime.UtcNow).TotalMilliseconds - policy.sleepBetweenRetries;  		if (remainingMillis <= 0) {  			break;  		}  	}  	if (policy.sleepBetweenRetries > 0) {  		// Sleep before trying again.  		Util.Sleep (policy.sleepBetweenRetries);  	}  	// Reset node reference and try again.  	node = null;  }  
Magic Number,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: try {  	node = GetNode ();  	Connection conn = node.GetConnection (remainingMillis);  	try {  		// Set command buffer.  		WriteBuffer ();  		// Check if timeout needs to be changed in send buffer.  		if (remainingMillis != policy.timeout) {  			// Reset timeout in send buffer (destined for server) and socket.  			ByteUtil.IntToBytes ((uint)remainingMillis' dataBuffer' 22);  		}  		// Send command.  		conn.Write (dataBuffer' dataOffset);  		// Parse results.  		ParseResult (conn);  		// Put connection back in pool.  		node.PutConnection (conn);  		// Command has completed successfully.  Exit method.  		return;  	} catch (AerospikeException ae) {  		if (ae.KeepConnection ()) {  			// Put connection back in pool.  			node.PutConnection (conn);  		} else {  			// Close socket to flush out possible garbage.  Do not put back in pool.  			node.CloseConnection (conn);  		}  		throw;  	} catch (SocketException se) {  		// Socket errors are considered temporary anomalies.  		// Retry after closing connection.  		node.CloseConnection (conn);  		exception = se;  	} catch (Exception) {  		// All other exceptions are considered fatal.  Do not retry.  		// Close socket to flush out possible garbage.  Do not put back in pool.  		node.CloseConnection (conn);  		throw;  	}  } catch (AerospikeException.InvalidNode ine) {  	// Node is currently inactive.  Retry.  	exception = ine;  	failedNodes++;  } catch (AerospikeException.Connection ce) {  	// Socket connection error has occurred. Retry.  	exception = ce;  	failedConns++;  }  
Magic Number,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: try {  	// Set command buffer.  	WriteBuffer ();  	// Check if timeout needs to be changed in send buffer.  	if (remainingMillis != policy.timeout) {  		// Reset timeout in send buffer (destined for server) and socket.  		ByteUtil.IntToBytes ((uint)remainingMillis' dataBuffer' 22);  	}  	// Send command.  	conn.Write (dataBuffer' dataOffset);  	// Parse results.  	ParseResult (conn);  	// Put connection back in pool.  	node.PutConnection (conn);  	// Command has completed successfully.  Exit method.  	return;  } catch (AerospikeException ae) {  	if (ae.KeepConnection ()) {  		// Put connection back in pool.  		node.PutConnection (conn);  	} else {  		// Close socket to flush out possible garbage.  Do not put back in pool.  		node.CloseConnection (conn);  	}  	throw;  } catch (SocketException se) {  	// Socket errors are considered temporary anomalies.  	// Retry after closing connection.  	node.CloseConnection (conn);  	exception = se;  } catch (Exception) {  	// All other exceptions are considered fatal.  Do not retry.  	// Close socket to flush out possible garbage.  Do not put back in pool.  	node.CloseConnection (conn);  	throw;  }  
Magic Number,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: if (remainingMillis != policy.timeout) {  	// Reset timeout in send buffer (destined for server) and socket.  	ByteUtil.IntToBytes ((uint)remainingMillis' dataBuffer' 22);  }  
Magic Number,Aerospike.Client,SyncCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: ByteUtil.IntToBytes ((uint)remainingMillis' dataBuffer' 22);  
Magic Number,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,ScanAll,The following statement contains a magic number: if (policy.scanPercent <= 0 || policy.scanPercent > 100) {  	throw new AerospikeException (ResultCode.PARAMETER_ERROR' "Invalid scan percent: " + policy.scanPercent);  }  
Magic Number,Aerospike.Client,AerospikeClient,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The following statement contains a magic number: if (policy.scanPercent <= 0 || policy.scanPercent > 100) {  	throw new AerospikeException (ResultCode.PARAMETER_ERROR' "Invalid scan percent: " + policy.scanPercent);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length) {  	offset = ByteUtil.EstimateSizeUtf8 (command) + 9;  	ResizeBuffer (offset);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length) {  	offset = ByteUtil.EstimateSizeUtf8 (command) + 9;  	ResizeBuffer (offset);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length) {  	offset = ByteUtil.EstimateSizeUtf8 (command) + 9;  	ResizeBuffer (offset);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = ByteUtil.EstimateSizeUtf8 (command) + 9;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: foreach (string command in commands) {  	offset += command.Length * 2 + 1;  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset += command.Length * 2 + 1;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if (offset > buffer.Length) {  	offset = 8;  	foreach (string command in commands) {  		offset += ByteUtil.EstimateSizeUtf8 (command) + 1;  	}  	ResizeBuffer (offset);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: while (offset < length) {  	b = buffer [offset];  	if (b < 48 || b > 57) {  		end = offset;  		break;  	}  	offset++;  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: while (offset < length) {  	b = buffer [offset];  	if (b < 48 || b > 57) {  		end = offset;  		break;  	}  	offset++;  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: if (b < 48 || b > 57) {  	end = offset;  	break;  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: if (b < 48 || b > 57) {  	end = offset;  	break;  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try {  	// Write size field.  	ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  	ByteUtil.LongToBytes (size' buffer' 0);  	// Write.  	conn.Write (buffer' offset);  	// Read - reuse input buffer.  	conn.ReadFully (buffer' 8);  	size = (ulong)ByteUtil.BytesToLong (buffer' 0);  	length = (int)(size & 0xFFFFFFFFFFFFL);  	ResizeBuffer (length);  	conn.ReadFully (buffer' length);  	offset = 0;  } catch (SocketException se) {  	throw new AerospikeException (se);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try {  	// Write size field.  	ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  	ByteUtil.LongToBytes (size' buffer' 0);  	// Write.  	conn.Write (buffer' offset);  	// Read - reuse input buffer.  	conn.ReadFully (buffer' 8);  	size = (ulong)ByteUtil.BytesToLong (buffer' 0);  	length = (int)(size & 0xFFFFFFFFFFFFL);  	ResizeBuffer (length);  	conn.ReadFully (buffer' length);  	offset = 0;  } catch (SocketException se) {  	throw new AerospikeException (se);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try {  	// Write size field.  	ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  	ByteUtil.LongToBytes (size' buffer' 0);  	// Write.  	conn.Write (buffer' offset);  	// Read - reuse input buffer.  	conn.ReadFully (buffer' 8);  	size = (ulong)ByteUtil.BytesToLong (buffer' 0);  	length = (int)(size & 0xFFFFFFFFFFFFL);  	ResizeBuffer (length);  	conn.ReadFully (buffer' length);  	offset = 0;  } catch (SocketException se) {  	throw new AerospikeException (se);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: conn.ReadFully (buffer' 8);  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (str.StartsWith ("ERROR:")) {  	int begin = 6;  	int end = str.IndexOf (':'' begin);  	int code = -1;  	string message = "";  	if (end >= 0) {  		code = int.Parse (str.Substring (begin' end - begin));  		if (str [str.Length - 1] == '\n') {  			message = str.Substring (end + 1' str.Length - 2);  		} else {  			message = str.Substring (end + 1);  		}  	}  	throw new AerospikeException (code' message);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (str.StartsWith ("ERROR:")) {  	int begin = 6;  	int end = str.IndexOf (':'' begin);  	int code = -1;  	string message = "";  	if (end >= 0) {  		code = int.Parse (str.Substring (begin' end - begin));  		if (str [str.Length - 1] == '\n') {  			message = str.Substring (end + 1' str.Length - 2);  		} else {  			message = str.Substring (end + 1);  		}  	}  	throw new AerospikeException (code' message);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (end >= 0) {  	code = int.Parse (str.Substring (begin' end - begin));  	if (str [str.Length - 1] == '\n') {  		message = str.Substring (end + 1' str.Length - 2);  	} else {  		message = str.Substring (end + 1);  	}  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (str [str.Length - 1] == '\n') {  	message = str.Substring (end + 1' str.Length - 2);  } else {  	message = str.Substring (end + 1);  }  
Magic Number,Aerospike.Client,Info,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: message = str.Substring (end + 1' str.Length - 2);  
Magic Number,Aerospike.Client,Key,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Key.cs,GetHashCode,The following statement contains a magic number: foreach (byte element in digest) {  	result = 31 * result + element;  }  
Magic Number,Aerospike.Client,Key,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Key.cs,GetHashCode,The following statement contains a magic number: result = 31 * result + element;  
Magic Number,Aerospike.Client,Key,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Key.cs,GetHashCode,The following statement contains a magic number: return 31 * result + ns.GetHashCode ();  
Magic Number,Aerospike.Client,Record,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Record.cs,ToString,The following statement contains a magic number: if (bins != null) {  	bool sep = false;  	foreach (KeyValuePair<string' object> entry in bins) {  		if (sep) {  			sb.Append (''');  		} else {  			sep = true;  		}  		sb.Append ('(');  		sb.Append (entry.Key);  		sb.Append (':');  		sb.Append (entry.Value);  		sb.Append (')');  		if (sb.Length > 1000) {  			sb.Append ("...");  			break;  		}  	}  } else {  	sb.Append ("null");  }  
Magic Number,Aerospike.Client,Record,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Record.cs,ToString,The following statement contains a magic number: foreach (KeyValuePair<string' object> entry in bins) {  	if (sep) {  		sb.Append (''');  	} else {  		sep = true;  	}  	sb.Append ('(');  	sb.Append (entry.Key);  	sb.Append (':');  	sb.Append (entry.Value);  	sb.Append (')');  	if (sb.Length > 1000) {  		sb.Append ("...");  		break;  	}  }  
Magic Number,Aerospike.Client,Record,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Main\Record.cs,ToString,The following statement contains a magic number: if (sb.Length > 1000) {  	sb.Append ("...");  	break;  }  
Magic Number,Aerospike.Client,InfoPolicy,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Policy\InfoPolicy.cs,InfoPolicy,The following statement contains a magic number: timeout = 1000;  
Magic Number,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,EstimateSize,The following statement contains a magic number: return ByteUtil.EstimateSizeUtf8 (name) + begin.EstimateSize () + end.EstimateSize () + 10;  
Magic Number,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: len = begin.Write (buf' offset + 4);  
Magic Number,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: offset += len + 4;  
Magic Number,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: len = end.Write (buf' offset + 4);  
Magic Number,Aerospike.Client,Filter,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: offset += len + 4;  
Magic Number,Aerospike.Client,QueryAggregateCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The following statement contains a magic number: ReadBytes (8);  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,QueryAggregateExecutor,The following statement contains a magic number: inputQueue = new BlockingCollection<object> (500);  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try {  	lua = LuaCache.GetInstance ();  	// Start thread queries to each node.  	StartThreads ();  	lua.LoadPackage (statement);  	object[] args = new object[4 + statement.functionArgs.Length];  	args [0] = lua.GetFunction (statement.functionName);  	args [1] = 2;  	args [2] = new LuaInputStream (inputQueue' cancel.Token);  	args [3] = new LuaOutputStream (resultSet);  	int count = 4;  	foreach (Value value in statement.functionArgs) {  		args [count++] = value.Object;  	}  	lua.Call ("apply_stream"' args);  } catch (Neo.IronLua.LuaRuntimeException lre) {  	// Try to get that elusive lua stack trace.  	HandleException (new Exception (lre.Message + lre.StackTrace));  } catch (Exception e) {  	if (e.InnerException is Neo.IronLua.LuaRuntimeException) {  		// Try to get that elusive lua stack trace.  		Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  		HandleException (new Exception (lre.Message + lre.StackTrace));  	} else {  		HandleException (e);  	}  } finally {  	// Send end command to user's result set.  	// If query was already cancelled' this put will be ignored.  	resultSet.Put (ResultSet.END);  	if (lua != null) {  		LuaCache.PutInstance (lua);  	}  }  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try {  	lua = LuaCache.GetInstance ();  	// Start thread queries to each node.  	StartThreads ();  	lua.LoadPackage (statement);  	object[] args = new object[4 + statement.functionArgs.Length];  	args [0] = lua.GetFunction (statement.functionName);  	args [1] = 2;  	args [2] = new LuaInputStream (inputQueue' cancel.Token);  	args [3] = new LuaOutputStream (resultSet);  	int count = 4;  	foreach (Value value in statement.functionArgs) {  		args [count++] = value.Object;  	}  	lua.Call ("apply_stream"' args);  } catch (Neo.IronLua.LuaRuntimeException lre) {  	// Try to get that elusive lua stack trace.  	HandleException (new Exception (lre.Message + lre.StackTrace));  } catch (Exception e) {  	if (e.InnerException is Neo.IronLua.LuaRuntimeException) {  		// Try to get that elusive lua stack trace.  		Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  		HandleException (new Exception (lre.Message + lre.StackTrace));  	} else {  		HandleException (e);  	}  } finally {  	// Send end command to user's result set.  	// If query was already cancelled' this put will be ignored.  	resultSet.Put (ResultSet.END);  	if (lua != null) {  		LuaCache.PutInstance (lua);  	}  }  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try {  	lua = LuaCache.GetInstance ();  	// Start thread queries to each node.  	StartThreads ();  	lua.LoadPackage (statement);  	object[] args = new object[4 + statement.functionArgs.Length];  	args [0] = lua.GetFunction (statement.functionName);  	args [1] = 2;  	args [2] = new LuaInputStream (inputQueue' cancel.Token);  	args [3] = new LuaOutputStream (resultSet);  	int count = 4;  	foreach (Value value in statement.functionArgs) {  		args [count++] = value.Object;  	}  	lua.Call ("apply_stream"' args);  } catch (Neo.IronLua.LuaRuntimeException lre) {  	// Try to get that elusive lua stack trace.  	HandleException (new Exception (lre.Message + lre.StackTrace));  } catch (Exception e) {  	if (e.InnerException is Neo.IronLua.LuaRuntimeException) {  		// Try to get that elusive lua stack trace.  		Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  		HandleException (new Exception (lre.Message + lre.StackTrace));  	} else {  		HandleException (e);  	}  } finally {  	// Send end command to user's result set.  	// If query was already cancelled' this put will be ignored.  	resultSet.Put (ResultSet.END);  	if (lua != null) {  		LuaCache.PutInstance (lua);  	}  }  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try {  	lua = LuaCache.GetInstance ();  	// Start thread queries to each node.  	StartThreads ();  	lua.LoadPackage (statement);  	object[] args = new object[4 + statement.functionArgs.Length];  	args [0] = lua.GetFunction (statement.functionName);  	args [1] = 2;  	args [2] = new LuaInputStream (inputQueue' cancel.Token);  	args [3] = new LuaOutputStream (resultSet);  	int count = 4;  	foreach (Value value in statement.functionArgs) {  		args [count++] = value.Object;  	}  	lua.Call ("apply_stream"' args);  } catch (Neo.IronLua.LuaRuntimeException lre) {  	// Try to get that elusive lua stack trace.  	HandleException (new Exception (lre.Message + lre.StackTrace));  } catch (Exception e) {  	if (e.InnerException is Neo.IronLua.LuaRuntimeException) {  		// Try to get that elusive lua stack trace.  		Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  		HandleException (new Exception (lre.Message + lre.StackTrace));  	} else {  		HandleException (e);  	}  } finally {  	// Send end command to user's result set.  	// If query was already cancelled' this put will be ignored.  	resultSet.Put (ResultSet.END);  	if (lua != null) {  		LuaCache.PutInstance (lua);  	}  }  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try {  	lua = LuaCache.GetInstance ();  	// Start thread queries to each node.  	StartThreads ();  	lua.LoadPackage (statement);  	object[] args = new object[4 + statement.functionArgs.Length];  	args [0] = lua.GetFunction (statement.functionName);  	args [1] = 2;  	args [2] = new LuaInputStream (inputQueue' cancel.Token);  	args [3] = new LuaOutputStream (resultSet);  	int count = 4;  	foreach (Value value in statement.functionArgs) {  		args [count++] = value.Object;  	}  	lua.Call ("apply_stream"' args);  } catch (Neo.IronLua.LuaRuntimeException lre) {  	// Try to get that elusive lua stack trace.  	HandleException (new Exception (lre.Message + lre.StackTrace));  } catch (Exception e) {  	if (e.InnerException is Neo.IronLua.LuaRuntimeException) {  		// Try to get that elusive lua stack trace.  		Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  		HandleException (new Exception (lre.Message + lre.StackTrace));  	} else {  		HandleException (e);  	}  } finally {  	// Send end command to user's result set.  	// If query was already cancelled' this put will be ignored.  	resultSet.Put (ResultSet.END);  	if (lua != null) {  		LuaCache.PutInstance (lua);  	}  }  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: args [1] = 2;  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: args [2] = new LuaInputStream (inputQueue' cancel.Token);  
Magic Number,Aerospike.Client,QueryAggregateExecutor,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: args [3] = new LuaOutputStream (resultSet);  
Magic Number,Aerospike.Client,ServerCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  }  
Magic Number,Aerospike.Client,ServerCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  }  
Magic Number,Aerospike.Client,ServerCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0; i < opCount; i++) {  	ReadBytes (8);  	int opSize = ByteUtil.BytesToInt (dataBuffer' 0);  	byte nameSize = dataBuffer [7];  	ReadBytes (nameSize);  	int particleBytesSize = (int)(opSize - (4 + nameSize));  	ReadBytes (particleBytesSize);  }  
Magic Number,Aerospike.Client,ServerCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: ReadBytes (8);  
Magic Number,Aerospike.Client,Statement,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Statement.cs,SetBinNames,The following statement contains a magic number: foreach (string binName in binNames) {  	if (binName.Length > 14) {  		throw new AerospikeException (ResultCode.BIN_NAME_TOO_LONG' "Bin name length greater than 14 characters");  	}  }  
Magic Number,Aerospike.Client,Statement,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Query\Statement.cs,SetBinNames,The following statement contains a magic number: if (binName.Length > 14) {  	throw new AerospikeException (ResultCode.BIN_NAME_TOO_LONG' "Bin name length greater than 14 characters");  }  
Magic Number,Aerospike.Client,BaseTask,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Task\BaseTask.cs,Wait,The following statement contains a magic number: TaskWait (1000);  
Magic Number,Aerospike.Client,BaseTask,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Task\BaseTask.cs,IsDone,The following statement contains a magic number: if (status == NOT_FOUND) {  	// The task may have not started yet.  Re-request status after a delay.  	Util.Sleep (1000);  	status = QueryStatus ();  }  
Magic Number,Aerospike.Client,BaseTask,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Task\BaseTask.cs,IsDone,The following statement contains a magic number: Util.Sleep (1000);  
Magic Number,Aerospike.Client,IndexTask,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Task\IndexTask.cs,QueryStatus,The following statement contains a magic number: foreach (Node node in nodes) {  	string response = Info.Request (policy' node' command);  	string find = "load_pct=";  	int index = response.IndexOf (find);  	if (index < 0) {  		if (response.IndexOf ("FAIL:201") >= 0 || response.IndexOf ("FAIL:203") >= 0) {  			// Index not found or not readable.  			return BaseTask.NOT_FOUND;  		} else {  			// Throw exception immediately.  			throw new AerospikeException (command + " failed: " + response);  		}  	}  	int begin = index + find.Length;  	int end = response.IndexOf (';'' begin);  	string str = response.Substring (begin' end - begin);  	int pct = Convert.ToInt32 (str);  	if (pct != 100) {  		return BaseTask.IN_PROGRESS;  	}  }  
Magic Number,Aerospike.Client,IndexTask,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Task\IndexTask.cs,QueryStatus,The following statement contains a magic number: if (pct != 100) {  	return BaseTask.IN_PROGRESS;  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackArrayBegin,The following statement contains a magic number: if (size < 16) {  	PackByte ((byte)(0x90 | size));  } else if (size < 65536) {  	PackShort (0xdc' (ushort)size);  } else {  	PackInt (0xdd' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackArrayBegin,The following statement contains a magic number: if (size < 16) {  	PackByte ((byte)(0x90 | size));  } else if (size < 65536) {  	PackShort (0xdc' (ushort)size);  } else {  	PackInt (0xdd' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackArrayBegin,The following statement contains a magic number: if (size < 65536) {  	PackShort (0xdc' (ushort)size);  } else {  	PackInt (0xdd' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackMapBegin,The following statement contains a magic number: if (size < 16) {  	PackByte ((byte)(0x80 | size));  } else if (size < 65536) {  	PackShort (0xde' (ushort)size);  } else {  	PackInt (0xdf' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackMapBegin,The following statement contains a magic number: if (size < 16) {  	PackByte ((byte)(0x80 | size));  } else if (size < 65536) {  	PackShort (0xde' (ushort)size);  } else {  	PackInt (0xdf' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackMapBegin,The following statement contains a magic number: if (size < 65536) {  	PackShort (0xde' (ushort)size);  } else {  	PackInt (0xdf' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByteArrayBegin,The following statement contains a magic number: if (size < 32) {  	PackByte ((byte)(0xa0 | size));  } else if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByteArrayBegin,The following statement contains a magic number: if (size < 32) {  	PackByte ((byte)(0xa0 | size));  } else if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByteArrayBegin,The following statement contains a magic number: if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= 0L) {  	if (val < 128L) {  		PackByte ((byte)val);  		return;  	}  	if (val < 256L) {  		PackByte (0xcc' (byte)val);  		return;  	}  	if (val < 65536L) {  		PackShort (0xcd' (ushort)val);  		return;  	}  	if (val < 4294967296L) {  		PackInt (0xce' (uint)val);  		return;  	}  	PackLong (0xcf' (ulong)val);  } else {  	if (val >= -32) {  		PackByte ((byte)(0xe0 | ((int)val + 32)));  		return;  	}  	if (val >= byte.MinValue) {  		PackByte (0xd0' (byte)val);  		return;  	}  	if (val >= short.MinValue) {  		PackShort (0xd1' (ushort)val);  		return;  	}  	if (val >= int.MinValue) {  		PackInt (0xd2' (uint)val);  		return;  	}  	PackLong (0xd3' (ulong)val);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= 0L) {  	if (val < 128L) {  		PackByte ((byte)val);  		return;  	}  	if (val < 256L) {  		PackByte (0xcc' (byte)val);  		return;  	}  	if (val < 65536L) {  		PackShort (0xcd' (ushort)val);  		return;  	}  	if (val < 4294967296L) {  		PackInt (0xce' (uint)val);  		return;  	}  	PackLong (0xcf' (ulong)val);  } else {  	if (val >= -32) {  		PackByte ((byte)(0xe0 | ((int)val + 32)));  		return;  	}  	if (val >= byte.MinValue) {  		PackByte (0xd0' (byte)val);  		return;  	}  	if (val >= short.MinValue) {  		PackShort (0xd1' (ushort)val);  		return;  	}  	if (val >= int.MinValue) {  		PackInt (0xd2' (uint)val);  		return;  	}  	PackLong (0xd3' (ulong)val);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= -32) {  	PackByte ((byte)(0xe0 | ((int)val + 32)));  	return;  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= -32) {  	PackByte ((byte)(0xe0 | ((int)val + 32)));  	return;  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: PackByte ((byte)(0xe0 | ((int)val + 32)));  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackString,The following statement contains a magic number: if (size < 32) {  	PackByte ((byte)(0xa0 | size));  } // TODO: Enable this code after all servers/clients  // have been upgraded to handle 8 bit string length format.  /* 			else if (size < 256) 			{ 				PackByte(0xd9' (byte)size); 			} 			*/else if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackString,The following statement contains a magic number: if (size < 32) {  	PackByte ((byte)(0xa0 | size));  } // TODO: Enable this code after all servers/clients  // have been upgraded to handle 8 bit string length format.  /* 			else if (size < 256) 			{ 				PackByte(0xd9' (byte)size); 			} 			*/else if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackString,The following statement contains a magic number: if (size < 65536) {  	PackShort (0xda' (ushort)size);  } else {  	PackInt (0xdb' (uint)size);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackDouble,The following statement contains a magic number: if (offset + 9 > buffer.Length) {  	Resize (9);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackDouble,The following statement contains a magic number: if (offset + 9 > buffer.Length) {  	Resize (9);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackDouble,The following statement contains a magic number: Resize (9);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackFloat,The following statement contains a magic number: if (offset + 5 > buffer.Length) {  	Resize (5);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackFloat,The following statement contains a magic number: if (offset + 5 > buffer.Length) {  	Resize (5);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackFloat,The following statement contains a magic number: Resize (5);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: if (offset + 9 > buffer.Length) {  	Resize (9);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: if (offset + 9 > buffer.Length) {  	Resize (9);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: Resize (9);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: offset += 8;  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: if (offset + 5 > buffer.Length) {  	Resize (5);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: if (offset + 5 > buffer.Length) {  	Resize (5);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: Resize (5);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: if (offset + 3 > buffer.Length) {  	Resize (3);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: if (offset + 3 > buffer.Length) {  	Resize (3);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: Resize (3);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: if (offset + 2 > buffer.Length) {  	Resize (2);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: if (offset + 2 > buffer.Length) {  	Resize (2);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: Resize (2);  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByte,The following statement contains a magic number: if (offset + 2 > buffer.Length) {  	Resize (2);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByte,The following statement contains a magic number: if (offset + 2 > buffer.Length) {  	Resize (2);  }  
Magic Number,Aerospike.Client,Packer,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Packer.cs,PackByte,The following statement contains a magic number: Resize (2);  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: while (i < len) {  	ulong r = NextLong ();  	int n = Math.Min (len - i' 8);  	for (int j = 0; j < n; j++) {  		bytes [i++] = (byte)r;  		r >>= 8;  	}  }  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: while (i < len) {  	ulong r = NextLong ();  	int n = Math.Min (len - i' 8);  	for (int j = 0; j < n; j++) {  		bytes [i++] = (byte)r;  		r >>= 8;  	}  }  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	bytes [i++] = (byte)r;  	r >>= 8;  }  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: r >>= 8;  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: s1 ^= s1 << 23;  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: seed1 = (s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5));  
Magic Number,Aerospike.Client,RandomShift,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: seed1 = (s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5));  
Magic Number,Aerospike.Client,ThreadLocalData,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\ThreadLocalData.cs,GetBuffer,The following statement contains a magic number: if (BufferThreadLocal == null) {  	BufferThreadLocal = new byte[8192];  }  
Magic Number,Aerospike.Client,ThreadLocalData,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\ThreadLocalData.cs,GetBuffer,The following statement contains a magic number: BufferThreadLocal = new byte[8192];  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if ((type & 0xf0) == 0x90) {  	count = type & 0x0f;  } else if (type == 0xdc) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdd) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new List<object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if ((type & 0xf0) == 0x90) {  	count = type & 0x0f;  } else if (type == 0xdc) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdd) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new List<object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if (type == 0xdc) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdd) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new List<object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if (type == 0xdc) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdd) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new List<object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if (type == 0xdd) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new List<object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if ((type & 0xf0) == 0x80) {  	count = type & 0x0f;  } else if (type == 0xde) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdf) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new Dictionary<object' object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if ((type & 0xf0) == 0x80) {  	count = type & 0x0f;  } else if (type == 0xde) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdf) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new Dictionary<object' object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if (type == 0xde) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdf) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new Dictionary<object' object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if (type == 0xde) {  	count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  } else if (type == 0xdf) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new Dictionary<object' object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if (type == 0xdf) {  	count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  } else {  	return new Dictionary<object' object> (0);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,CreateMap,The following statement contains a magic number: if (type == 0xc7) {  	int extensionType = buffer [offset + 1] & 0xff;  	if (extensionType == 0) {  		int mapBits = buffer [offset + 2] & 0xff;  		// Extension is a map type.  Determine which one.  		if ((mapBits & (0x04 | 0x08)) != 0) {  			// Index/rank range result where order needs to be preserved.  			return null;  		} else if ((mapBits & 0x01) != 0) {  			// Sorted map  			return new SortedDictionary<object' object> ();  		}  	}  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,CreateMap,The following statement contains a magic number: if (extensionType == 0) {  	int mapBits = buffer [offset + 2] & 0xff;  	// Extension is a map type.  Determine which one.  	if ((mapBits & (0x04 | 0x08)) != 0) {  		// Index/rank range result where order needs to be preserved.  		return null;  	} else if ((mapBits & 0x01) != 0) {  		// Sorted map  		return new SortedDictionary<object' object> ();  	}  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type) {  case 0xc0:// nil   {  	return null;  }  case 0xc3:// boolean true   {  	return true;  }  case 0xc2:// boolean false   {  	return false;  }  case 0xca:// float   {  	float val = ByteUtil.BytesToFloat (buffer' offset);  	offset += 4;  	return val;  }  case 0xcb:// double   {  	double val = ByteUtil.BytesToDouble (buffer' offset);  	offset += 8;  	return val;  }  case 0xd0:// signed 8 bit integer   {  	return (long)(sbyte)(buffer [offset++]);  }  case 0xcc:// unsigned 8 bit integer   {  	return (long)(buffer [offset++]);  }  case 0xd1:// signed 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)(short)val;  }  case 0xcd:// unsigned 16 bit integer   {  	int val = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return (long)val;  }  case 0xd2:// signed 32 bit integer   {  	int val = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xce:// unsigned 32 bit integer   {  	uint val = ByteUtil.BytesToUInt (buffer' offset);  	offset += 4;  	return (long)val;  }  case 0xd3:// signed 64 bit integer   {  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xcf:// unsigned 64 bit integer   {  	// The contract is to always return long.    	// The caller can always cast back to ulong.  	long val = ByteUtil.BytesToLong (buffer' offset);  	offset += 8;  	return val;  }  case 0xc4:  case 0xd9:// string raw bytes with 8 bit header   {  	int count = buffer [offset++];  	return UnpackBlob (count);  }  case 0xc5:  case 0xda:// raw bytes with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackBlob (count);  }  case 0xc6:  case 0xdb:// raw bytes with 32 bit header   {  	// Array length is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackBlob (count);  }  case 0xdc:// list with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackList (count);  }  case 0xdd:// list with 32 bit header   {  	// List size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackList (count);  }  case 0xde:// map with 16 bit header   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += 2;  	return UnpackMap (count);  }  case 0xdf:// map with 32 bit header   {  	// Map size is restricted to positive int values (0 - int.MAX_VALUE).  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += 4;  	return UnpackMap (count);  }  case 0xd4:// Skip over type extension with 1 byte   {  	offset += 1 + 1;  	return null;  }  case 0xd5:// Skip over type extension with 2 bytes   {  	offset += 1 + 2;  	return null;  }  case 0xd6:// Skip over type extension with 4 bytes   {  	offset += 1 + 4;  	return null;  }  case 0xd7:// Skip over type extension with 8 bytes   {  	offset += 1 + 8;  	return null;  }  case 0xd8:// Skip over type extension with 16 bytes   {  	offset += 1 + 16;  	return null;  }  case 0xc7:// Skip over type extension with 8 bit header and bytes   {  	int count = buffer [offset];  	offset += count + 1 + 1;  	return null;  }  case 0xc8:// Skip over type extension with 16 bit header and bytes   {  	int count = ByteUtil.BytesToShort (buffer' offset);  	offset += count + 1 + 2;  	return null;  }  case 0xc9:// Skip over type extension with 32 bit header and bytes   {  	int count = ByteUtil.BytesToInt (buffer' offset);  	offset += count + 1 + 4;  	return null;  }  default: {  	if ((type & 0xe0) == 0xa0)// raw bytes with 8 bit combined header  	 {  		return UnpackBlob (type & 0x1f);  	}  	if ((type & 0xf0) == 0x80)// map with 8 bit combined header  	 {  		return UnpackMap (type & 0x0f);  	}  	if ((type & 0xf0) == 0x90)// list with 8 bit combined header  	 {  		return UnpackList (type & 0x0f);  	}  	if (type < 0x80)// 8 bit combined unsigned integer  	 {  		return (long)type;  	}  	if (type >= 0xe0)// 8 bit combined signed integer  	 {  		return (long)(type - 0xe0 - 32);  	}  	throw new IOException ("Unknown unpack type: " + type);  }  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 8;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 8;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 8;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 1 + 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 1 + 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 1 + 8;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += 1 + 16;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += count + 1 + 2;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: offset += count + 1 + 4;  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: if (type >= 0xe0)// 8 bit combined signed integer   {  	return (long)(type - 0xe0 - 32);  }  
Magic Number,Aerospike.Client,Unpacker,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: return (long)(type - 0xe0 - 32);  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: if ((str.Length - (byteLength * 2)) == 1) {  	uneven = true;  	byteLength++;  }  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: while (byteOffset >= 0) {  	bytes [byteOffset--] = (byte)((HexVal (str [strOffset]) << 4) + (HexVal (str [strOffset + 1])));  	strOffset += 2;  }  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: while (byteOffset >= 0) {  	bytes [byteOffset--] = (byte)((HexVal (str [strOffset]) << 4) + (HexVal (str [strOffset + 1])));  	strOffset += 2;  }  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: bytes [byteOffset--] = (byte)((HexVal (str [strOffset]) << 4) + (HexVal (str [strOffset + 1])));  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: strOffset += 2;  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));  
Magic Number,Aerospike.Client,Util,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));  
Magic Number,Aerospike.Client,LuaAerospike,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level) {  case 1:  	Log.LogMessage (Log.Level.WARN' message);  	break;  case 2:  	Log.LogMessage (Log.Level.INFO' message);  	break;  case 3:  case 4:  	Log.LogMessage (Log.Level.DEBUG' message);  	break;  }  
Magic Number,Aerospike.Client,LuaAerospike,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level) {  case 1:  	Log.LogMessage (Log.Level.WARN' message);  	break;  case 2:  	Log.LogMessage (Log.Level.INFO' message);  	break;  case 3:  case 4:  	Log.LogMessage (Log.Level.DEBUG' message);  	break;  }  
Magic Number,Aerospike.Client,LuaAerospike,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level) {  case 1:  	Log.LogMessage (Log.Level.WARN' message);  	break;  case 2:  	Log.LogMessage (Log.Level.INFO' message);  	break;  case 3:  case 4:  	Log.LogMessage (Log.Level.DEBUG' message);  	break;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt16,The following statement contains a magic number: try {  	int capacity = offset + 2;  	EnsureCapacity (capacity);  	ByteUtil.ShortToBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt16,The following statement contains a magic number: try {  	int capacity = offset + 2;  	EnsureCapacity (capacity);  	ByteUtil.ShortToLittleBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt32,The following statement contains a magic number: try {  	int capacity = offset + 4;  	EnsureCapacity (capacity);  	ByteUtil.IntToBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt32,The following statement contains a magic number: try {  	int capacity = offset + 4;  	EnsureCapacity (capacity);  	ByteUtil.IntToLittleBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt64,The following statement contains a magic number: try {  	int capacity = offset + 8;  	EnsureCapacity (capacity);  	ByteUtil.LongToBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt64,The following statement contains a magic number: try {  	int capacity = offset + 8;  	EnsureCapacity (capacity);  	ByteUtil.LongToLittleBytes (value' bytes' offset);  	ResetSize (capacity);  	return true;  } catch (Exception) {  	return false;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetVarInt,The following statement contains a magic number: EnsureCapacity (offset + 5);  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetIntBig,The following statement contains a magic number: if (offset < 0 || offset + 4 > this.length) {  	return 0;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetIntLittle,The following statement contains a magic number: if (offset < 0 || offset + 4 > this.length) {  	return 0;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetLongBig,The following statement contains a magic number: if (offset < 0 || offset + 8 > this.length) {  	return 0;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetLongLittle,The following statement contains a magic number: if (offset < 0 || offset + 8 > this.length) {  	return 0;  }  
Magic Number,Aerospike.Client,LuaBytes,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,EnsureCapacity,The following statement contains a magic number: if (capacity > bytes.Length) {  	int len = bytes.Length * 2;  	if (capacity > len) {  		len = capacity;  	}  	byte[] target = new byte[len];  	Array.Copy (bytes' 0' target' 0' length);  	bytes = target;  }  
Magic Number,Aerospike.Client,LuaInstance,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,BytesToLua,The following statement contains a magic number: switch (type) {  case ParticleType.STRING:  	return ByteUtil.Utf8ToString (buf' offset' len);  case ParticleType.INTEGER:  	return ByteUtil.BytesToNumber (buf' offset' len);  case ParticleType.DOUBLE:  	return ByteUtil.BytesToDouble (buf' offset);  case ParticleType.BLOB:  	byte[] dest = new byte[len];  	Array.Copy (buf' offset' dest' 0' len);  	return new LuaBytes (dest);  case ParticleType.CSHARP_BLOB:  	return ByteUtil.BytesToObject (buf' offset' len);  case ParticleType.LIST: {  	Unpacker unpacker = new Unpacker (buf' offset' len' true);  	return unpacker.UnpackList ();  }  case ParticleType.MAP: {  	Unpacker unpacker = new Unpacker (buf' offset' len' true);  	return unpacker.UnpackMap ();  }  case ParticleType.GEOJSON: {  	// skip the flags  	int ncells = ByteUtil.BytesToShort (buf' offset + 1);  	int hdrsz = 1 + 2 + (ncells * 8);  	return new LuaGeoJSON (ByteUtil.Utf8ToString (buf' offset + hdrsz' len - hdrsz));  }  default:  	return null;  }  
Magic Number,Aerospike.Client,LuaInstance,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,BytesToLua,The following statement contains a magic number: switch (type) {  case ParticleType.STRING:  	return ByteUtil.Utf8ToString (buf' offset' len);  case ParticleType.INTEGER:  	return ByteUtil.BytesToNumber (buf' offset' len);  case ParticleType.DOUBLE:  	return ByteUtil.BytesToDouble (buf' offset);  case ParticleType.BLOB:  	byte[] dest = new byte[len];  	Array.Copy (buf' offset' dest' 0' len);  	return new LuaBytes (dest);  case ParticleType.CSHARP_BLOB:  	return ByteUtil.BytesToObject (buf' offset' len);  case ParticleType.LIST: {  	Unpacker unpacker = new Unpacker (buf' offset' len' true);  	return unpacker.UnpackList ();  }  case ParticleType.MAP: {  	Unpacker unpacker = new Unpacker (buf' offset' len' true);  	return unpacker.UnpackMap ();  }  case ParticleType.GEOJSON: {  	// skip the flags  	int ncells = ByteUtil.BytesToShort (buf' offset + 1);  	int hdrsz = 1 + 2 + (ncells * 8);  	return new LuaGeoJSON (ByteUtil.Utf8ToString (buf' offset + hdrsz' len - hdrsz));  }  default:  	return null;  }  
Magic Number,Aerospike.Client,LuaList,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaList.cs,LuaList,The following statement contains a magic number: list = new List<object> (32);  
Magic Number,Aerospike.Client,LuaMap,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaMap.cs,LuaMap,The following statement contains a magic number: map = new Dictionary<object' object> (32);  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [2] == '$')  	startingOffset = 3;  else {  	minor = salt [2];  	if (minor != 'a' || salt [3] != '$')  		throw new SaltParseException ("Invalid salt revision");  	startingOffset = 4;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [2] == '$')  	startingOffset = 3;  else {  	minor = salt [2];  	if (minor != 'a' || salt [3] != '$')  		throw new SaltParseException ("Invalid salt revision");  	startingOffset = 4;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [2] == '$')  	startingOffset = 3;  else {  	minor = salt [2];  	if (minor != 'a' || salt [3] != '$')  		throw new SaltParseException ("Invalid salt revision");  	startingOffset = 4;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [2] == '$')  	startingOffset = 3;  else {  	minor = salt [2];  	if (minor != 'a' || salt [3] != '$')  		throw new SaltParseException ("Invalid salt revision");  	startingOffset = 4;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [2] == '$')  	startingOffset = 3;  else {  	minor = salt [2];  	if (minor != 'a' || salt [3] != '$')  		throw new SaltParseException ("Invalid salt revision");  	startingOffset = 4;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: startingOffset = 3;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: minor = salt [2];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (minor != 'a' || salt [3] != '$')  	throw new SaltParseException ("Invalid salt revision");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: startingOffset = 4;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt [startingOffset + 2] > '$')  	throw new SaltParseException ("Missing salt rounds");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: result.Append (EncodeBase64 (hashed' (_BfCryptCiphertext.Length * 4) - 1));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The following statement contains a magic number: if (workFactor < 4 || workFactor > 31)  	throw new ArgumentOutOfRangeException ("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The following statement contains a magic number: if (workFactor < 4 || workFactor > 31)  	throw new ArgumentOutOfRangeException ("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length) {  	int c1 = byteArray [off++] & 0xff;  	rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  	c1 = (c1 & 0x03) << 4;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	int c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 4) & 0x0f;  	rs.Append (_Base64Code [c1 & 0x3f]);  	c1 = (c2 & 0x0f) << 2;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 6) & 0x03;  	rs.Append (_Base64Code [c1 & 0x3f]);  	rs.Append (_Base64Code [c2 & 0x3f]);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length) {  	int c1 = byteArray [off++] & 0xff;  	rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  	c1 = (c1 & 0x03) << 4;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	int c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 4) & 0x0f;  	rs.Append (_Base64Code [c1 & 0x3f]);  	c1 = (c2 & 0x0f) << 2;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 6) & 0x03;  	rs.Append (_Base64Code [c1 & 0x3f]);  	rs.Append (_Base64Code [c2 & 0x3f]);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length) {  	int c1 = byteArray [off++] & 0xff;  	rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  	c1 = (c1 & 0x03) << 4;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	int c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 4) & 0x0f;  	rs.Append (_Base64Code [c1 & 0x3f]);  	c1 = (c2 & 0x0f) << 2;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 6) & 0x03;  	rs.Append (_Base64Code [c1 & 0x3f]);  	rs.Append (_Base64Code [c2 & 0x3f]);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length) {  	int c1 = byteArray [off++] & 0xff;  	rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  	c1 = (c1 & 0x03) << 4;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	int c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 4) & 0x0f;  	rs.Append (_Base64Code [c1 & 0x3f]);  	c1 = (c2 & 0x0f) << 2;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 6) & 0x03;  	rs.Append (_Base64Code [c1 & 0x3f]);  	rs.Append (_Base64Code [c2 & 0x3f]);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length) {  	int c1 = byteArray [off++] & 0xff;  	rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  	c1 = (c1 & 0x03) << 4;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	int c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 4) & 0x0f;  	rs.Append (_Base64Code [c1 & 0x3f]);  	c1 = (c2 & 0x0f) << 2;  	if (off >= length) {  		rs.Append (_Base64Code [c1 & 0x3f]);  		break;  	}  	c2 = byteArray [off++] & 0xff;  	c1 |= (c2 >> 6) & 0x03;  	rs.Append (_Base64Code [c1 & 0x3f]);  	rs.Append (_Base64Code [c2 & 0x3f]);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: rs.Append (_Base64Code [(c1 >> 2) & 0x3f]);  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: c1 = (c1 & 0x03) << 4;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: c1 |= (c2 >> 4) & 0x0f;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: c1 = (c2 & 0x0f) << 2;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: c1 |= (c2 >> 6) & 0x03;  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes) {  	int c1 = Char64 (encodedstring [position++]);  	int c2 = Char64 (encodedstring [position++]);  	if (c1 == -1 || c2 == -1)  		break;  	rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c3 = Char64 (encodedstring [position++]);  	if (c3 == -1)  		break;  	rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c4 = Char64 (encodedstring [position++]);  	rs.Append ((char)(((c3 & 0x03) << 6) | c4));  	++outputLength;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes) {  	int c1 = Char64 (encodedstring [position++]);  	int c2 = Char64 (encodedstring [position++]);  	if (c1 == -1 || c2 == -1)  		break;  	rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c3 = Char64 (encodedstring [position++]);  	if (c3 == -1)  		break;  	rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c4 = Char64 (encodedstring [position++]);  	rs.Append ((char)(((c3 & 0x03) << 6) | c4));  	++outputLength;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes) {  	int c1 = Char64 (encodedstring [position++]);  	int c2 = Char64 (encodedstring [position++]);  	if (c1 == -1 || c2 == -1)  		break;  	rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c3 = Char64 (encodedstring [position++]);  	if (c3 == -1)  		break;  	rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c4 = Char64 (encodedstring [position++]);  	rs.Append ((char)(((c3 & 0x03) << 6) | c4));  	++outputLength;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes) {  	int c1 = Char64 (encodedstring [position++]);  	int c2 = Char64 (encodedstring [position++]);  	if (c1 == -1 || c2 == -1)  		break;  	rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c3 = Char64 (encodedstring [position++]);  	if (c3 == -1)  		break;  	rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c4 = Char64 (encodedstring [position++]);  	rs.Append ((char)(((c3 & 0x03) << 6) | c4));  	++outputLength;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes) {  	int c1 = Char64 (encodedstring [position++]);  	int c2 = Char64 (encodedstring [position++]);  	if (c1 == -1 || c2 == -1)  		break;  	rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c3 = Char64 (encodedstring [position++]);  	if (c3 == -1)  		break;  	rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  	if (++outputLength >= maximumBytes || position >= sourceLength)  		break;  	int c4 = Char64 (encodedstring [position++]);  	rs.Append ((char)(((c3 & 0x03) << 6) | c4));  	++outputLength;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: rs.Append ((char)((c1 << 2) | ((c2 & 0x30) >> 4)));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: rs.Append ((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: rs.Append ((char)(((c3 & 0x03) << 6) | c4));  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked {  	for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  		// Feistel substitution on left word  		n = _S [(block >> 24) & 0xff];  		n += _S [0x100 | ((block >> 16) & 0xff)];  		n ^= _S [0x200 | ((block >> 8) & 0xff)];  		n += _S [0x300 | (block & 0xff)];  		r ^= n ^ _P [++round];  		// Feistel substitution on right word  		n = _S [(r >> 24) & 0xff];  		n += _S [0x100 | ((r >> 16) & 0xff)];  		n ^= _S [0x200 | ((r >> 8) & 0xff)];  		n += _S [0x300 | (r & 0xff)];  		block ^= n ^ _P [++round];  	}  	blockArray [offset] = r ^ _P [BLOWFISH_NUM_ROUNDS + 1];  	blockArray [offset + 1] = block;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2;) {  	// Feistel substitution on left word  	n = _S [(block >> 24) & 0xff];  	n += _S [0x100 | ((block >> 16) & 0xff)];  	n ^= _S [0x200 | ((block >> 8) & 0xff)];  	n += _S [0x300 | (block & 0xff)];  	r ^= n ^ _P [++round];  	// Feistel substitution on right word  	n = _S [(r >> 24) & 0xff];  	n += _S [0x100 | ((r >> 16) & 0xff)];  	n ^= _S [0x200 | ((r >> 8) & 0xff)];  	n += _S [0x300 | (r & 0xff)];  	block ^= n ^ _P [++round];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n = _S [(block >> 24) & 0xff];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n += _S [0x100 | ((block >> 16) & 0xff)];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n ^= _S [0x200 | ((block >> 8) & 0xff)];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n = _S [(r >> 24) & 0xff];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n += _S [0x100 | ((r >> 16) & 0xff)];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: n ^= _S [0x200 | ((r >> 8) & 0xff)];  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	word = (word << 8) | (uint)(data [offset] & 0xff);  	offset = (offset + 1) % data.Length;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	word = (word << 8) | (uint)(data [offset] & 0xff);  	offset = (offset + 1) % data.Length;  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,StreamToWord,The following statement contains a magic number: word = (word << 8) | (uint)(data [offset] & 0xff);  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: for (i = 0; i < plen; i += 2) {  	Encipher (lr' 0);  	_P [i] = lr [0];  	_P [i + 1] = lr [1];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: i += 2
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: for (i = 0; i < slen; i += 2) {  	Encipher (lr' 0);  	_S [i] = lr [0];  	_S [i + 1] = lr [1];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: i += 2
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: for (i = 0; i < plen; i += 2) {  	lr [0] ^= StreamToWord (saltBytes' ref saltOffset);  	lr [1] ^= StreamToWord (saltBytes' ref saltOffset);  	Encipher (lr' 0);  	_P [i] = lr [0];  	_P [i + 1] = lr [1];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: i += 2
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: for (i = 0; i < slen; i += 2) {  	lr [0] ^= StreamToWord (saltBytes' ref saltOffset);  	lr [1] ^= StreamToWord (saltBytes' ref saltOffset);  	Encipher (lr' 0);  	_S [i] = lr [0];  	_S [i + 1] = lr [1];  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: i += 2
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)  	throw new ArgumentException ("Bad number of rounds"' "logRounds");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)  	throw new ArgumentException ("Bad number of rounds"' "logRounds");  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0; i < 64; i++) {  	for (int j = 0; j < (clen >> 1); j++)  		Encipher (cdata' j << 1);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++) {  	ret [j++] = (byte)((cdata [i] >> 24) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 16) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 8) & 0xff);  	ret [j++] = (byte)(cdata [i] & 0xff);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++) {  	ret [j++] = (byte)((cdata [i] >> 24) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 16) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 8) & 0xff);  	ret [j++] = (byte)(cdata [i] & 0xff);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++) {  	ret [j++] = (byte)((cdata [i] >> 24) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 16) & 0xff);  	ret [j++] = (byte)((cdata [i] >> 8) & 0xff);  	ret [j++] = (byte)(cdata [i] & 0xff);  }  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: ret [j++] = (byte)((cdata [i] >> 24) & 0xff);  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: ret [j++] = (byte)((cdata [i] >> 16) & 0xff);  
Magic Number,BCrypt.Net,BCrypt,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: ret [j++] = (byte)((cdata [i] >> 8) & 0xff);  
Missing Default,Aerospike.Client,AsyncMultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,The following switch statement is missing a default case: switch (fieldtype) {  case FieldType.DIGEST_RIPE:  	digest = new byte[size];  	Array.Copy (dataBuffer' dataOffset' digest' 0' size);  	dataOffset += size;  	break;  case FieldType.NAMESPACE:  	ns = ByteUtil.Utf8ToString (dataBuffer' dataOffset' size);  	dataOffset += size;  	break;  case FieldType.TABLE:  	setName = ByteUtil.Utf8ToString (dataBuffer' dataOffset' size);  	dataOffset += size;  	break;  case FieldType.KEY:  	int type = dataBuffer [dataOffset++];  	size--;  	userKey = ByteUtil.BytesToKeyValue (type' dataBuffer' dataOffset' size);  	dataOffset += size;  	break;  }  
Missing Default,Aerospike.Client,MapPolicy,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\CDT\MapPolicy.cs,MapPolicy,The following switch statement is missing a default case: switch (writeMode) {  case MapWriteMode.UPDATE:  	itemCommand = MapBase.PUT;  	itemsCommand = MapBase.PUT_ITEMS;  	break;  case MapWriteMode.UPDATE_ONLY:  	itemCommand = MapBase.REPLACE;  	itemsCommand = MapBase.REPLACE_ITEMS;  	break;  case MapWriteMode.CREATE_ONLY:  	itemCommand = MapBase.ADD;  	itemsCommand = MapBase.ADD_ITEMS;  	break;  }  
Missing Default,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following switch statement is missing a default case: switch (policy.recordExistsAction) {  case RecordExistsAction.UPDATE:  	break;  case RecordExistsAction.UPDATE_ONLY:  	infoAttr |= Command.INFO3_UPDATE_ONLY;  	break;  case RecordExistsAction.REPLACE:  	infoAttr |= Command.INFO3_CREATE_OR_REPLACE;  	break;  case RecordExistsAction.REPLACE_ONLY:  	infoAttr |= Command.INFO3_REPLACE_ONLY;  	break;  case RecordExistsAction.CREATE_ONLY:  	writeAttr |= Command.INFO2_CREATE_ONLY;  	break;  }  
Missing Default,Aerospike.Client,Command,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following switch statement is missing a default case: switch (policy.generationPolicy) {  case GenerationPolicy.NONE:  	break;  case GenerationPolicy.EXPECT_GEN_EQUAL:  	generation = policy.generation;  	writeAttr |= Command.INFO2_GENERATION;  	break;  case GenerationPolicy.EXPECT_GEN_GT:  	generation = policy.generation;  	writeAttr |= Command.INFO2_GENERATION_GT;  	break;  }  
Missing Default,Aerospike.Client,MultiCommand,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\..\..\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following switch statement is missing a default case: switch (fieldtype) {  case FieldType.DIGEST_RIPE:  	digest = new byte[size];  	Array.Copy (dataBuffer' 1' digest' 0' size);  	break;  case FieldType.NAMESPACE:  	ns = ByteUtil.Utf8ToString (dataBuffer' 1' size);  	break;  case FieldType.TABLE:  	setName = ByteUtil.Utf8ToString (dataBuffer' 1' size);  	break;  case FieldType.KEY:  	userKey = ByteUtil.BytesToKeyValue (dataBuffer [1]' dataBuffer' 2' size - 1);  	break;  }  
Missing Default,Aerospike.Client,LuaAerospike,F:\newReposMay17\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following switch statement is missing a default case: switch (level) {  case 1:  	Log.LogMessage (Log.Level.WARN' message);  	break;  case 2:  	Log.LogMessage (Log.Level.INFO' message);  	break;  case 3:  case 4:  	Log.LogMessage (Log.Level.DEBUG' message);  	break;  }  
