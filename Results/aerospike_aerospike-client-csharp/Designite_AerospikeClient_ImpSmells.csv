Implementation smell,Namespace,Class,File,Method,Description
Long Method,Aerospike.Client,Node,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Node.cs,GetConnection,The method has 100 lines of code.
Long Method,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The method has 115 lines of code.
Long Method,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The method has 179 lines of code.
Long Method,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The method has 144 lines of code.
Long Method,Aerospike.Client,ResultCode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\ResultCode.cs,GetResultString,The method has 143 lines of code.
Long Method,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The method has 192 lines of code.
Complex Method,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,InitTendThread,Cyclomatic complexity of the method is 10
Complex Method,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,Tend,Cyclomatic complexity of the method is 12
Complex Method,Aerospike.Client,Node,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Node.cs,RefreshPeers,Cyclomatic complexity of the method is 11
Complex Method,Aerospike.Client,NodeValidator,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\NodeValidator.cs,ValidateAlias,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,Cyclomatic complexity of the method is 14
Complex Method,Aerospike.Client,TlsConnection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\TlsConnection.cs,ValidateServerCertificate,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,Cyclomatic complexity of the method is 11
Complex Method,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,Cyclomatic complexity of the method is 27
Complex Method,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,Aerospike.Client,ValueArray,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,ListValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,MapValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackObject,Cyclomatic complexity of the method is 11
Complex Method,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,Cyclomatic complexity of the method is 8
Long Parameter List,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,CreateUser,The method has 5 parameters. Parameters: cluster' policy' user' password' roles
Long Parameter List,Aerospike.Client,AsyncBatchReadListCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchReadListCommand,The method has 5 parameters. Parameters: parent' cluster' batch' batchPolicy' records
Long Parameter List,Aerospike.Client,AsyncBatchReadSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchReadSequenceCommand,The method has 6 parameters. Parameters: parent' cluster' batch' batchPolicy' listener' records
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayExecutor,The method has 6 parameters. Parameters: cluster' policy' listener' keys' binNames' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayCommand,The method has 8 parameters. Parameters: parent' cluster' batch' batchPolicy' keys' binNames' records' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchGetArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetArrayDirect,The method has 9 parameters. Parameters: parent' cluster' node' batch' policy' keys' binNames' records' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceExecutor,The method has 6 parameters. Parameters: cluster' policy' listener' keys' binNames' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceCommand,The method has 8 parameters. Parameters: parent' cluster' batch' batchPolicy' keys' binNames' listener' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchGetSequenceDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchGetSequenceDirect,The method has 9 parameters. Parameters: parent' cluster' node' batch' policy' keys' binNames' listener' readAttr
Long Parameter List,Aerospike.Client,AsyncBatchExistsArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsArrayCommand,The method has 6 parameters. Parameters: parent' cluster' batch' batchPolicy' keys' existsArray
Long Parameter List,Aerospike.Client,AsyncBatchExistsArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsArrayDirect,The method has 7 parameters. Parameters: parent' cluster' node' batch' policy' keys' existsArray
Long Parameter List,Aerospike.Client,AsyncBatchExistsSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsSequenceCommand,The method has 6 parameters. Parameters: parent' cluster' batch' batchPolicy' keys' listener
Long Parameter List,Aerospike.Client,AsyncBatchExistsSequenceDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,AsyncBatchExistsSequenceDirect,The method has 7 parameters. Parameters: parent' cluster' node' batch' policy' keys' listener
Long Parameter List,Aerospike.Client,AsyncClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncClient.cs,ScanAll,The method has 5 parameters. Parameters: policy' listener' ns' setName' binNames
Long Parameter List,Aerospike.Client,AsyncClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncClient.cs,Execute,The method has 6 parameters. Parameters: policy' token' key' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,AsyncClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncClient.cs,Execute,The method has 6 parameters. Parameters: policy' listener' key' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,AsyncCommand,The method has 5 parameters. Parameters: cluster' policy' partition' node' isRead
Long Parameter List,Aerospike.Client,AsyncExecute,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncExecute.cs,AsyncExecute,The method has 7 parameters. Parameters: cluster' writePolicy' listener' key' packageName' functionName' args
Long Parameter List,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,AsyncMultiCommand,The method has 5 parameters. Parameters: parent' cluster' policy' node' stopOnNotFound
Long Parameter List,Aerospike.Client,AsyncQuery,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncQuery.cs,AsyncQuery,The method has 6 parameters. Parameters: parent' cluster' node' queryPolicy' listener' statement
Long Parameter List,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,AsyncRead,The method has 6 parameters. Parameters: cluster' policy' listener' key' binNames' isRead
Long Parameter List,Aerospike.Client,AsyncScan,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncScan.cs,AsyncScan,The method has 9 parameters. Parameters: parent' cluster' node' scanPolicy' listener' ns' setName' binNames' taskId
Long Parameter List,Aerospike.Client,AsyncScanExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncScanExecutor.cs,AsyncScanExecutor,The method has 6 parameters. Parameters: cluster' policy' listener' ns' setName' binNames
Long Parameter List,Aerospike.Client,AsyncWrite,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncWrite.cs,AsyncWrite,The method has 6 parameters. Parameters: cluster' writePolicy' listener' key' bins' operation
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The method has 5 parameters. Parameters: command' attributes' binName' value1' value2
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters. Parameters: command' attributes' binName' value1' value2
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters. Parameters: command' type' binName' list' returnType
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters. Parameters: command' type' binName' value' returnType
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 5 parameters. Parameters: command' type' binName' index' returnType
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The method has 6 parameters. Parameters: command' type' binName' index' count' returnType
Long Parameter List,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The method has 6 parameters. Parameters: command' type' binName' begin' end' returnType
Long Parameter List,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,PartitionParser,The method has 5 parameters. Parameters: conn' node' map' partitionCount' requestProleReplicas
Long Parameter List,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The method has 5 parameters. Parameters: node' partitions' index' regime' begin
Long Parameter List,Aerospike.Client,TlsConnection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\TlsConnection.cs,TlsConnection,The method has 6 parameters. Parameters: policy' tlsName' address' timeoutMillis' maxSocketIdleMillis' pool
Long Parameter List,Aerospike.Client,BatchGetArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,BatchGetArrayCommand,The method has 6 parameters. Parameters: batch' policy' keys' binNames' records' readAttr
Long Parameter List,Aerospike.Client,BatchGetArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,BatchGetArrayDirect,The method has 6 parameters. Parameters: batch' policy' keys' binNames' records' readAttr
Long Parameter List,Aerospike.Client,BatchExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,The method has 7 parameters. Parameters: cluster' policy' keys' existsArray' records' binNames' readAttr
Long Parameter List,Aerospike.Client,BatchExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchExecutor.cs,ExecuteNode,The method has 8 parameters. Parameters: cluster' batchNode' policy' keys' existsArray' records' binNames' readAttr
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetUdf,The method has 5 parameters. Parameters: policy' key' packageName' functionName' args
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The method has 5 parameters. Parameters: policy' keys' batch' binNames' readAttr
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchReadDirect,The method has 5 parameters. Parameters: policy' keys' batch' binNames' readAttr
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The method has 5 parameters. Parameters: policy' ns' setName' binNames' taskId
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The method has 5 parameters. Parameters: policy' readAttr' writeAttr' fieldCount' operationCount
Long Parameter List,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The method has 5 parameters. Parameters: policy' readAttr' writeAttr' fieldCount' operationCount
Long Parameter List,Aerospike.Client,ExecuteCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ExecuteCommand.cs,ExecuteCommand,The method has 5 parameters. Parameters: writePolicy' key' packageName' functionName' args
Long Parameter List,Aerospike.Client,RegisterCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\RegisterCommand.cs,Register,The method has 5 parameters. Parameters: cluster' policy' content' serverPath' language
Long Parameter List,Aerospike.Client,ScanCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ScanCommand.cs,ScanCommand,The method has 6 parameters. Parameters: policy' ns' setName' callback' binNames' taskId
Long Parameter List,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The method has 5 parameters. Parameters: cluster' policy' key' node' isRead
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ScanAll,The method has 5 parameters. Parameters: policy' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The method has 6 parameters. Parameters: policy' nodeName' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The method has 6 parameters. Parameters: policy' node' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Register,The method has 5 parameters. Parameters: policy' resourceAssembly' resourcePath' serverPath' language
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Execute,The method has 5 parameters. Parameters: policy' key' packageName' functionName' args
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Execute,The method has 5 parameters. Parameters: policy' statement' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,QueryAggregate,The method has 5 parameters. Parameters: policy' statement' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,CreateIndex,The method has 6 parameters. Parameters: policy' ns' setName' indexName' binName' indexType
Long Parameter List,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,CreateIndex,The method has 7 parameters. Parameters: policy' ns' setName' indexName' binName' indexType' indexCollectionType
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanAll,The method has 5 parameters. Parameters: policy' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanNode,The method has 6 parameters. Parameters: policy' nodeName' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,ScanNode,The method has 6 parameters. Parameters: policy' node' ns' setName' callback' binNames
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,Register,The method has 5 parameters. Parameters: policy' resourceAssembly' resourcePath' serverPath' language
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,Execute,The method has 5 parameters. Parameters: policy' key' packageName' functionName' args
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,Execute,The method has 5 parameters. Parameters: policy' statement' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,QueryAggregate,The method has 5 parameters. Parameters: policy' statement' packageName' functionName' functionArgs
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,CreateIndex,The method has 6 parameters. Parameters: policy' ns' setName' indexName' binName' indexType
Long Parameter List,Aerospike.Client,IAerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\IAerospikeClient.cs,CreateIndex,The method has 7 parameters. Parameters: policy' ns' setName' indexName' binName' indexType' indexCollectionType
Long Parameter List,Aerospike.Client,Key,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Key.cs,Key,The method has 5 parameters. Parameters: ns' setName' key' offset' length
Long Parameter List,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The method has 5 parameters. Parameters: name' type' lng' lat' radius
Long Parameter List,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,Filter,The method has 5 parameters. Parameters: name' colType' valType' begin' end
Long Parameter List,Aerospike.Client,Statement,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Statement.cs,SetAggregateFunction,The method has 5 parameters. Parameters: resourceAssembly' resourcePath' packageName' functionName' functionArgs
Long Statement,Aerospike.Client,AsyncBatchReadListCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchReadSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchGetArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchGetArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,AsyncBatchGetSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchGetSequenceDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,AsyncBatchExistsArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchExistsArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,AsyncBatchExistsSequenceCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,AsyncBatchExistsSequenceDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncBatch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,AsyncCommandDelayingQueue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommandDelayingQueue.cs,ScheduleCommand,The length of the statement  "				if (_commandQueue.IsEmpty) // NB: We could make the choice to always execute the command synchronously in this case. Might be better for performance. " is 149.
Long Statement,Aerospike.Client,AsyncCommandDelayingQueue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommandDelayingQueue.cs,ExclusiveScheduleCommands,The length of the statement  "					Monitor.TryEnter(_commandQueue' ref lockTaken); // If we can't enter the lock' it means another instance of the job is already doing the work. " is 142.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByKeyRange,The length of the statement  "			return MapBase.CreateRangeOperation(MapBase.REMOVE_BY_KEY_INTERVAL' Operation.Type.MAP_MODIFY' binName' keyBegin' keyEnd' returnType); " is 134.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByValueRange,The length of the statement  "			return MapBase.CreateRangeOperation(MapBase.REMOVE_BY_VALUE_INTERVAL' Operation.Type.MAP_MODIFY' binName' valueBegin' valueEnd' returnType); " is 140.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByIndexRange,The length of the statement  "			return MapBase.CreateOperation(MapBase.REMOVE_BY_INDEX_RANGE' Operation.Type.MAP_MODIFY' binName' index' count' returnType); " is 124.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,RemoveByRankRange,The length of the statement  "			return MapBase.CreateOperation(MapBase.REMOVE_BY_RANK_RANGE' Operation.Type.MAP_MODIFY' binName' rank' count' returnType); " is 122.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,GetByKeyRange,The length of the statement  "			return MapBase.CreateRangeOperation(MapBase.GET_BY_KEY_INTERVAL' Operation.Type.MAP_READ' binName' keyBegin' keyEnd' returnType); " is 129.
Long Statement,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,GetByValueRange,The length of the statement  "			return MapBase.CreateRangeOperation(MapBase.GET_BY_VALUE_INTERVAL' Operation.Type.MAP_READ' binName' valueBegin' valueEnd' returnType); " is 135.
Long Statement,Aerospike.Client,Connection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Connection.cs,GetHostAddresses,The length of the statement  "				// See: https://social.msdn.microsoft.com/Forums/en-US/313cf28c-2a6d-498e-8188-7a0639dbd552/tcpclientbeginconnect-issue?forum=netfxnetcom " is 137.
Long Statement,Aerospike.Client,Node,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Node.cs,RefreshPartitions,The length of the statement  "				PartitionParser parser = new PartitionParser(tendConnection' this' cluster.partitionMap' Node.PARTITIONS' cluster.requestProleReplicas); " is 136.
Long Statement,Aerospike.Client,NodeValidator,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\NodeValidator.cs,ValidateAlias,The length of the statement  "						throw new AerospikeException.InvalidNode("Node " + nodeName + ' ' + alias + ' ' + " expected cluster name '" + cluster.clusterName + "' received '" + id + "'"); " is 160.
Long Statement,Aerospike.Client,BatchReadListCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,BatchGetArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,BatchGetArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,BatchExistsArrayCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + batchIndex); " is 144.
Long Statement,Aerospike.Client,BatchExistsArrayDirect,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Batch.cs,ParseRow,The length of the statement  "				throw new AerospikeException.Parse("Unexpected batch key returned: " + key.ns + ''' + ByteUtil.BytesToHexString(key.digest) + ''' + index + ''' + offset); " is 154.
Long Statement,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The length of the statement  "			WriteFieldHeader(0' policy.sendSetName ? FieldType.BATCH_INDEX_WITH_SET : FieldType.BATCH_INDEX); // Need to update size at end " is 127.
Long Statement,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The length of the statement  "			WriteFieldHeader(0' policy.sendSetName ? FieldType.BATCH_INDEX_WITH_SET : FieldType.BATCH_INDEX); // Need to update size at end " is 127.
Long Statement,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Get,The length of the statement  "						throw new AerospikeException(ResultCode.PARAMETER_ERROR' "Requested command requires a server that supports new batch index protocol."); " is 136.
Long Statement,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Get,The length of the statement  "						throw new AerospikeException(ResultCode.PARAMETER_ERROR' "Requested command requires a server that supports new batch index protocol."); " is 136.
Long Statement,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The length of the statement  "			string rgnstr = string.Format("{{ \"type\": \"AeroCircle\"' " + "\"coordinates\": [[{0:F8}' {1:F8}]' {2:F}] }}"' lng' lat' radius); " is 131.
Long Statement,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,GeoWithinRadius,The length of the statement  "			string rgnstr = string.Format("{{ \"type\": \"AeroCircle\"' " + "\"coordinates\": [[{0:F8}' {1:F8}]' {2:F}] }}"' lng' lat' radius); " is 131.
Long Statement,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The length of the statement  "                throw new ArgumentOutOfRangeException("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)"); " is 120.
Complex Conditional,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The conditional expression  "!(privilege.setName == null || privilege.setName.Length == 0) &&  						(privilege.ns == null || privilege.ns.Length == 0)"  is complex.
Complex Conditional,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WritePrivileges,The conditional expression  "! (privilege.ns == null || privilege.ns.Length == 0) ||  						! (privilege.setName == null || privilege.setName.Length == 0)"  is complex.
Complex Conditional,Aerospike.Client,Node,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Node.cs,RefreshPartitions,The conditional expression  "failures > 0 || ! active || (peersCount == 0 && peers.refreshCount > 1)"  is complex.
Complex Conditional,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.key.ns == key.ns &&  					(! policy.sendSetName || prev.key.setName == key.setName) &&  					prev.binNames == binNames && prev.readAllBins == record.readAllBins"  is complex.
Complex Conditional,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.key.ns == key.ns &&  					(!policy.sendSetName || prev.key.setName == key.setName) &&  					prev.binNames == binNames && prev.readAllBins == record.readAllBins"  is complex.
Complex Conditional,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.ns == key.ns && (! policy.sendSetName || prev.setName == key.setName)"  is complex.
Complex Conditional,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The conditional expression  "prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName)"  is complex.
Virtual Method Call from Constructor,Aerospike.Client,AsyncCluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCluster.cs,AsyncCluster,The constructor "AsyncCluster" calls a virtual method "ReleaseArgs".
Virtual Method Call from Constructor,Aerospike.Client,AsyncCluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCluster.cs,AsyncCluster,The constructor "AsyncCluster" calls a virtual method "InitTendThread".
Virtual Method Call from Constructor,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,AerospikeClient,The constructor "AerospikeClient" calls a virtual method "InitTendThread".
Virtual Method Call from Constructor,Aerospike.Client,Key,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Key.cs,Key,The constructor "Key" calls a virtual method "ValidateKeyType".
Empty Catch Block,Aerospike.Client,AsyncConnection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,Connection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Connection.cs,Close,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,NodeValidator,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\NodeValidator.cs,SetFeatures,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ParseInfoError,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,QueryAggregateCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The method has an empty catch block.
Empty Catch Block,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,Sleep,The method has an empty catch block.
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: dataBuffer = new byte[8096];
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: dataOffset = 8;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,AdminCommand,The following statement contains a magic number: this.dataOffset = dataOffset + 8;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,SetAuthenticate,The following statement contains a magic number: WriteHeader(AUTHENTICATE' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,CreateUser,The following statement contains a magic number: WriteHeader(CREATE_USER' 3);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,SetPassword,The following statement contains a magic number: WriteHeader(SET_PASSWORD' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ChangePassword,The following statement contains a magic number: WriteHeader(CHANGE_PASSWORD' 3);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,GrantRoles,The following statement contains a magic number: WriteHeader(GRANT_ROLES' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,RevokeRoles,The following statement contains a magic number: WriteHeader(REVOKE_ROLES' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,CreateRole,The following statement contains a magic number: WriteHeader(CREATE_ROLE' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,GrantPrivileges,The following statement contains a magic number: WriteHeader(GRANT_PRIVILEGES' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,RevokePrivileges,The following statement contains a magic number: WriteHeader(REVOKE_PRIVILEGES' 2);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteSize,The following statement contains a magic number: ulong size = (ulong)(dataOffset - dataBegin - 8) | (MSG_VERSION << 56) | (MSG_TYPE << 48);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteSize,The following statement contains a magic number: ulong size = (ulong)(dataOffset - dataBegin - 8) | (MSG_VERSION << 56) | (MSG_TYPE << 48);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteSize,The following statement contains a magic number: ulong size = (ulong)(dataOffset - dataBegin - 8) | (MSG_VERSION << 56) | (MSG_TYPE << 48);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: Array.Clear(dataBuffer' dataOffset' 16);
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataBuffer[dataOffset + 2] = command;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataBuffer[dataOffset + 3] = fieldCount;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteHeader,The following statement contains a magic number: dataOffset += 16;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,WriteFieldHeader,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ExecuteCommand,The following statement contains a magic number: int timeout = (policy == null) ? 1000 : policy.timeout;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ExecuteQuery,The following statement contains a magic number: int timeout = (policy == null) ? 1000 : policy.timeout;
Magic Number,Aerospike.Client,AdminCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ReadBlocks,The following statement contains a magic number: while (status == 0)  			{  				conn.ReadFully(dataBuffer' 8);  				long size = ByteUtil.BytesToLong(dataBuffer' 0);  				int receiveSize = ((int)(size & 0xFFFFFFFFFFFFL));    				if (receiveSize > 0)  				{  					if (receiveSize > dataBuffer.Length)  					{  						dataBuffer = ThreadLocalData.ResizeBuffer(receiveSize);  					}  					conn.ReadFully(dataBuffer' receiveSize);  					status = ParseBlock(receiveSize);  				}  			}
Magic Number,Aerospike.Client,UserCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ParseBlock,The following statement contains a magic number: while (base.dataOffset < receiveSize)  				{  					int resultCode = base.dataBuffer[base.dataOffset + 1];    					if (resultCode != 0)  					{  						return resultCode;  					}    					User user = new User();  					int fieldCount = base.dataBuffer[base.dataOffset + 3];  					base.dataOffset += HEADER_REMAINING;    					for (int i = 0; i < fieldCount; i++)  					{  						int len = ByteUtil.BytesToInt(base.dataBuffer' base.dataOffset);  						base.dataOffset += 4;  						int id = base.dataBuffer[base.dataOffset++];  						len--;    						if (id == USER)  						{  							user.name = ByteUtil.Utf8ToString(base.dataBuffer' base.dataOffset' len);  							base.dataOffset += len;  						}  						else if (id == ROLES)  						{  							ParseRoles(user);  						}  						else  						{  							base.dataOffset += len;  						}  					}    					if (user.name == null && user.roles == null)  					{  						continue;  					}    					if (user.roles == null)  					{  						user.roles = new List<string>(0);  					}  					list.Add(user);  				}
Magic Number,Aerospike.Client,UserCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ParseBlock,The following statement contains a magic number: while (base.dataOffset < receiveSize)  				{  					int resultCode = base.dataBuffer[base.dataOffset + 1];    					if (resultCode != 0)  					{  						return resultCode;  					}    					User user = new User();  					int fieldCount = base.dataBuffer[base.dataOffset + 3];  					base.dataOffset += HEADER_REMAINING;    					for (int i = 0; i < fieldCount; i++)  					{  						int len = ByteUtil.BytesToInt(base.dataBuffer' base.dataOffset);  						base.dataOffset += 4;  						int id = base.dataBuffer[base.dataOffset++];  						len--;    						if (id == USER)  						{  							user.name = ByteUtil.Utf8ToString(base.dataBuffer' base.dataOffset' len);  							base.dataOffset += len;  						}  						else if (id == ROLES)  						{  							ParseRoles(user);  						}  						else  						{  							base.dataOffset += len;  						}  					}    					if (user.name == null && user.roles == null)  					{  						continue;  					}    					if (user.roles == null)  					{  						user.roles = new List<string>(0);  					}  					list.Add(user);  				}
Magic Number,Aerospike.Client,RoleCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ParseBlock,The following statement contains a magic number: while (base.dataOffset < receiveSize)  				{  					int resultCode = base.dataBuffer[base.dataOffset + 1];    					if (resultCode != 0)  					{  						return resultCode;  					}    					Role role = new Role();  					int fieldCount = base.dataBuffer[base.dataOffset + 3];  					base.dataOffset += HEADER_REMAINING;    					for (int i = 0; i < fieldCount; i++)  					{  						int len = ByteUtil.BytesToInt(base.dataBuffer' base.dataOffset);  						base.dataOffset += 4;  						int id = base.dataBuffer[base.dataOffset++];  						len--;    						if (id == ROLE)  						{  							role.name = ByteUtil.Utf8ToString(base.dataBuffer' base.dataOffset' len);  							base.dataOffset += len;  						}  						else if (id == PRIVILEGES)  						{  							ParsePrivileges(role);  						}  						else  						{  							base.dataOffset += len;  						}  					}    					if (role.name == null && role.privileges == null)  					{  						continue;  					}    					if (role.privileges == null)  					{  						role.privileges = new List<Privilege>(0);  					}  					list.Add(role);  				}
Magic Number,Aerospike.Client,RoleCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\AdminCommand.cs,ParseBlock,The following statement contains a magic number: while (base.dataOffset < receiveSize)  				{  					int resultCode = base.dataBuffer[base.dataOffset + 1];    					if (resultCode != 0)  					{  						return resultCode;  					}    					Role role = new Role();  					int fieldCount = base.dataBuffer[base.dataOffset + 3];  					base.dataOffset += HEADER_REMAINING;    					for (int i = 0; i < fieldCount; i++)  					{  						int len = ByteUtil.BytesToInt(base.dataBuffer' base.dataOffset);  						base.dataOffset += 4;  						int id = base.dataBuffer[base.dataOffset++];  						len--;    						if (id == ROLE)  						{  							role.name = ByteUtil.Utf8ToString(base.dataBuffer' base.dataOffset' len);  							base.dataOffset += len;  						}  						else if (id == PRIVILEGES)  						{  							ParsePrivileges(role);  						}  						else  						{  							base.dataOffset += len;  						}  					}    					if (role.name == null && role.privileges == null)  					{  						continue;  					}    					if (role.privileges == null)  					{  						role.privileges = new List<Privilege>(0);  					}  					list.Add(role);  				}
Magic Number,Aerospike.Client,Privilege,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Admin\Privilege.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,ConnectionCreated,The following statement contains a magic number: if (cluster.user != null)  			{  				inAuthenticate = true;  				// Authentication messages are small.  Set a reasonable upper bound.  				dataOffset = 200;  				SizeBuffer();    				AdminCommand command = new AdminCommand(dataBuffer' dataOffset);  				dataLength = command.SetAuthenticate(cluster.user' cluster.password);  				eventArgs.SetBuffer(dataBuffer' dataOffset' dataLength - dataOffset);  				Send();  				return;  			}
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)length - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)length - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)length - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,ReceiveBegin,The following statement contains a magic number: dataLength = dataOffset + 8;
Magic Number,Aerospike.Client,AsyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncCommand.cs,ReceiveBegin,The following statement contains a magic number: eventArgs.SetBuffer(dataOffset' 8);
Magic Number,Aerospike.Client,AsyncDelete,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncDelete.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,AsyncExists,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncExists.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < dataLength)  			{  				resultCode = dataBuffer[dataOffset + 5];    				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return true;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				// If this is the end marker of the response' do not proceed further  				if ((dataBuffer[dataOffset + 3] & Command.INFO3_LAST) != 0)  				{  					return true;  				}  				generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' dataOffset + 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);    				dataOffset += Command.MSG_REMAINING_HEADER_SIZE;    				if (!valid)  				{  					throw new AerospikeException.QueryTerminated();  				}    				Key key = ParseKey();  				ParseRow(key);  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++)  			{  				int fieldlen = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				dataOffset += 4;    				int fieldtype = dataBuffer[dataOffset++];  				int size = fieldlen - 1;    				switch (fieldtype)  				{  					case FieldType.DIGEST_RIPE:  						digest = new byte[size];  						Array.Copy(dataBuffer' dataOffset' digest' 0' size);  						dataOffset += size;  						break;    					case FieldType.NAMESPACE:  						ns = ByteUtil.Utf8ToString(dataBuffer' dataOffset' size);  						dataOffset += size;  						break;    					case FieldType.TABLE:  						setName = ByteUtil.Utf8ToString(dataBuffer' dataOffset' size);  						dataOffset += size;  						break;    					case FieldType.KEY:  						int type = dataBuffer[dataOffset++];  						size--;  						userKey = ByteUtil.BytesToKeyValue(type' dataBuffer' dataOffset' size);  						dataOffset += size;  						break;  				}   			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseResult,The following statement contains a magic number: int generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseResult,The following statement contains a magic number: int expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseResult,The following statement contains a magic number: int fieldCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 18);
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseResult,The following statement contains a magic number: int opCount = ByteUtil.BytesToShort(dataBuffer' dataOffset + 20);
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: if (fieldCount > 0)  			{  				// Just skip over all the fields  				for (int i = 0; i < fieldCount; i++)  				{  					int fieldSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  					dataOffset += 4 + fieldSize;  				}  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncRead,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncRead.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' dataOffset);  				byte particleType = dataBuffer[dataOffset + 5];  				byte nameSize = dataBuffer[dataOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' dataOffset + 8' nameSize);  				dataOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' dataOffset' particleBytesSize);  				dataOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,AsyncReadHeader,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncReadHeader.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,AsyncReadHeader,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncReadHeader.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0)  			{  				int generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				int expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);    				record = new Record(null' generation' expiration);  			}  			else  			{  				if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  				{  					record = null;  				}  				else  				{  					throw new AerospikeException(resultCode);  				}  			}
Magic Number,Aerospike.Client,AsyncReadHeader,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncReadHeader.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0)  			{  				int generation = ByteUtil.BytesToInt(dataBuffer' dataOffset + 6);  				int expiration = ByteUtil.BytesToInt(dataBuffer' dataOffset + 10);    				record = new Record(null' generation' expiration);  			}  			else  			{  				if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  				{  					record = null;  				}  				else  				{  					throw new AerospikeException(resultCode);  				}  			}
Magic Number,Aerospike.Client,AsyncTouch,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncTouch.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,AsyncWrite,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncWrite.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[dataOffset + 5];
Magic Number,Aerospike.Client,BufferPool,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\BufferPool.cs,BufferPool,The following statement contains a magic number: int rem = size % 8192;
Magic Number,Aerospike.Client,BufferPool,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\BufferPool.cs,BufferPool,The following statement contains a magic number: if (rem > 0)  			{  				size += 8192 - rem;  			}
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,Insert,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,InsertItems,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,PopRange,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,RemoveRange,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,Set,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,Trim,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,Increment,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,ListOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\ListOperation.cs,GetRange,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: if (command == MapBase.REPLACE)  			{  				// Replace doesn't allow map attributes because it does not create on non-existing key.  				packer.PackArrayBegin(2);  				value1.Pack(packer);  				value2.Pack(packer);  			}  			else  			{  				packer.PackArrayBegin(3);  				value1.Pack(packer);  				value2.Pack(packer);  				packer.PackNumber(attributes);  			}
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreatePut,The following statement contains a magic number: if (command == MapBase.REPLACE)  			{  				// Replace doesn't allow map attributes because it does not create on non-existing key.  				packer.PackArrayBegin(2);  				value1.Pack(packer);  				value2.Pack(packer);  			}  			else  			{  				packer.PackArrayBegin(3);  				value1.Pack(packer);  				value2.Pack(packer);  				packer.PackNumber(attributes);  			}
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin(3);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin(2);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateOperation,The following statement contains a magic number: packer.PackArrayBegin(3);
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: if (end == null)  			{  				packer.PackArrayBegin(2);  				packer.PackNumber((int)returnType);  				begin.Pack(packer);  			}  			else  			{  				packer.PackArrayBegin(3);  				packer.PackNumber((int)returnType);  				begin.Pack(packer);  				end.Pack(packer);  			}
Magic Number,Aerospike.Client,MapBase,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapBase.cs,CreateRangeOperation,The following statement contains a magic number: if (end == null)  			{  				packer.PackArrayBegin(2);  				packer.PackNumber((int)returnType);  				begin.Pack(packer);  			}  			else  			{  				packer.PackArrayBegin(3);  				packer.PackNumber((int)returnType);  				begin.Pack(packer);  				end.Pack(packer);  			}
Magic Number,Aerospike.Client,MapOperation,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapOperation.cs,PutItems,The following statement contains a magic number: if (policy.itemsCommand == MapBase.REPLACE_ITEMS)  			{  				// Replace doesn't allow map attributes because it does not create on non-existing key.  				packer.PackArrayBegin(1);  				packer.PackMap(map);  			}  			else  			{  				packer.PackArrayBegin(2);  				packer.PackMap(map);  				packer.PackNumber(policy.attributes);  			}
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,Cluster,The following statement contains a magic number: if (policy.user != null && policy.user.Length > 0)  			{  				this.user = ByteUtil.StringToUtf8(policy.user);    				string pass = policy.password;    				if (pass == null)  				{  					pass = "";  				}    				if (! (pass.Length == 60 && pass.StartsWith("$2a$")))  				{  					pass = AdminCommand.HashPassword(pass);  				}  				this.password = ByteUtil.StringToUtf8(pass);  			}
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,Cluster,The following statement contains a magic number: maxSocketIdleMillis = 1000 * ((policy.maxSocketIdle <= MaxSocketIdleSecondLimit) ? policy.maxSocketIdle : MaxSocketIdleSecondLimit);
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,WaitTillStabilized,The following statement contains a magic number: for (int i = 0; i < 3; i++)  			{  				Tend(failIfNotConnected);    				// Check to see if cluster has changed since the last Tend().  				// If not' assume cluster has stabilized and return.  				if (count == nodes.Length)  				{  					return;  				}    				count = nodes.Length;  			}
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,Tend,The following statement contains a magic number: Peers peers = new Peers(nodes.Length + 16);
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,SeedNodes,The following statement contains a magic number: Dictionary<String' Node> nodesToAdd = new Dictionary<String' Node>(seedArray.Length + 16);
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,SeedNodes,The following statement contains a magic number: if (nodesToAdd.Count > 0)  			{  				AddNodes(nodesToAdd);  				return true;  			}  			else if (failIfNotConnected)  			{  				StringBuilder sb = new StringBuilder(500);  				sb.AppendLine("Failed to connect to host(s): ");    				for (int i = 0; i < seedArray.Length; i++)  				{  					sb.Append(seedArray[i]);  					sb.Append(' ');    					Exception ex = exceptions[i];    					if (ex != null)  					{  						sb.AppendLine(ex.Message);  					}  				}  				throw new AerospikeException.Connection(sb.ToString());  			}
Magic Number,Aerospike.Client,Cluster,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Cluster.cs,FindNodesToRemove,The following statement contains a magic number: foreach (Node node in nodes)  			{  				if (!node.Active)  				{  					// Inactive nodes must be removed.  					removeList.Add(node);  					continue;  				}    				if (refreshCount == 0 && node.failures >= 5)  				{  					// All node info requests failed and this node had 5 consecutive failures.  					// Remove node.  If no nodes are left' seeds will be tried in next cluster  					// tend iteration.  					removeList.Add(node);  					continue;  				}    				if (nodes.Length > 1 && refreshCount >= 1 && node.referenceCount == 0)  				{  					// Node is not referenced by other nodes.  					// Check if node responded to info request.  					if (node.failures == 0)  					{  						// Node is alive' but not referenced by other nodes.  Check if mapped.  						if (! FindNodeInPartitionMap(node))  						{  							// Node doesn't have any partitions mapped to it.  							// There is no point in keeping it in the cluster.  							removeList.Add(node);  						}  					}  					else  					{  						// Node not responding. Remove it.  						removeList.Add(node);  					}  				}  			}
Magic Number,Aerospike.Client,Connection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Connection.cs,Connection,The following statement contains a magic number: try  			{  				socket.NoDelay = true;    				if (timeoutMillis > 0)  				{  					socket.SendTimeout = timeoutMillis;  					socket.ReceiveTimeout = timeoutMillis;  				}  				else  				{  					// Never allow timeoutMillis of zero (no timeout) because WaitOne returns   					// immediately when that happens!  					// Retry functionality will attempt to reconnect later.  					timeoutMillis = 2000;  				}    #if NETFRAMEWORK  				IAsyncResult result = socket.BeginConnect(address' null' null);  				WaitHandle wait = result.AsyncWaitHandle;    				if (wait.WaitOne(timeoutMillis))  				{  					// Connection succeeded.  					// EndConnect will automatically close AsyncWaitHandle.  					socket.EndConnect(result);  				}  				else  				{  					// Connection timed out.  					// Do not close AsyncWaitHandle. If AsyncWaitHandle is closed'  					// the disposed handle can be referenced after the timeout exception is thrown.  					// The handle will eventually get closed by the garbage collector.  					// See: https://social.msdn.microsoft.com/Forums/en-US/313cf28c-2a6d-498e-8188-7a0639dbd552/tcpclientbeginconnect-issue?forum=netfxnetcom  					throw new SocketException((int)SocketError.TimedOut);  				}  #else  				System.Threading.Tasks.Task task = socket.ConnectAsync(address);    				if (! task.Wait(timeoutMillis))  				{  					// Connection timed out.  					throw new SocketException((int)SocketError.TimedOut);  				}  #endif  				timestamp = DateTime.UtcNow;  			}  			catch (Exception e)  			{  				//socket.Close();  				socket.Dispose();  				throw new AerospikeException.Connection(e);  			}
Magic Number,Aerospike.Client,Connection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Connection.cs,ReadFully,The following statement contains a magic number: if (socket.ReceiveTimeout > 0)  			{  				// Check if data is available for reading.  				// Poll is used because the timeout value is respected under 500ms.  				// The Receive method does not timeout until after 500ms.  				if (! socket.Poll(socket.ReceiveTimeout * 1000' SelectMode.SelectRead))  				{  					throw new SocketException((int)SocketError.TimedOut);  				}  			}
Magic Number,Aerospike.Client,NodeValidator,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\NodeValidator.cs,SetAliases,The following statement contains a magic number: aliases = new List<Host>(addresses.Length + 2);
Magic Number,Aerospike.Client,Partition,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\Partition.cs,GetHashCode,The following statement contains a magic number: const int prime = 31;
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasMaster,The following statement contains a magic number: while (offset < length)  			{  				if (buffer[offset] == ':')  				{  					// Parse namespace.  					string ns = ByteUtil.Utf8ToString(buffer' begin' offset - begin).Trim();    					if (ns.Length <= 0 || ns.Length >= 32)  					{  						string response = GetTruncatedResponse();  						throw new AerospikeException.Parse("Invalid partition namespace " + ns + ". Response=" + response);  					}  					begin = ++offset;    					// Parse partition bitmap.  					while (offset < length)  					{  						byte b = buffer[offset];    						if (b == ';' || b == '\n')  						{  							break;  						}  						offset++;  					}    					if (offset == begin)  					{  						string response = GetTruncatedResponse();  						throw new AerospikeException.Parse("Empty partition id for namespace " + ns + ". Response=" + response);  					}    					Partitions partitions;    					if (!map.TryGetValue(ns' out partitions))  					{  						partitions = new Partitions(partitionCount' 1' false);  						CopyPartitionMap();  						map[ns] = partitions;  					}    					// Log.info("Map: " + namespace + "[0] " + node);  					DecodeBitmap(node' partitions' 0' 0' begin);  					begin = ++offset;  				}  				else  				{  					offset++;  				}  			}
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,ParseReplicasAll,The following statement contains a magic number: while (offset < length)  			{  				if (buffer[offset] == ':')  				{  					// Parse namespace.  					string ns = ByteUtil.Utf8ToString(buffer' begin' offset - begin).Trim();    					if (ns.Length <= 0 || ns.Length >= 32)  					{  						string response = GetTruncatedResponse();  						throw new AerospikeException.Parse("Invalid partition namespace " + ns + ". Response=" + response);  					}  					begin = ++offset;    					// Parse regime.  					if (command == Replicas)  					{  						while (offset < length)  						{  							byte b = buffer[offset];    							if (b == ''')  							{  								break;  							}  							offset++;  						}  						regime = Convert.ToInt32(Encoding.UTF8.GetString(buffer' begin' offset - begin));  						begin = ++offset;  					}    					// Parse replica count.  					while (offset < length)  					{  						byte b = buffer[offset];    						if (b == ''')  						{  							break;  						}  						offset++;  					}  					int replicaCount = Convert.ToInt32(Encoding.UTF8.GetString(buffer' begin' offset - begin));    					// Ensure replicaCount is uniform.  					Partitions partitions;    					if (!map.TryGetValue(ns' out partitions))  					{  						// Create new replica array.   						partitions = new Partitions(partitionCount' replicaCount' regime != 0);  						CopyPartitionMap();  						map[ns] = partitions;  					}  					else if (partitions.replicas.Length != replicaCount)  					{  						if (Log.InfoEnabled())  						{  							Log.Info("Namespace " + ns + " replication factor changed from " + partitions.replicas.Length + " to " + replicaCount);  						}    						// Resize partition map.   						Partitions tmp = new Partitions(partitions' replicaCount);    						CopyPartitionMap();  						partitions = tmp;  						map[ns] = partitions;  					}    					// Parse partition bitmaps.  					for (int i = 0; i < replicaCount; i++)  					{  						begin = ++offset;    						// Find bitmap endpoint  						while (offset < length)  						{  							byte b = buffer[offset];    							if (b == ''' || b == ';')  							{  								break;  							}  							offset++;  						}    						if (offset == begin)  						{  							string response = GetTruncatedResponse();  							throw new AerospikeException.Parse("Empty partition id for namespace " + ns + ". Response=" + response);  						}    						// Log.info("Map: " + namespace + '[' + i + "] " + node);  						DecodeBitmap(node' partitions' i' regime' begin);  					}  					begin = ++offset;  				}  				else  				{  					offset++;  				}  			}
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: for (int i = 0; i < partitionCount; i++)  			{  				Node nodeOld = nodeArray[i];    				if ((restoreBuffer[i >> 3] & (0x80 >> (i & 7))) != 0)  				{  					// Node owns this partition.  					int regimeOld = regimes[i];    					if (regime == 0 || regime >= regimeOld)  					{  						// Log.info("Map: " + i);  						if (regime > regimeOld)  						{  							regimes[i] = regime;  						}    						if (nodeOld != null && nodeOld != node)  						{  							// Force previously mapped node to refresh it's partition map on next cluster tend.  							nodeOld.partitionGeneration = -1;  						}  						nodeArray[i] = node;  					}  				}  				else  				{  					// Node does not own partition.  					if (node == nodeOld)  					{  						// Must erase previous map.  						nodeArray[i] = null;  					}  				}  			}
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,DecodeBitmap,The following statement contains a magic number: for (int i = 0; i < partitionCount; i++)  			{  				Node nodeOld = nodeArray[i];    				if ((restoreBuffer[i >> 3] & (0x80 >> (i & 7))) != 0)  				{  					// Node owns this partition.  					int regimeOld = regimes[i];    					if (regime == 0 || regime >= regimeOld)  					{  						// Log.info("Map: " + i);  						if (regime > regimeOld)  						{  							regimes[i] = regime;  						}    						if (nodeOld != null && nodeOld != node)  						{  							// Force previously mapped node to refresh it's partition map on next cluster tend.  							nodeOld.partitionGeneration = -1;  						}  						nodeArray[i] = node;  					}  				}  				else  				{  					// Node does not own partition.  					if (node == nodeOld)  					{  						// Must erase previous map.  						nodeArray[i] = null;  					}  				}  			}
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,GetTruncatedResponse,The following statement contains a magic number: int max = (length > 200) ? 200 : length;
Magic Number,Aerospike.Client,PartitionParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PartitionParser.cs,GetTruncatedResponse,The following statement contains a magic number: int max = (length > 200) ? 200 : length;
Magic Number,Aerospike.Client,PeerParser,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\PeerParser.cs,ParseHosts,The following statement contains a magic number: List<Host> hosts = new List<Host>(4);
Magic Number,Aerospike.Client,TlsConnection,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Cluster\TlsConnection.cs,ReadFully,The following statement contains a magic number: if (!sslStream.CanRead && socket.ReceiveTimeout > 0)  			{  				// Check if data is available for reading.  				// Poll is used because the timeout value is respected under 500ms.  				// The read method does not timeout until after 500ms.  				if (! socket.Poll(socket.ReceiveTimeout * 1000' SelectMode.SelectRead))  				{  					throw new SocketException((int)SocketError.TimedOut);  				}  			}
Magic Number,Aerospike.Client,BatchExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchExecutor.cs,Execute,The following statement contains a magic number: if (policy.maxConcurrentThreads == 1 || batchNodes.Count <= 1)  			{  				// Run batch requests sequentially in same thread.  				foreach (BatchNode batchNode in batchNodes)  				{  					ExecuteNode(cluster' batchNode' policy' keys' existsArray' records' binNames' readAttr);  				}  			}  			else  			{  				// Run batch requests in parallel in separate threads.  				//  				// Multiple threads write to the record/exists array' so one might think that  				// volatile or memory barriers are needed on the write threads and this read thread.  				// This should not be necessary here because it happens in Executor which does a   				// volatile write (Interlocked.Increment(ref completedCount)) at the end of write threads  				// and a synchronized WaitTillComplete() in this thread.  				Executor executor = new Executor(cluster' policy' batchNodes.Count * 2);    				// Initialize threads.    				foreach (BatchNode batchNode in batchNodes)  				{  					if (batchNode.node.UseNewBatch(policy))  					{  						// New batch  						if (records != null)  						{  							MultiCommand command = new BatchGetArrayCommand(batchNode' policy' keys' binNames' records' readAttr);  							executor.AddCommand(batchNode.node' command);  						}  						else  						{  							MultiCommand command = new BatchExistsArrayCommand(batchNode' policy' keys' existsArray);  							executor.AddCommand(batchNode.node' command);  						}  					}  					else  					{  						// There may be multiple threads for a single node because the  						// wire protocol only allows one namespace per command.  Multiple namespaces   						// require multiple threads per node.  						batchNode.SplitByNamespace(keys);    						foreach (BatchNode.BatchNamespace batchNamespace in batchNode.batchNamespaces)  						{  							if (records != null)  							{  								MultiCommand command = new BatchGetArrayDirect(batchNamespace' policy' keys' binNames' records' readAttr);  								executor.AddCommand(batchNode.node' command);  							}  							else  							{  								MultiCommand command = new BatchExistsArrayDirect(batchNamespace' policy' keys' existsArray);  								executor.AddCommand(batchNode.node' command);  							}  						}  					}  				}  				executor.Execute(policy.maxConcurrentThreads);  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode += (int)((uint)keysPerNode >> 2);
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10)  			{  				keysPerNode = 10;  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10)  			{  				keysPerNode = 10;  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: keysPerNode += (int)((uint)keysPerNode >> 2);
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10)  			{  				keysPerNode = 10;  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,GenerateList,The following statement contains a magic number: if (keysPerNode < 10)  			{  				keysPerNode = 10;  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,AddKey,The following statement contains a magic number: if (offsetsSize >= offsets.Length)  			{  				int[] copy = new int[offsetsSize * 2];  				Array.Copy(offsets' 0' copy' 0' offsetsSize);  				offsets = copy;  			}
Magic Number,Aerospike.Client,BatchNode,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\BatchNode.cs,SplitByNamespace,The following statement contains a magic number: batchNamespaces = new List<BatchNamespace>(4);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: for (int i = end - 1; i >= begin; i--)  			{  				val += ((uint)buf[i] - 48) * mult;  				mult *= 10;  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,Utf8DigitsToInt,The following statement contains a magic number: for (int i = end - 1; i >= begin; i--)  			{  				val += ((uint)buf[i] - 48) * mult;  				mult *= 10;  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToHexString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(buf.Length * 2);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToHexString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(len * 2);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToGeoJSON,The following statement contains a magic number: int hdrsz = 1 + 2 + (ncells * 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToGeoJSON,The following statement contains a magic number: int hdrsz = 1 + 2 + (ncells * 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len == 8)  			{  				return BytesToLong(buf' offset);  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len < 8)  			{  				// Handle variable length long.   				long val = 0;    				for (int i = 0; i < len; i++)  				{  					val <<= 8;  					val |= buf[offset + i];  				}  				return val;  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToNumber,The following statement contains a magic number: if (len < 8)  			{  				// Handle variable length long.   				long val = 0;    				for (int i = 0; i < len; i++)  				{  					val <<= 8;  					val |= buf[offset + i];  				}  				return val;  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLongValue,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				val <<= 8;  				val |= buf[offset + i];  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: buf[offset++] = bytes[3];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: buf[offset++] = bytes[2];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,FloatToBytes,The following statement contains a magic number: return 4;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: byte[] bytes = new byte[4];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes[0] = buf[offset + 3];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes[1] = buf[offset + 2];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes[2] = buf[offset + 1];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToFloat,The following statement contains a magic number: bytes[3] = buf[offset];
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 56);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 48);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 40);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 32);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 24);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 16);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >>  8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToBytes,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 16);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 24);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 32);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 40);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 48);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: buf[offset]   = (byte)(v >> 56);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LongToLittleBytes,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToLong,The following statement contains a magic number: return (long)(  				((ulong)(buf[offset]) << 56) |  				((ulong)(buf[offset + 1]) << 48) |  				((ulong)(buf[offset + 2]) << 40) |  				((ulong)(buf[offset + 3]) << 32) |  				((ulong)(buf[offset + 4]) << 24) |  				((ulong)(buf[offset + 5]) << 16) |  				((ulong)(buf[offset + 6]) << 8) |  				((ulong)(buf[offset + 7]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToLong,The following statement contains a magic number: return (long)(  			   ((ulong)(buf[offset]) << 0) |  			   ((ulong)(buf[offset + 1]) << 8) |  			   ((ulong)(buf[offset + 2]) << 16) |  			   ((ulong)(buf[offset + 3]) << 24) |  			   ((ulong)(buf[offset + 4]) << 32) |  			   ((ulong)(buf[offset + 5]) << 40) |  			   ((ulong)(buf[offset + 6]) << 48) |  			   ((ulong)(buf[offset + 7]) << 56)  			   );
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 24);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 16);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToBytes,The following statement contains a magic number: return 4;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 16);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: buf[offset]   = (byte)(v >> 24);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToLittleBytes,The following statement contains a magic number: return 4;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf[offset]) << 24) |   				    ((buf[offset + 1]) << 16) |   					((buf[offset + 2]) << 8) |   					 (buf[offset + 3]));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf[offset]) << 24) |   				    ((buf[offset + 1]) << 16) |   					((buf[offset + 2]) << 8) |   					 (buf[offset + 3]));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf[offset]) << 24) |   				    ((buf[offset + 1]) << 16) |   					((buf[offset + 2]) << 8) |   					 (buf[offset + 3]));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf[offset]) << 24) |   				    ((buf[offset + 1]) << 16) |   					((buf[offset + 2]) << 8) |   					 (buf[offset + 3]));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToInt,The following statement contains a magic number: return (((buf[offset]) << 24) |   				    ((buf[offset + 1]) << 16) |   					((buf[offset + 2]) << 8) |   					 (buf[offset + 3]));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf[offset]) |  					((buf[offset + 1]) << 8) |  					((buf[offset + 2]) << 16) |  					((buf[offset + 3]) << 24));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf[offset]) |  					((buf[offset + 1]) << 8) |  					((buf[offset + 2]) << 16) |  					((buf[offset + 3]) << 24));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf[offset]) |  					((buf[offset + 1]) << 8) |  					((buf[offset + 2]) << 16) |  					((buf[offset + 3]) << 24));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf[offset]) |  					((buf[offset + 1]) << 8) |  					((buf[offset + 2]) << 16) |  					((buf[offset + 3]) << 24));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToInt,The following statement contains a magic number: return ((buf[offset]) |  					((buf[offset + 1]) << 8) |  					((buf[offset + 2]) << 16) |  					((buf[offset + 3]) << 24));
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (  				((uint)(buf[offset]) << 24) |  				((uint)(buf[offset + 1]) << 16) |  				((uint)(buf[offset + 2]) << 8) |  				((uint)(buf[offset + 3]))  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (  				((uint)(buf[offset]) << 24) |  				((uint)(buf[offset + 1]) << 16) |  				((uint)(buf[offset + 2]) << 8) |  				((uint)(buf[offset + 3]))  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (  				((uint)(buf[offset]) << 24) |  				((uint)(buf[offset + 1]) << 16) |  				((uint)(buf[offset + 2]) << 8) |  				((uint)(buf[offset + 3]))  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (  				((uint)(buf[offset]) << 24) |  				((uint)(buf[offset + 1]) << 16) |  				((uint)(buf[offset + 2]) << 8) |  				((uint)(buf[offset + 3]))  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToUInt,The following statement contains a magic number: return (  				((uint)(buf[offset]) << 24) |  				((uint)(buf[offset + 1]) << 16) |  				((uint)(buf[offset + 2]) << 8) |  				((uint)(buf[offset + 3]))  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,ShortToBytes,The following statement contains a magic number: buf[offset++] = (byte)(v >> 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,ShortToBytes,The following statement contains a magic number: return 2;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,ShortToLittleBytes,The following statement contains a magic number: buf[offset]   = (byte)(v >> 8);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,ShortToLittleBytes,The following statement contains a magic number: return 2;
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,BytesToShort,The following statement contains a magic number: return (  				((buf[offset]) << 8) |  				((buf[offset + 1]) << 0)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,LittleBytesToShort,The following statement contains a magic number: return (  				((buf[offset]) << 0) |  				((buf[offset + 1]) << 8)  				);
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,IntToVarBytes,The following statement contains a magic number: while (i < buf.Length && v >= 0x80)  			{  				buf[i++] = (byte)(v | 0x80);  				v >>= 7;  			}
Magic Number,Aerospike.Client,ByteUtil,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ByteUtil.cs,VarBytesToInt,The following statement contains a magic number: do  			{  				b = buf[i++];  				val |= (b & 0x7F) << shift;  				shift += 7;  			} while ((b & 0x80) != 0);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ushort fieldCount = policy.sendSetName ? (ushort)2 : (ushort)1;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += FIELD_HEADER_SIZE + 5;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				BatchRead record = records[offsets[i]];  				Key key = record.key;  				string[] binNames = record.binNames;    				dataOffset += key.digest.Length + 4;    				// Avoid relatively expensive full equality checks for performance reasons.  				// Use reference equality only in hope that common namespaces/bin names are set from   				// fixed variables.  It's fine if equality not determined correctly because it just   				// results in more space used. The batch will still be correct.  				if (prev != null && prev.key.ns == key.ns &&  					(! policy.sendSetName || prev.key.setName == key.setName) &&  					prev.binNames == binNames && prev.readAllBins == record.readAllBins)  				{  					// Can set repeat previous namespace/bin names to save space.  					dataOffset++;  				}  				else  				{  					// Estimate full header' namespace and bin names.  					dataOffset += ByteUtil.EstimateSizeUtf8(key.ns) + FIELD_HEADER_SIZE + 6;    					if (policy.sendSetName)  					{  						dataOffset += ByteUtil.EstimateSizeUtf8(key.setName) + FIELD_HEADER_SIZE;  					}    					if (binNames != null)  					{  						foreach (string binName in binNames)  						{  							EstimateOperationSize(binName);  						}  					}  					prev = record;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				BatchRead record = records[offsets[i]];  				Key key = record.key;  				string[] binNames = record.binNames;    				dataOffset += key.digest.Length + 4;    				// Avoid relatively expensive full equality checks for performance reasons.  				// Use reference equality only in hope that common namespaces/bin names are set from   				// fixed variables.  It's fine if equality not determined correctly because it just   				// results in more space used. The batch will still be correct.  				if (prev != null && prev.key.ns == key.ns &&  					(! policy.sendSetName || prev.key.setName == key.setName) &&  					prev.binNames == binNames && prev.readAllBins == record.readAllBins)  				{  					// Can set repeat previous namespace/bin names to save space.  					dataOffset++;  				}  				else  				{  					// Estimate full header' namespace and bin names.  					dataOffset += ByteUtil.EstimateSizeUtf8(key.ns) + FIELD_HEADER_SIZE + 6;    					if (policy.sendSetName)  					{  						dataOffset += ByteUtil.EstimateSizeUtf8(key.setName) + FIELD_HEADER_SIZE;  					}    					if (binNames != null)  					{  						foreach (string binName in binNames)  						{  							EstimateOperationSize(binName);  						}  					}  					prev = record;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				int index = offsets[i];  				ByteUtil.IntToBytes((uint)index' dataBuffer' dataOffset);  				dataOffset += 4;    				BatchRead record = records[index];  				Key key = record.key;  				string[] binNames = record.binNames;  				byte[] digest = key.digest;  				Array.Copy(digest' 0' dataBuffer' dataOffset' digest.Length);  				dataOffset += digest.Length;    				// Avoid relatively expensive full equality checks for performance reasons.  				// Use reference equality only in hope that common namespaces/bin names are set from   				// fixed variables.  It's fine if equality not determined correctly because it just   				// results in more space used. The batch will still be correct.		  				if (prev != null && prev.key.ns == key.ns &&  					(!policy.sendSetName || prev.key.setName == key.setName) &&  					prev.binNames == binNames && prev.readAllBins == record.readAllBins)  				{  					// Can set repeat previous namespace/bin names to save space.  					dataBuffer[dataOffset++] = 1; // repeat  				}  				else  				{  					// Write full header' namespace and bin names.  					dataBuffer[dataOffset++] = 0; // do not repeat    					if (binNames != null && binNames.Length != 0)  					{  						dataBuffer[dataOffset++] = (byte)readAttr;  						dataOffset += ByteUtil.ShortToBytes(fieldCount' dataBuffer' dataOffset);  						dataOffset += ByteUtil.ShortToBytes((ushort)binNames.Length' dataBuffer' dataOffset);  						WriteField(key.ns' FieldType.NAMESPACE);    						if (policy.sendSetName)  						{  							WriteField(key.setName' FieldType.TABLE);  						}    						foreach (string binName in binNames)  						{  							WriteOperation(binName' Operation.Type.READ);  						}  					}  					else  					{  						dataBuffer[dataOffset++] = (byte)(readAttr | (record.readAllBins ? Command.INFO1_GET_ALL : Command.INFO1_NOBINDATA));  						dataOffset += ByteUtil.ShortToBytes(fieldCount' dataBuffer' dataOffset);  						dataOffset += ByteUtil.ShortToBytes(0' dataBuffer' dataOffset);  						WriteField(key.ns' FieldType.NAMESPACE);    						if (policy.sendSetName)  						{  							WriteField(key.setName' FieldType.TABLE);  						}  					}  					prev = record;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(dataOffset - MSG_TOTAL_HEADER_SIZE - 4)' dataBuffer' fieldSizeOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ushort fieldCount = policy.sendSetName ? (ushort)2 : (ushort)1;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += FIELD_HEADER_SIZE + 5;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				Key key = keys[offsets[i]];    				dataOffset += key.digest.Length + 4;    				// Try reference equality in hope that namespace for all keys is set from a fixed variable.  				if (prev != null && prev.ns == key.ns && (! policy.sendSetName || prev.setName == key.setName))   				{	  					// Can set repeat previous namespace/bin names to save space.  					dataOffset++;  				}  				else  				{  					// Estimate full header' namespace and bin names.  					dataOffset += ByteUtil.EstimateSizeUtf8(key.ns) + FIELD_HEADER_SIZE + 6;    					if (policy.sendSetName)  					{  						dataOffset += ByteUtil.EstimateSizeUtf8(key.setName) + FIELD_HEADER_SIZE;  					}  					dataOffset += binNameSize;  					prev = key;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				Key key = keys[offsets[i]];    				dataOffset += key.digest.Length + 4;    				// Try reference equality in hope that namespace for all keys is set from a fixed variable.  				if (prev != null && prev.ns == key.ns && (! policy.sendSetName || prev.setName == key.setName))   				{	  					// Can set repeat previous namespace/bin names to save space.  					dataOffset++;  				}  				else  				{  					// Estimate full header' namespace and bin names.  					dataOffset += ByteUtil.EstimateSizeUtf8(key.ns) + FIELD_HEADER_SIZE + 6;    					if (policy.sendSetName)  					{  						dataOffset += ByteUtil.EstimateSizeUtf8(key.setName) + FIELD_HEADER_SIZE;  					}  					dataOffset += binNameSize;  					prev = key;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: for (int i = 0; i < max; i++)  			{  				int index = offsets[i];  				ByteUtil.IntToBytes((uint)index' dataBuffer' dataOffset);  				dataOffset += 4;    				Key key = keys[index];  				byte[] digest = key.digest;  				Array.Copy(digest' 0' dataBuffer' dataOffset' digest.Length);  				dataOffset += digest.Length;    				// Try reference equality in hope that namespace for all keys is set from a fixed variable.  				if (prev != null && prev.ns == key.ns && (!policy.sendSetName || prev.setName == key.setName))  				{  					// Can set repeat previous namespace/bin names to save space.  					dataBuffer[dataOffset++] = 1; // repeat  				}  				else  				{  					// Write full header' namespace and bin names.  					dataBuffer[dataOffset++] = 0; // do not repeat  					dataBuffer[dataOffset++] = (byte)readAttr;  					dataOffset += ByteUtil.ShortToBytes(fieldCount' dataBuffer' dataOffset);  					dataOffset += ByteUtil.ShortToBytes((ushort)operationCount' dataBuffer' dataOffset);  					WriteField(key.ns' FieldType.NAMESPACE);    					if (policy.sendSetName)  					{  						WriteField(key.setName' FieldType.TABLE);  					}    					if (binNames != null)  					{  						foreach (string binName in binNames)  						{  							WriteOperation(binName' Operation.Type.READ);  						}  					}  					prev = key;  				}  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchRead,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(dataOffset - MSG_TOTAL_HEADER_SIZE - 4)' dataBuffer' fieldSizeOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetBatchReadDirect,The following statement contains a magic number: WriteHeader(policy' readAttr' 0' 2' operationCount);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 2 + FIELD_HEADER_SIZE;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 4 + FIELD_HEADER_SIZE;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: dataOffset += 8 + FIELD_HEADER_SIZE;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader(2' FieldType.SCAN_OPTIONS);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: priority <<= 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader(4' FieldType.SCAN_TIMEOUT);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetScan,The following statement contains a magic number: WriteFieldHeader(8' FieldType.TRAN_ID);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataOffset += 8 + FIELD_HEADER_SIZE;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null)  			{  				IndexCollectionType type = statement.filter.CollectionType;    				if (type != IndexCollectionType.DEFAULT)  				{  					dataOffset += FIELD_HEADER_SIZE + 1;  					fieldCount++;  				}    				dataOffset += FIELD_HEADER_SIZE;  				filterSize++; // num filters  				filterSize += statement.filter.EstimateSize();  				dataOffset += filterSize;  				fieldCount++;    				// Query bin names are specified as a field (Scan bin names are specified later as operations)  				if (statement.binNames != null)  				{  					dataOffset += FIELD_HEADER_SIZE;  					binNameSize++; // num bin names    					foreach (string binName in statement.binNames)  					{  						binNameSize += ByteUtil.EstimateSizeUtf8(binName) + 1;  					}  					dataOffset += binNameSize;  					fieldCount++;  				}  			}  			else  			{  				// Calling query with no filters is more efficiently handled by a primary index scan.   				// Estimate scan options size.  				dataOffset += 2 + FIELD_HEADER_SIZE;  				fieldCount++;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.functionName != null)  			{  				dataOffset += FIELD_HEADER_SIZE + 1; // udf type  				dataOffset += ByteUtil.EstimateSizeUtf8(statement.packageName) + FIELD_HEADER_SIZE;  				dataOffset += ByteUtil.EstimateSizeUtf8(statement.functionName) + FIELD_HEADER_SIZE;    				if (statement.functionArgs.Length > 0)  				{  					functionArgBuffer = Packer.Pack(statement.functionArgs);  				}  				else  				{  					functionArgBuffer = new byte[0];  				}  				dataOffset += FIELD_HEADER_SIZE + functionArgBuffer.Length;  				fieldCount += 4;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: WriteFieldHeader(8' FieldType.TRAN_ID);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: dataOffset += 8;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null)  			{  				IndexCollectionType type = statement.filter.CollectionType;    				if (type != IndexCollectionType.DEFAULT)  				{  					WriteFieldHeader(1' FieldType.INDEX_TYPE);  					dataBuffer[dataOffset++] = (byte)type;  				}    				WriteFieldHeader(filterSize' FieldType.INDEX_RANGE);  				dataBuffer[dataOffset++] = (byte)1;  				dataOffset = statement.filter.Write(dataBuffer' dataOffset);    				// Query bin names are specified as a field (Scan bin names are specified later as operations)  				if (statement.binNames != null)  				{  					WriteFieldHeader(binNameSize' FieldType.QUERY_BINLIST);  					dataBuffer[dataOffset++] = (byte)statement.binNames.Length;    					foreach (string binName in statement.binNames)  					{  						int len = ByteUtil.StringToUtf8(binName' dataBuffer' dataOffset + 1);  						dataBuffer[dataOffset] = (byte)len;  						dataOffset += len + 1;  					}  				}  			}  			else  			{  				// Calling query with no filters is more efficiently handled by a primary index scan.   				WriteFieldHeader(2' FieldType.SCAN_OPTIONS);  				byte priority = (byte)policy.priority;  				priority <<= 4;  				dataBuffer[dataOffset++] = priority;  				dataBuffer[dataOffset++] = (byte)100;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null)  			{  				IndexCollectionType type = statement.filter.CollectionType;    				if (type != IndexCollectionType.DEFAULT)  				{  					WriteFieldHeader(1' FieldType.INDEX_TYPE);  					dataBuffer[dataOffset++] = (byte)type;  				}    				WriteFieldHeader(filterSize' FieldType.INDEX_RANGE);  				dataBuffer[dataOffset++] = (byte)1;  				dataOffset = statement.filter.Write(dataBuffer' dataOffset);    				// Query bin names are specified as a field (Scan bin names are specified later as operations)  				if (statement.binNames != null)  				{  					WriteFieldHeader(binNameSize' FieldType.QUERY_BINLIST);  					dataBuffer[dataOffset++] = (byte)statement.binNames.Length;    					foreach (string binName in statement.binNames)  					{  						int len = ByteUtil.StringToUtf8(binName' dataBuffer' dataOffset + 1);  						dataBuffer[dataOffset] = (byte)len;  						dataOffset += len + 1;  					}  				}  			}  			else  			{  				// Calling query with no filters is more efficiently handled by a primary index scan.   				WriteFieldHeader(2' FieldType.SCAN_OPTIONS);  				byte priority = (byte)policy.priority;  				priority <<= 4;  				dataBuffer[dataOffset++] = priority;  				dataBuffer[dataOffset++] = (byte)100;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.filter != null)  			{  				IndexCollectionType type = statement.filter.CollectionType;    				if (type != IndexCollectionType.DEFAULT)  				{  					WriteFieldHeader(1' FieldType.INDEX_TYPE);  					dataBuffer[dataOffset++] = (byte)type;  				}    				WriteFieldHeader(filterSize' FieldType.INDEX_RANGE);  				dataBuffer[dataOffset++] = (byte)1;  				dataOffset = statement.filter.Write(dataBuffer' dataOffset);    				// Query bin names are specified as a field (Scan bin names are specified later as operations)  				if (statement.binNames != null)  				{  					WriteFieldHeader(binNameSize' FieldType.QUERY_BINLIST);  					dataBuffer[dataOffset++] = (byte)statement.binNames.Length;    					foreach (string binName in statement.binNames)  					{  						int len = ByteUtil.StringToUtf8(binName' dataBuffer' dataOffset + 1);  						dataBuffer[dataOffset] = (byte)len;  						dataOffset += len + 1;  					}  				}  			}  			else  			{  				// Calling query with no filters is more efficiently handled by a primary index scan.   				WriteFieldHeader(2' FieldType.SCAN_OPTIONS);  				byte priority = (byte)policy.priority;  				priority <<= 4;  				dataBuffer[dataOffset++] = priority;  				dataBuffer[dataOffset++] = (byte)100;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,SetQuery,The following statement contains a magic number: if (statement.functionName != null)  			{  				WriteFieldHeader(1' FieldType.UDF_OP);  				dataBuffer[dataOffset++] = (statement.returnData) ? (byte)1 : (byte)2;  				WriteField(statement.packageName' FieldType.UDF_PACKAGE_NAME);  				WriteField(statement.functionName' FieldType.UDF_FUNCTION);  				WriteField(functionArgBuffer' FieldType.UDF_ARGLIST);  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,EstimateUdfSize,The following statement contains a magic number: return 3;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: dataOffset += 8;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: dataOffset += 8;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following statement contains a magic number: for (int i = 0; i < 10; i++)  			{  				dataBuffer[dataOffset++] = 0;  			}
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(nameLength + valueLength + 4)' dataBuffer' dataOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(nameLength + valueLength + 4)' dataBuffer' dataOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(nameLength + 4)' dataBuffer' dataOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: ByteUtil.IntToBytes(4' dataBuffer' dataOffset);
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteOperation,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteFieldHeader,The following statement contains a magic number: dataOffset += 4;
Magic Number,Aerospike.Client,DeleteCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\DeleteCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,ExistsCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ExistsCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseResult,The following statement contains a magic number: bis = new BufferedStream(stream' 8192);
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseResult,The following statement contains a magic number: while (status)  			{  				// Read header.  				ReadBytes(8);    				long size = ByteUtil.BytesToLong(dataBuffer' 0);  				int receiveSize = ((int)(size & 0xFFFFFFFFFFFFL));    				if (receiveSize > 0)  				{  					status = ParseGroup(receiveSize);  				}  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseGroup,The following statement contains a magic number: while (dataOffset < receiveSize)  			{  				ReadBytes(MSG_REMAINING_HEADER_SIZE);  				resultCode = dataBuffer[5];    				// The only valid server return codes are "ok" and "not found".  				// If other return codes are received' then abort the batch.  				if (resultCode != 0)  				{  					if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  					{  						if (stopOnNotFound)  						{  							return false;  						}  					}  					else  					{  						throw new AerospikeException(resultCode);  					}  				}    				byte info3 = dataBuffer[3];    				// If this is the end marker of the response' do not proceed further  				if ((info3 & Command.INFO3_LAST) == Command.INFO3_LAST)  				{  					return false;  				}    				generation = ByteUtil.BytesToInt(dataBuffer' 6);  				expiration = ByteUtil.BytesToInt(dataBuffer' 10);  				batchIndex = ByteUtil.BytesToInt(dataBuffer' 14);  				fieldCount = ByteUtil.BytesToShort(dataBuffer' 18);  				opCount = ByteUtil.BytesToShort(dataBuffer' 20);    				Key key = ParseKey(fieldCount);  				ParseRow(key);  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++)  			{  				ReadBytes(4);  				int fieldlen = ByteUtil.BytesToInt(dataBuffer' 0);  				ReadBytes(fieldlen);  				int fieldtype = dataBuffer[0];  				int size = fieldlen - 1;    				switch (fieldtype)   				{  				case FieldType.DIGEST_RIPE:  					digest = new byte[size];  					Array.Copy(dataBuffer' 1' digest' 0' size);  					break;  			  				case FieldType.NAMESPACE:  					ns = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;  				  				case FieldType.TABLE:  					setName = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;    				case FieldType.KEY:  					userKey = ByteUtil.BytesToKeyValue(dataBuffer[1]' dataBuffer' 2' size-1);  					break;  				}  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following statement contains a magic number: for (int i = 0; i < fieldCount; i++)  			{  				ReadBytes(4);  				int fieldlen = ByteUtil.BytesToInt(dataBuffer' 0);  				ReadBytes(fieldlen);  				int fieldtype = dataBuffer[0];  				int size = fieldlen - 1;    				switch (fieldtype)   				{  				case FieldType.DIGEST_RIPE:  					digest = new byte[size];  					Array.Copy(dataBuffer' 1' digest' 0' size);  					break;  			  				case FieldType.NAMESPACE:  					ns = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;  				  				case FieldType.TABLE:  					setName = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;    				case FieldType.KEY:  					userKey = ByteUtil.BytesToKeyValue(dataBuffer[1]' dataBuffer' 2' size-1);  					break;  				}  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte particleType = dataBuffer[5];  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);  				string name = ByteUtil.Utf8ToString(dataBuffer' 0' nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' 0' particleBytesSize);    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte particleType = dataBuffer[5];  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);  				string name = ByteUtil.Utf8ToString(dataBuffer' 0' nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' 0' particleBytesSize);    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte particleType = dataBuffer[5];  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);  				string name = ByteUtil.Utf8ToString(dataBuffer' 0' nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' 0' particleBytesSize);    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte particleType = dataBuffer[5];  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);  				string name = ByteUtil.Utf8ToString(dataBuffer' 0' nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' 0' particleBytesSize);    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				bins[name] = value;  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: byte headerLength = dataBuffer[8];
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: int generation = ByteUtil.BytesToInt(dataBuffer' 14);
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: int expiration = ByteUtil.BytesToInt(dataBuffer' 18);
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: int fieldCount = ByteUtil.BytesToShort(dataBuffer' 26);
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseResult,The following statement contains a magic number: int opCount = ByteUtil.BytesToShort(dataBuffer' 28);
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: try  			{  				string[] list = ret.Split(':');  				code = Convert.ToInt32(list[2].Trim());    				if (code == ResultCode.LARGE_ITEM_NOT_FOUND)  				{  					record = null;  					return;  				}  				message = list[0] + ':' + list[1] + ' ' + list[3];  			}  			catch (Exception)  			{  				// Use generic exception if parse error occurs.  				throw new AerospikeException(resultCode' ret);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,HandleUdfError,The following statement contains a magic number: try  			{  				string[] list = ret.Split(':');  				code = Convert.ToInt32(list[2].Trim());    				if (code == ResultCode.LARGE_ITEM_NOT_FOUND)  				{  					record = null;  					return;  				}  				message = list[0] + ':' + list[1] + ' ' + list[3];  			}  			catch (Exception)  			{  				// Use generic exception if parse error occurs.  				throw new AerospikeException(resultCode' ret);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: if (fieldCount != 0)  			{  				// Just skip over all the fields  				for (int i = 0; i < fieldCount; i++)  				{  					int fieldSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  					receiveOffset += 4 + fieldSize;  				}  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadCommand.cs,ParseRecord,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				int opSize = ByteUtil.BytesToInt(dataBuffer' receiveOffset);  				byte particleType = dataBuffer[receiveOffset + 5];  				byte nameSize = dataBuffer[receiveOffset + 7];  				string name = ByteUtil.Utf8ToString(dataBuffer' receiveOffset + 8' nameSize);  				receiveOffset += 4 + 4 + nameSize;    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				object value = ByteUtil.BytesToParticle(particleType' dataBuffer' receiveOffset' particleBytesSize);  				receiveOffset += particleBytesSize;    				if (bins == null)  				{  					bins = new Dictionary<string' object>();  				}  				AddBin(bins' name' value);  			}
Magic Number,Aerospike.Client,ReadHeaderCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadHeaderCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,ReadHeaderCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadHeaderCommand.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0)  			{  				int generation = ByteUtil.BytesToInt(dataBuffer' 14);  				int expiration = ByteUtil.BytesToInt(dataBuffer' 18);  				record = new Record(null' generation' expiration);  			}  			else  			{  				if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  				{  					record = null;  				}  				else  				{  					throw new AerospikeException(resultCode);  				}  			}
Magic Number,Aerospike.Client,ReadHeaderCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\ReadHeaderCommand.cs,ParseResult,The following statement contains a magic number: if (resultCode == 0)  			{  				int generation = ByteUtil.BytesToInt(dataBuffer' 14);  				int expiration = ByteUtil.BytesToInt(dataBuffer' 18);  				record = new Record(null' generation' expiration);  			}  			else  			{  				if (resultCode == ResultCode.KEY_NOT_FOUND_ERROR)  				{  					record = null;  				}  				else  				{  					throw new AerospikeException(resultCode);  				}  			}
Magic Number,Aerospike.Client,RegisterCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\RegisterCommand.cs,Register,The following statement contains a magic number: StringBuilder sb = new StringBuilder(serverPath.Length + content.Length + 100);
Magic Number,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,Execute,The following statement contains a magic number: while (true)  			{  				try  				{  					if (partition != null)  					{  						// Single record command node retrieval.  						node = GetNode(cluster' partition' policy.replica' isRead);  					}    					Connection conn = node.GetConnection(socketTimeout);    					try  					{  						// Set command buffer.  						WriteBuffer();    						// Check if timeout needs to be changed in send buffer.  						if (totalTimeout != policy.totalTimeout)  						{  							// Reset timeout in send buffer (destined for server) and socket.  							ByteUtil.IntToBytes((uint)totalTimeout' dataBuffer' 22);  						}    						// Send command.  						conn.Write(dataBuffer' dataOffset);    						// Parse results.  						ParseResult(conn);    						// Put connection back in pool.  						node.PutConnection(conn);    						// Command has completed successfully.  Exit method.  						return;  					}  					catch (AerospikeException ae)  					{  						if (ae.KeepConnection())  						{  							// Put connection back in pool.  							node.PutConnection(conn);  						}  						else  						{  							// Close socket to flush out possible garbage.  Do not put back in pool.  							node.CloseConnection(conn);  						}    						if (ae.Result == ResultCode.TIMEOUT)  						{  							// Go through retry logic on server timeout.  							exception = new AerospikeException.Timeout(node' policy' iteration + 1' false);  							isClientTimeout = false;    							if (isRead)  							{  								base.sequence++;  							}  						}  						else  						{  							throw;  						}  					}  					catch (SocketException se)  					{  						// Socket errors are considered temporary anomalies.  						// Retry after closing connection.  						node.CloseConnection(conn);    						if (se.SocketErrorCode == SocketError.TimedOut)  						{  							exception = se;  							isClientTimeout = true;    							if (isRead)  							{  								base.sequence++;  							}  						}  						else  						{  							exception = new AerospikeException(se);  							isClientTimeout = false;  							base.sequence++;  						}  					}  					catch (Exception)  					{  						// All other exceptions are considered fatal.  Do not retry.  						// Close socket to flush out possible garbage.  Do not put back in pool.  						node.CloseConnection(conn);  						throw;  					}  				}  				catch (AerospikeException.Connection ce)  				{  					// Socket connection error has occurred. Retry.  					exception = ce;  					isClientTimeout = false;  					base.sequence++;  				}    				// Check maxRetries.  				if (++iteration > policy.maxRetries)  				{  					break;  				}    				if (policy.totalTimeout > 0)  				{  					// Check for total timeout.  					long remaining = (long)deadline.Subtract(DateTime.UtcNow).TotalMilliseconds - policy.sleepBetweenRetries;    					if (remaining <= 0)  					{  						break;  					}    					if (remaining < totalTimeout)  					{  						totalTimeout = (int)remaining;    						if (socketTimeout > totalTimeout)  						{  							socketTimeout = totalTimeout;  						}  					}  				}    				if (!isClientTimeout && policy.sleepBetweenRetries > 0)  				{  					// Sleep before trying again.  					Util.Sleep(policy.sleepBetweenRetries);  				}  			}
Magic Number,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)dataOffset - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)dataOffset - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,End,The following statement contains a magic number: ulong size = ((ulong)dataOffset - 8) | (CL_MSG_VERSION << 56) | (AS_MSG_TYPE << 48);
Magic Number,Aerospike.Client,SyncCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\SyncCommand.cs,EmptySocket,The following statement contains a magic number: int headerLength = dataBuffer[8];
Magic Number,Aerospike.Client,TouchCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\TouchCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,WriteCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\WriteCommand.cs,ParseResult,The following statement contains a magic number: int resultCode = dataBuffer[13];
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,Truncate,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ScanAll,The following statement contains a magic number: if (policy.scanPercent <= 0 || policy.scanPercent > 100)  			{  				throw new AerospikeException(ResultCode.PARAMETER_ERROR' "Invalid scan percent: " + policy.scanPercent);  			}
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ScanNode,The following statement contains a magic number: if (policy.scanPercent <= 0 || policy.scanPercent > 100)  			{  				throw new AerospikeException(ResultCode.PARAMETER_ERROR' "Invalid scan percent: " + policy.scanPercent);  			}
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,CreateIndex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(500);
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,DropIndex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(500);
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,QueryUsers,The following statement contains a magic number: AdminCommand.UserCommand command = new AdminCommand.UserCommand(100);
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,QueryRoles,The following statement contains a magic number: AdminCommand.RoleCommand command = new AdminCommand.RoleCommand(100);
Magic Number,Aerospike.Client,AerospikeClient,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\AerospikeClient.cs,ParseInfoError,The following statement contains a magic number: if (list.Length >= 2 && list[0].Equals("FAIL"))  			{  				int code = 0;    				try  				{  					code = Convert.ToInt32(list[1]);  				}  				catch (Exception)  				{  				}  				throw new AerospikeException(code' message);  			}
Magic Number,Aerospike.Client,Host,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Host.cs,GetHashCode,The following statement contains a magic number: const int prime = 31;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length)  			{  				offset = ByteUtil.EstimateSizeUtf8(command) + 9;  				ResizeBuffer(offset);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length)  			{  				offset = ByteUtil.EstimateSizeUtf8(command) + 9;  				ResizeBuffer(offset);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if ((command.Length * 2 + 9) > buffer.Length)  			{  				offset = ByteUtil.EstimateSizeUtf8(command) + 9;  				ResizeBuffer(offset);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: foreach (string command in commands)  			{  				offset += command.Length * 2 + 1;  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: if (offset > buffer.Length)  			{  				offset = 8;    				foreach (string command in commands)  				{  					offset += ByteUtil.EstimateSizeUtf8(command) + 1;  				}  				ResizeBuffer(offset);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,Info,The following statement contains a magic number: offset = 8;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: while (offset < length)  			{  				b = buffer[offset];    				if (b < 48 || b > 57)  				{  					end = offset;  					break;  				}  				offset++;  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,ParseInt,The following statement contains a magic number: while (offset < length)  			{  				b = buffer[offset];    				if (b < 48 || b > 57)  				{  					end = offset;  					break;  				}  				offset++;  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,GetTruncatedResponse,The following statement contains a magic number: int max = (length > 200) ? 200 : length;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,GetTruncatedResponse,The following statement contains a magic number: int max = (length > 200) ? 200 : length;
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try  			{  				// Write size field.  				ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  				ByteUtil.LongToBytes(size' buffer' 0);    				// Write.  				conn.Write(buffer' offset);    				// Read - reuse input buffer.  				conn.ReadFully(buffer' 8);    				size = (ulong)ByteUtil.BytesToLong(buffer' 0);  				length = (int)(size & 0xFFFFFFFFFFFFL);  				ResizeBuffer(length);  				conn.ReadFully(buffer' length);  				offset = 0;  			}  			catch (SocketException se)  			{  				throw new AerospikeException(se);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try  			{  				// Write size field.  				ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  				ByteUtil.LongToBytes(size' buffer' 0);    				// Write.  				conn.Write(buffer' offset);    				// Read - reuse input buffer.  				conn.ReadFully(buffer' 8);    				size = (ulong)ByteUtil.BytesToLong(buffer' 0);  				length = (int)(size & 0xFFFFFFFFFFFFL);  				ResizeBuffer(length);  				conn.ReadFully(buffer' length);  				offset = 0;  			}  			catch (SocketException se)  			{  				throw new AerospikeException(se);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,SendCommand,The following statement contains a magic number: try  			{  				// Write size field.  				ulong size = ((ulong)offset - 8L) | (2L << 56) | (1L << 48);  				ByteUtil.LongToBytes(size' buffer' 0);    				// Write.  				conn.Write(buffer' offset);    				// Read - reuse input buffer.  				conn.ReadFully(buffer' 8);    				size = (ulong)ByteUtil.BytesToLong(buffer' 0);  				length = (int)(size & 0xFFFFFFFFFFFFL);  				ResizeBuffer(length);  				conn.ReadFully(buffer' length);  				offset = 0;  			}  			catch (SocketException se)  			{  				throw new AerospikeException(se);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (str.StartsWith("ERROR:"))  			{  				int begin = 6;  				int end = str.IndexOf(':'' begin);  				int code = -1;  				string message = "";    				if (end >= 0)  				{  					code = int.Parse(str.Substring(begin' end - begin));    					if (str[str.Length-1] == '\n')  					{  						message = str.Substring(end + 1' str.Length - 2);  					}  					else  					{  						message = str.Substring(end + 1);  					}  				}  				throw new AerospikeException(code' message);  			}
Magic Number,Aerospike.Client,Info,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Info.cs,CheckError,The following statement contains a magic number: if (str.StartsWith("ERROR:"))  			{  				int begin = 6;  				int end = str.IndexOf(':'' begin);  				int code = -1;  				string message = "";    				if (end >= 0)  				{  					code = int.Parse(str.Substring(begin' end - begin));    					if (str[str.Length-1] == '\n')  					{  						message = str.Substring(end + 1' str.Length - 2);  					}  					else  					{  						message = str.Substring(end + 1);  					}  				}  				throw new AerospikeException(code' message);  			}
Magic Number,Aerospike.Client,Key,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Key.cs,GetHashCode,The following statement contains a magic number: foreach (byte element in digest)  			{  				result = 31 * result + element;  			}
Magic Number,Aerospike.Client,Key,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Key.cs,GetHashCode,The following statement contains a magic number: return 31 * result + ns.GetHashCode();
Magic Number,Aerospike.Client,Record,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Record.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(500);
Magic Number,Aerospike.Client,Record,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Record.cs,ToString,The following statement contains a magic number: if (bins != null)  			{  				bool sep = false;    				foreach (KeyValuePair<string' object> entry in bins)  				{  					if (sep)  					{  						sb.Append(''');  					}  					else  					{  						sep = true;  					}  					sb.Append('(');  					sb.Append(entry.Key);  					sb.Append(':');  					sb.Append(entry.Value);  					sb.Append(')');    					if (sb.Length > 1000)  					{  						sb.Append("...");  						break;  					}  				}  			}  			else  			{  				sb.Append("null");  			}
Magic Number,Aerospike.Client,BytesValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: foreach (byte b in bytes)  				{  					result = 31 * result + b;  				}
Magic Number,Aerospike.Client,ByteSegmentValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < length; i++)  				{  					result = 31 * result + bytes[offset + i];  				}
Magic Number,Aerospike.Client,DoubleValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,DoubleValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Aerospike.Client,FloatValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,FloatValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Aerospike.Client,LongValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,LongValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return (int)((ulong)value ^ ((ulong)value >> 32));
Magic Number,Aerospike.Client,UnsignedLongValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return ((value & 0x8000000000000000) == 0)? 8 : 9;
Magic Number,Aerospike.Client,UnsignedLongValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return ((value & 0x8000000000000000) == 0)? 8 : 9;
Magic Number,Aerospike.Client,UnsignedLongValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return (int)(value ^ (value >> 32));
Magic Number,Aerospike.Client,IntegerValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,UnsignedIntegerValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,ShortValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,UnsignedShortValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,BooleanValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return value ? 1231 : 1237;
Magic Number,Aerospike.Client,BooleanValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: return value ? 1231 : 1237;
Magic Number,Aerospike.Client,GeoJSONValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,EstimateSize,The following statement contains a magic number: return 1 + 2 + ByteUtil.EstimateSizeUtf8(value);
Magic Number,Aerospike.Client,GeoJSONValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,Write,The following statement contains a magic number: return 1 + 2 + ByteUtil.StringToUtf8(value' buffer' offset + 3);
Magic Number,Aerospike.Client,GeoJSONValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,Write,The following statement contains a magic number: return 1 + 2 + ByteUtil.StringToUtf8(value' buffer' offset + 3);
Magic Number,Aerospike.Client,ValueArray,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: foreach (Value value in array)  				{  					result = 31 * result + (value == null ? 0 : value.GetHashCode());  				}
Magic Number,Aerospike.Client,ListValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: foreach (object value in list)  				{  					result = 31 * result + (value == null ? 0 : value.GetHashCode());  				}
Magic Number,Aerospike.Client,MapValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: foreach (DictionaryEntry entry in map)  				{  					result = 31 * result + (entry.Key == null ? 0 : entry.Key.GetHashCode());  					result = 31 * result + (entry.Value == null ? 0 : entry.Value.GetHashCode());  				}
Magic Number,Aerospike.Client,MapValue,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Main\Value.cs,GetHashCode,The following statement contains a magic number: foreach (DictionaryEntry entry in map)  				{  					result = 31 * result + (entry.Key == null ? 0 : entry.Key.GetHashCode());  					result = 31 * result + (entry.Value == null ? 0 : entry.Value.GetHashCode());  				}
Magic Number,Aerospike.Client,InfoPolicy,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Policy\InfoPolicy.cs,InfoPolicy,The following statement contains a magic number: timeout = 1000;
Magic Number,Aerospike.Client,QueryPolicy,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Policy\QueryPolicy.cs,QueryPolicy,The following statement contains a magic number: base.socketTimeout = 10000;
Magic Number,Aerospike.Client,ScanPolicy,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Policy\ScanPolicy.cs,ScanPolicy,The following statement contains a magic number: base.socketTimeout = 10000;
Magic Number,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,EstimateSize,The following statement contains a magic number: return ByteUtil.EstimateSizeUtf8(name) + begin.EstimateSize() + end.EstimateSize() + 10;
Magic Number,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: len = begin.Write(buf' offset + 4);
Magic Number,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: offset += len + 4;
Magic Number,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: len = end.Write(buf' offset + 4);
Magic Number,Aerospike.Client,Filter,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Filter.cs,Write,The following statement contains a magic number: offset += len + 4;
Magic Number,Aerospike.Client,IntegerVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 14;
Magic Number,Aerospike.Client,IntegerVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,IntegerVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: ByteUtil.IntToBytes(8' buf' offset);
Magic Number,Aerospike.Client,IntegerVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,IntegerVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 8;
Magic Number,Aerospike.Client,StringVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return ByteUtil.EstimateSizeUtf8(value) + 6;
Magic Number,Aerospike.Client,StringVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,StringVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: int len = ByteUtil.StringToUtf8(value' buf' offset + 4);
Magic Number,Aerospike.Client,StringVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4 + len;
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 2 + 4 + 1 + 2 + ByteUtil.EstimateSizeUtf8(this.value);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 2 + 4 + 1 + 2 + ByteUtil.EstimateSizeUtf8(this.value);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 2 + 4 + 1 + 2 + ByteUtil.EstimateSizeUtf8(this.value);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: int len = ByteUtil.StringToUtf8(value' buf' offset + 4 + 1 + 2);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: int len = ByteUtil.StringToUtf8(value' buf' offset + 4 + 1 + 2);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: ByteUtil.IntToBytes((uint)(len + 1 + 2)' buf' offset);
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,GeoJSONVal,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,AndOr,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 8;
Magic Number,Aerospike.Client,AndOr,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,AndOr,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: ByteUtil.IntToBytes(2' buf' offset);
Magic Number,Aerospike.Client,AndOr,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,AndOr,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,Op,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 6;
Magic Number,Aerospike.Client,Op,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,Op,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,OpInt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,EstimateSize,The following statement contains a magic number: return 10;
Magic Number,Aerospike.Client,OpInt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,OpInt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: ByteUtil.IntToBytes(4' buf' offset);
Magic Number,Aerospike.Client,OpInt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,OpInt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\PredExp.cs,Write,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,QueryAggregateCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The following statement contains a magic number: ReadBytes(8);
Magic Number,Aerospike.Client,QueryAggregateCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The following statement contains a magic number: byte particleType = dataBuffer[5];
Magic Number,Aerospike.Client,QueryAggregateCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The following statement contains a magic number: byte nameSize = dataBuffer[7];
Magic Number,Aerospike.Client,QueryAggregateCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateCommand.cs,ParseRow,The following statement contains a magic number: int particleBytesSize = (int)(opSize - (4 + nameSize));
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,QueryAggregateExecutor,The following statement contains a magic number: inputQueue = new BlockingCollection<object>(500);
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try  			{  				lua = LuaCache.GetInstance();    				// Start thread queries to each node.  				StartThreads();    				lua.LoadPackage(statement);    				object[] args = new object[4 + statement.functionArgs.Length];  				args[0] = lua.GetFunction(statement.functionName);  				args[1] = 2;  				args[2] = new LuaInputStream(inputQueue' cancel.Token);  				args[3] = new LuaOutputStream(resultSet);  				int count = 4;    				foreach (Value value in statement.functionArgs)  				{  					args[count++] = value.Object;  				}  				lua.Call("apply_stream"' args);  			}  			catch (Neo.IronLua.LuaRuntimeException lre)  			{  				// Try to get that elusive lua stack trace.  				HandleException(new Exception(lre.Message + lre.StackTrace));  			}  			catch (Exception e)  			{  				if (e.InnerException is Neo.IronLua.LuaRuntimeException)  				{  					// Try to get that elusive lua stack trace.  					Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  					HandleException(new Exception(lre.Message + lre.StackTrace));  				}  				else  				{  					HandleException(e);  				}  			}  			finally  			{  				// Send end command to user's result set.  				// If query was already cancelled' this put will be ignored.  				resultSet.Put(ResultSet.END);    				if (lua != null)  				{  					LuaCache.PutInstance(lua);  				}  			}
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try  			{  				lua = LuaCache.GetInstance();    				// Start thread queries to each node.  				StartThreads();    				lua.LoadPackage(statement);    				object[] args = new object[4 + statement.functionArgs.Length];  				args[0] = lua.GetFunction(statement.functionName);  				args[1] = 2;  				args[2] = new LuaInputStream(inputQueue' cancel.Token);  				args[3] = new LuaOutputStream(resultSet);  				int count = 4;    				foreach (Value value in statement.functionArgs)  				{  					args[count++] = value.Object;  				}  				lua.Call("apply_stream"' args);  			}  			catch (Neo.IronLua.LuaRuntimeException lre)  			{  				// Try to get that elusive lua stack trace.  				HandleException(new Exception(lre.Message + lre.StackTrace));  			}  			catch (Exception e)  			{  				if (e.InnerException is Neo.IronLua.LuaRuntimeException)  				{  					// Try to get that elusive lua stack trace.  					Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  					HandleException(new Exception(lre.Message + lre.StackTrace));  				}  				else  				{  					HandleException(e);  				}  			}  			finally  			{  				// Send end command to user's result set.  				// If query was already cancelled' this put will be ignored.  				resultSet.Put(ResultSet.END);    				if (lua != null)  				{  					LuaCache.PutInstance(lua);  				}  			}
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try  			{  				lua = LuaCache.GetInstance();    				// Start thread queries to each node.  				StartThreads();    				lua.LoadPackage(statement);    				object[] args = new object[4 + statement.functionArgs.Length];  				args[0] = lua.GetFunction(statement.functionName);  				args[1] = 2;  				args[2] = new LuaInputStream(inputQueue' cancel.Token);  				args[3] = new LuaOutputStream(resultSet);  				int count = 4;    				foreach (Value value in statement.functionArgs)  				{  					args[count++] = value.Object;  				}  				lua.Call("apply_stream"' args);  			}  			catch (Neo.IronLua.LuaRuntimeException lre)  			{  				// Try to get that elusive lua stack trace.  				HandleException(new Exception(lre.Message + lre.StackTrace));  			}  			catch (Exception e)  			{  				if (e.InnerException is Neo.IronLua.LuaRuntimeException)  				{  					// Try to get that elusive lua stack trace.  					Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  					HandleException(new Exception(lre.Message + lre.StackTrace));  				}  				else  				{  					HandleException(e);  				}  			}  			finally  			{  				// Send end command to user's result set.  				// If query was already cancelled' this put will be ignored.  				resultSet.Put(ResultSet.END);    				if (lua != null)  				{  					LuaCache.PutInstance(lua);  				}  			}
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try  			{  				lua = LuaCache.GetInstance();    				// Start thread queries to each node.  				StartThreads();    				lua.LoadPackage(statement);    				object[] args = new object[4 + statement.functionArgs.Length];  				args[0] = lua.GetFunction(statement.functionName);  				args[1] = 2;  				args[2] = new LuaInputStream(inputQueue' cancel.Token);  				args[3] = new LuaOutputStream(resultSet);  				int count = 4;    				foreach (Value value in statement.functionArgs)  				{  					args[count++] = value.Object;  				}  				lua.Call("apply_stream"' args);  			}  			catch (Neo.IronLua.LuaRuntimeException lre)  			{  				// Try to get that elusive lua stack trace.  				HandleException(new Exception(lre.Message + lre.StackTrace));  			}  			catch (Exception e)  			{  				if (e.InnerException is Neo.IronLua.LuaRuntimeException)  				{  					// Try to get that elusive lua stack trace.  					Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  					HandleException(new Exception(lre.Message + lre.StackTrace));  				}  				else  				{  					HandleException(e);  				}  			}  			finally  			{  				// Send end command to user's result set.  				// If query was already cancelled' this put will be ignored.  				resultSet.Put(ResultSet.END);    				if (lua != null)  				{  					LuaCache.PutInstance(lua);  				}  			}
Magic Number,Aerospike.Client,QueryAggregateExecutor,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\QueryAggregateExecutor.cs,Run,The following statement contains a magic number: try  			{  				lua = LuaCache.GetInstance();    				// Start thread queries to each node.  				StartThreads();    				lua.LoadPackage(statement);    				object[] args = new object[4 + statement.functionArgs.Length];  				args[0] = lua.GetFunction(statement.functionName);  				args[1] = 2;  				args[2] = new LuaInputStream(inputQueue' cancel.Token);  				args[3] = new LuaOutputStream(resultSet);  				int count = 4;    				foreach (Value value in statement.functionArgs)  				{  					args[count++] = value.Object;  				}  				lua.Call("apply_stream"' args);  			}  			catch (Neo.IronLua.LuaRuntimeException lre)  			{  				// Try to get that elusive lua stack trace.  				HandleException(new Exception(lre.Message + lre.StackTrace));  			}  			catch (Exception e)  			{  				if (e.InnerException is Neo.IronLua.LuaRuntimeException)  				{  					// Try to get that elusive lua stack trace.  					Neo.IronLua.LuaRuntimeException lre = e.InnerException as Neo.IronLua.LuaRuntimeException;  					HandleException(new Exception(lre.Message + lre.StackTrace));  				}  				else  				{  					HandleException(e);  				}  			}  			finally  			{  				// Send end command to user's result set.  				// If query was already cancelled' this put will be ignored.  				resultSet.Put(ResultSet.END);    				if (lua != null)  				{  					LuaCache.PutInstance(lua);  				}  			}
Magic Number,Aerospike.Client,ServerCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  			}
Magic Number,Aerospike.Client,ServerCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  			}
Magic Number,Aerospike.Client,ServerCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\ServerCommand.cs,ParseRow,The following statement contains a magic number: for (int i = 0 ; i < opCount; i++)  			{  				ReadBytes(8);  				int opSize = ByteUtil.BytesToInt(dataBuffer' 0);  				byte nameSize = dataBuffer[7];    				ReadBytes(nameSize);    				int particleBytesSize = (int)(opSize - (4 + nameSize));  				ReadBytes(particleBytesSize);  			}
Magic Number,Aerospike.Client,Statement,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Query\Statement.cs,SetBinNames,The following statement contains a magic number: foreach (string binName in binNames)  			{  				if (binName.Length > 14)  				{  					throw new AerospikeException(ResultCode.BIN_NAME_TOO_LONG' "Bin name length greater than 14 characters");  				}  			}
Magic Number,Aerospike.Client,BaseTask,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Task\BaseTask.cs,Wait,The following statement contains a magic number: TaskWait(1000);
Magic Number,Aerospike.Client,BaseTask,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Task\BaseTask.cs,IsDone,The following statement contains a magic number: if (status == NOT_FOUND)  			{  				// The task may have not started yet.  Re-request status after a delay.  				Util.Sleep(1000);  				status = QueryStatus();  			}
Magic Number,Aerospike.Client,IndexTask,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Task\IndexTask.cs,QueryStatus,The following statement contains a magic number: foreach (Node node in nodes)  			{  				string response = Info.Request(policy' node' command);  				string find = "load_pct=";  				int index = response.IndexOf(find);        				if (index < 0)  				{  					if (response.IndexOf("FAIL:201") >= 0 || response.IndexOf("FAIL:203") >= 0)  					{  						// Index not found or not readable.  						return BaseTask.NOT_FOUND;  					}  					else  					{  						// Throw exception immediately.  						throw new AerospikeException(command + " failed: " + response);  					}  				}        				int begin = index + find.Length;  				int end = response.IndexOf(';'' begin);  				string str = response.Substring(begin' end - begin);  				int pct = Convert.ToInt32(str);        				if (pct != 100)  				{  					return BaseTask.IN_PROGRESS;  				}  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackArrayBegin,The following statement contains a magic number: if (size < 16)  			{  				PackByte((byte)(0x90 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xdc' (ushort)size);  			}  			else  			{  				PackInt(0xdd' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackArrayBegin,The following statement contains a magic number: if (size < 16)  			{  				PackByte((byte)(0x90 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xdc' (ushort)size);  			}  			else  			{  				PackInt(0xdd' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackMapBegin,The following statement contains a magic number: if (size < 16)  			{  				PackByte((byte) (0x80 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xde' (ushort)size);  			}  			else  			{  				PackInt(0xdf' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackMapBegin,The following statement contains a magic number: if (size < 16)  			{  				PackByte((byte) (0x80 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xde' (ushort)size);  			}  			else  			{  				PackInt(0xdf' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackByteArrayBegin,The following statement contains a magic number: if (size < 32)  			{  				PackByte((byte)(0xa0 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xda' (ushort)size);  			}  			else  			{  				PackInt(0xdb' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackByteArrayBegin,The following statement contains a magic number: if (size < 32)  			{  				PackByte((byte)(0xa0 | size));  			}  			else if (size < 65536)  			{  				PackShort(0xda' (ushort)size);  			}  			else  			{  				PackInt(0xdb' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= 0L)  			{  				if (val < 128L)  				{  					PackByte((byte)val);  					return;  				}    				if (val < 256L)  				{  					PackByte(0xcc' (byte)val);  					return;  				}    				if (val < 65536L)  				{  					PackShort(0xcd' (ushort)val);  					return;  				}    				if (val < 4294967296L)  				{  					PackInt(0xce' (uint)val);  					return;  				}  				PackLong(0xcf' (ulong)val);  			}  			else  			{  				if (val >= -32)  				{  					PackByte((byte)(0xe0 | ((int)val + 32)));  					return;  				}    				if (val >= byte.MinValue)  				{  					PackByte(0xd0' (byte)val);  					return;  				}    				if (val >= short.MinValue)  				{  					PackShort(0xd1' (ushort)val);  					return;  				}    				if (val >= int.MinValue)  				{  					PackInt(0xd2' (uint)val);  					return;  				}  				PackLong(0xd3' (ulong)val);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackNumber,The following statement contains a magic number: if (val >= 0L)  			{  				if (val < 128L)  				{  					PackByte((byte)val);  					return;  				}    				if (val < 256L)  				{  					PackByte(0xcc' (byte)val);  					return;  				}    				if (val < 65536L)  				{  					PackShort(0xcd' (ushort)val);  					return;  				}    				if (val < 4294967296L)  				{  					PackInt(0xce' (uint)val);  					return;  				}  				PackLong(0xcf' (ulong)val);  			}  			else  			{  				if (val >= -32)  				{  					PackByte((byte)(0xe0 | ((int)val + 32)));  					return;  				}    				if (val >= byte.MinValue)  				{  					PackByte(0xd0' (byte)val);  					return;  				}    				if (val >= short.MinValue)  				{  					PackShort(0xd1' (ushort)val);  					return;  				}    				if (val >= int.MinValue)  				{  					PackInt(0xd2' (uint)val);  					return;  				}  				PackLong(0xd3' (ulong)val);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackString,The following statement contains a magic number: if (size < 32)  			{  				PackByte((byte)(0xa0 | size));  			}  			// TODO: Enable this code after all servers/clients  			// have been upgraded to handle 8 bit string length format.  			/*  			else if (size < 256)  			{  				PackByte(0xd9' (byte)size);  			}  			*/  			else if (size < 65536)  			{  				PackShort(0xda' (ushort)size);  			}  			else  			{  				PackInt(0xdb' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackString,The following statement contains a magic number: if (size < 32)  			{  				PackByte((byte)(0xa0 | size));  			}  			// TODO: Enable this code after all servers/clients  			// have been upgraded to handle 8 bit string length format.  			/*  			else if (size < 256)  			{  				PackByte(0xd9' (byte)size);  			}  			*/  			else if (size < 65536)  			{  				PackShort(0xda' (ushort)size);  			}  			else  			{  				PackInt(0xdb' (uint)size);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackDouble,The following statement contains a magic number: if (offset + 9 > buffer.Length)  			{  				Resize(9);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackDouble,The following statement contains a magic number: if (offset + 9 > buffer.Length)  			{  				Resize(9);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackFloat,The following statement contains a magic number: if (offset + 5 > buffer.Length)  			{  				Resize(5);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackFloat,The following statement contains a magic number: if (offset + 5 > buffer.Length)  			{  				Resize(5);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: if (offset + 9 > buffer.Length)  			{  				Resize(9);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: if (offset + 9 > buffer.Length)  			{  				Resize(9);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackLong,The following statement contains a magic number: offset += 8;
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: if (offset + 5 > buffer.Length)  			{  				Resize(5);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: if (offset + 5 > buffer.Length)  			{  				Resize(5);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackInt,The following statement contains a magic number: offset += 4;
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: if (offset + 3 > buffer.Length)  			{  				Resize(3);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: if (offset + 3 > buffer.Length)  			{  				Resize(3);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackShort,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: if (offset + 2 > buffer.Length)  			{  				Resize(2);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: if (offset + 2 > buffer.Length)  			{  				Resize(2);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackRawShort,The following statement contains a magic number: offset += 2;
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackByte,The following statement contains a magic number: if (offset + 2 > buffer.Length)  			{  				Resize(2);  			}
Magic Number,Aerospike.Client,Packer,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Packer.cs,PackByte,The following statement contains a magic number: if (offset + 2 > buffer.Length)  			{  				Resize(2);  			}
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,RandomShift,The following statement contains a magic number: byte[] buffer = new byte[sizeof(UInt64) * 2];
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: while (i < len)  			{  				ulong r = NextLong();  				int n = Math.Min(len - i' 8);    				for (int j = 0; j < n; j++)  				{  					bytes[i++] = (byte)r;  					r >>= 8;  				}  			}
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,NextBytes,The following statement contains a magic number: while (i < len)  			{  				ulong r = NextLong();  				int n = Math.Min(len - i' 8);    				for (int j = 0; j < n; j++)  				{  					bytes[i++] = (byte)r;  					r >>= 8;  				}  			}
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: s1 ^= s1 << 23;
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: seed1 = (s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5));
Magic Number,Aerospike.Client,RandomShift,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\RandomShift.cs,NextLong,The following statement contains a magic number: seed1 = (s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5));
Magic Number,Aerospike.Client,ThreadLocalData,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\ThreadLocalData.cs,GetBuffer,The following statement contains a magic number: if (BufferThreadLocal == null)  			{  				BufferThreadLocal = new byte[8192];  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if ((type & 0xf0) == 0x90)  			{  				count = type & 0x0f;  			}  			else if (type == 0xdc)  			{  				count = ByteUtil.BytesToShort(buffer' offset);  				offset += 2;  			}  			else if (type == 0xdd)  			{  				count = ByteUtil.BytesToInt(buffer' offset);  				offset += 4;  			}  			else  			{  				return new List<object>(0);  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackList,The following statement contains a magic number: if ((type & 0xf0) == 0x90)  			{  				count = type & 0x0f;  			}  			else if (type == 0xdc)  			{  				count = ByteUtil.BytesToShort(buffer' offset);  				offset += 2;  			}  			else if (type == 0xdd)  			{  				count = ByteUtil.BytesToInt(buffer' offset);  				offset += 4;  			}  			else  			{  				return new List<object>(0);  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if ((type & 0xf0) == 0x80)  			{  				count = type & 0x0f;  			}  			else if (type == 0xde)  			{  				count = ByteUtil.BytesToShort(buffer' offset);  				offset += 2;  			}  			else if (type == 0xdf)  			{  				count = ByteUtil.BytesToInt(buffer' offset);  				offset += 4;  			}  			else  			{  				return new Dictionary<object' object>(0);  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackMap,The following statement contains a magic number: if ((type & 0xf0) == 0x80)  			{  				count = type & 0x0f;  			}  			else if (type == 0xde)  			{  				count = ByteUtil.BytesToShort(buffer' offset);  				offset += 2;  			}  			else if (type == 0xdf)  			{  				count = ByteUtil.BytesToInt(buffer' offset);  				offset += 4;  			}  			else  			{  				return new Dictionary<object' object>(0);  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,CreateMap,The following statement contains a magic number: if (type == 0xc7)  			{  				int extensionType = buffer[offset + 1] & 0xff;    				if (extensionType == 0)  				{  					int mapBits = buffer[offset + 2] & 0xff;    					// Extension is a map type.  Determine which one.  					if ((mapBits & (0x04 | 0x08)) != 0)  					{  						// Index/rank range result where order needs to be preserved.  						return null;  					}  					else if ((mapBits & 0x01) != 0)  					{  						// Sorted map  						return new SortedDictionary<object' object>();  					}  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Unpacker,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Unpacker.cs,UnpackObject,The following statement contains a magic number: switch (type)  			{  				case 0xc0: // nil  				{  					return null;  				}    				case 0xc3: // boolean true  				{  					return true;  				}    				case 0xc2: // boolean false  				{  					return false;  				}    				case 0xca: // float  				{  					float val = ByteUtil.BytesToFloat(buffer' offset);  					offset += 4;  					return val;  				}    				case 0xcb: // double  				{  					double val = ByteUtil.BytesToDouble(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xd0: // signed 8 bit integer  				{  					return (long)(sbyte)(buffer[offset++]);  				}  				  				case 0xcc: // unsigned 8 bit integer  				{  					return (long)(buffer[offset++]);  				}    				case 0xd1: // signed 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)(short)val;  				}    				case 0xcd: // unsigned 16 bit integer  				{  					int val = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return (long)val;  				}    				case 0xd2: // signed 32 bit integer  				{  					int val = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xce: // unsigned 32 bit integer  				{  					uint val = ByteUtil.BytesToUInt(buffer' offset);  					offset += 4;  					return (long)val;  				}    				case 0xd3: // signed 64 bit integer  				{  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xcf: // unsigned 64 bit integer  				{  					// The contract is to always return long.    					// The caller can always cast back to ulong.  					long val = ByteUtil.BytesToLong(buffer' offset);  					offset += 8;  					return val;  				}    				case 0xc4:  				case 0xd9: // string raw bytes with 8 bit header  				{  					int count = buffer[offset++];  					return UnpackBlob(count);  				}    				case 0xc5:  				case 0xda: // raw bytes with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackBlob(count);  				}    				case 0xc6:  				case 0xdb: // raw bytes with 32 bit header  				{  					// Array length is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackBlob(count);  				}    				case 0xdc: // list with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackList(count);  				}    				case 0xdd: // list with 32 bit header  				{  					// List size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackList(count);  				}    				case 0xde: // map with 16 bit header  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += 2;  					return UnpackMap(count);  				}    				case 0xdf: // map with 32 bit header  				{  					// Map size is restricted to positive int values (0 - int.MAX_VALUE).  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += 4;  					return UnpackMap(count);  				}    				case 0xd4: // Skip over type extension with 1 byte  				{  					offset += 1 + 1;  					return null;  				}    				case 0xd5: // Skip over type extension with 2 bytes  				{  					offset += 1 + 2;  					return null;  				}    				case 0xd6: // Skip over type extension with 4 bytes  				{  					offset += 1 + 4;  					return null;  				}    				case 0xd7: // Skip over type extension with 8 bytes  				{  					offset += 1 + 8;  					return null;  				}    				case 0xd8: // Skip over type extension with 16 bytes  				{  					offset += 1 + 16;  					return null;  				}    				case 0xc7: // Skip over type extension with 8 bit header and bytes  				{  					int count = buffer[offset];  					offset += count + 1 + 1;  					return null;  				}    				case 0xc8: // Skip over type extension with 16 bit header and bytes  				{  					int count = ByteUtil.BytesToShort(buffer' offset);  					offset += count + 1 + 2;  					return null;  				}    				case 0xc9: // Skip over type extension with 32 bit header and bytes  				{  					int count = ByteUtil.BytesToInt(buffer' offset);  					offset += count + 1 + 4;  					return null;  				}  				  				default:  				{  					if ((type & 0xe0) == 0xa0) // raw bytes with 8 bit combined header  					{  						return UnpackBlob(type & 0x1f);  					}    					if ((type & 0xf0) == 0x80) // map with 8 bit combined header  					{  						return UnpackMap(type & 0x0f);  					}    					if ((type & 0xf0) == 0x90) // list with 8 bit combined header  					{  						return UnpackList(type & 0x0f);  					}    					if (type < 0x80) // 8 bit combined unsigned integer  					{  						return (long)type;  					}    					if (type >= 0xe0) // 8 bit combined signed integer  					{  						return (long)(type - 0xe0 - 32);  					}  					throw new IOException("Unknown unpack type: " + type);  				}  			}
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,MapToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,ListToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,ArrayToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,BytesToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,ObjectToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(200);
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: int byteLength = str.Length / 2;
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: if ((str.Length - (byteLength * 2)) == 1)  			{  				uneven = true;  				byteLength++;  			}
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: while (byteOffset >= 0)  			{  				bytes[byteOffset--] = (byte)((HexVal(str[strOffset]) << 4) + (HexVal(str[strOffset + 1])));  				strOffset += 2;  			}
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexStringToBytes,The following statement contains a magic number: while (byteOffset >= 0)  			{  				bytes[byteOffset--] = (byte)((HexVal(str[strOffset]) << 4) + (HexVal(str[strOffset + 1])));  				strOffset += 2;  			}
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));
Magic Number,Aerospike.Client,Util,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Util\Util.cs,HexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : (val < 97 ? 55 : 87));
Magic Number,Aerospike.Client,LuaAerospike,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level)  			{  				case 1:  					Log.LogMessage(Log.Level.WARN' message);  					break;  				case 2:  					Log.LogMessage(Log.Level.INFO' message);  					break;  				case 3:  				case 4:  					Log.LogMessage(Log.Level.DEBUG' message);  					break;  			}
Magic Number,Aerospike.Client,LuaAerospike,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level)  			{  				case 1:  					Log.LogMessage(Log.Level.WARN' message);  					break;  				case 2:  					Log.LogMessage(Log.Level.INFO' message);  					break;  				case 3:  				case 4:  					Log.LogMessage(Log.Level.DEBUG' message);  					break;  			}
Magic Number,Aerospike.Client,LuaAerospike,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following statement contains a magic number: switch (level)  			{  				case 1:  					Log.LogMessage(Log.Level.WARN' message);  					break;  				case 2:  					Log.LogMessage(Log.Level.INFO' message);  					break;  				case 3:  				case 4:  					Log.LogMessage(Log.Level.DEBUG' message);  					break;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt16,The following statement contains a magic number: try  			{  				int capacity = offset + 2;  				EnsureCapacity(capacity);  				ByteUtil.ShortToBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt16,The following statement contains a magic number: try  			{  				int capacity = offset + 2;  				EnsureCapacity(capacity);  				ByteUtil.ShortToLittleBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt32,The following statement contains a magic number: try  			{  				int capacity = offset + 4;  				EnsureCapacity(capacity);  				ByteUtil.IntToBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt32,The following statement contains a magic number: try  			{  				int capacity = offset + 4;  				EnsureCapacity(capacity);  				ByteUtil.IntToLittleBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetBigInt64,The following statement contains a magic number: try  			{  				int capacity = offset + 8;  				EnsureCapacity(capacity);  				ByteUtil.LongToBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetLittleInt64,The following statement contains a magic number: try  			{  				int capacity = offset + 8;  				EnsureCapacity(capacity);  				ByteUtil.LongToLittleBytes(value' bytes' offset);  				ResetSize(capacity);  				return true;  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,SetVarInt,The following statement contains a magic number: EnsureCapacity(offset + 5);
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetIntBig,The following statement contains a magic number: if (offset < 0 || offset + 4 > this.length)  			{  				return 0;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetIntLittle,The following statement contains a magic number: if (offset < 0 || offset + 4 > this.length)  			{  				return 0;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetLongBig,The following statement contains a magic number: if (offset < 0 || offset + 8 > this.length)  			{  				return 0;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,GetLongLittle,The following statement contains a magic number: if (offset < 0 || offset + 8 > this.length)  			{  				return 0;  			}
Magic Number,Aerospike.Client,LuaBytes,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaBytes.cs,EnsureCapacity,The following statement contains a magic number: if (capacity > bytes.Length)  			{  				int len = bytes.Length * 2;    				if (capacity > len)  				{  					len = capacity;  				}    				byte[] target = new byte[len];  				Array.Copy(bytes' 0' target' 0' length);  				bytes = target;  			}
Magic Number,Aerospike.Client,LuaInstance,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,FindFile,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,Aerospike.Client,LuaInstance,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,BytesToLua,The following statement contains a magic number: switch (type) {  			case ParticleType.STRING:  				return ByteUtil.Utf8ToString(buf' offset' len);  			  			case ParticleType.INTEGER:  				return ByteUtil.BytesToNumber(buf' offset' len);    			case ParticleType.DOUBLE:  				return ByteUtil.BytesToDouble(buf' offset);    			case ParticleType.BLOB:  				byte[] dest = new byte[len];  				Array.Copy(buf' offset' dest' 0' len);  				return new LuaBytes(dest);    			case ParticleType.CSHARP_BLOB:  				return ByteUtil.BytesToObject(buf' offset' len);  			  			case ParticleType.LIST:  			{  				Unpacker unpacker = new Unpacker(buf' offset' len' true);  				return unpacker.UnpackList();  			}    			case ParticleType.MAP:   			{  				Unpacker unpacker = new Unpacker(buf' offset' len' true);  				return unpacker.UnpackMap();  			}    			case ParticleType.GEOJSON:  			{  				// skip the flags  				int ncells = ByteUtil.BytesToShort(buf' offset + 1);  				int hdrsz = 1 + 2 + (ncells * 8);  				return new LuaGeoJSON(ByteUtil.Utf8ToString(buf' offset + hdrsz' len - hdrsz));  			}    			default:  				return null;  			}
Magic Number,Aerospike.Client,LuaInstance,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaInstance.cs,BytesToLua,The following statement contains a magic number: switch (type) {  			case ParticleType.STRING:  				return ByteUtil.Utf8ToString(buf' offset' len);  			  			case ParticleType.INTEGER:  				return ByteUtil.BytesToNumber(buf' offset' len);    			case ParticleType.DOUBLE:  				return ByteUtil.BytesToDouble(buf' offset);    			case ParticleType.BLOB:  				byte[] dest = new byte[len];  				Array.Copy(buf' offset' dest' 0' len);  				return new LuaBytes(dest);    			case ParticleType.CSHARP_BLOB:  				return ByteUtil.BytesToObject(buf' offset' len);  			  			case ParticleType.LIST:  			{  				Unpacker unpacker = new Unpacker(buf' offset' len' true);  				return unpacker.UnpackList();  			}    			case ParticleType.MAP:   			{  				Unpacker unpacker = new Unpacker(buf' offset' len' true);  				return unpacker.UnpackMap();  			}    			case ParticleType.GEOJSON:  			{  				// skip the flags  				int ncells = ByteUtil.BytesToShort(buf' offset + 1);  				int hdrsz = 1 + 2 + (ncells * 8);  				return new LuaGeoJSON(ByteUtil.Utf8ToString(buf' offset + hdrsz' len - hdrsz));  			}    			default:  				return null;  			}
Magic Number,Aerospike.Client,LuaList,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaList.cs,LuaList,The following statement contains a magic number: list = new List<object>(32);
Magic Number,Aerospike.Client,LuaMap,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaMap.cs,LuaMap,The following statement contains a magic number: map = new Dictionary<object' object>(32);
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[2] == '$')                  startingOffset = 3;              else              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                      throw new SaltParseException("Invalid salt revision");                  startingOffset = 4;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[2] == '$')                  startingOffset = 3;              else              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                      throw new SaltParseException("Invalid salt revision");                  startingOffset = 4;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[2] == '$')                  startingOffset = 3;              else              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                      throw new SaltParseException("Invalid salt revision");                  startingOffset = 4;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[2] == '$')                  startingOffset = 3;              else              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                      throw new SaltParseException("Invalid salt revision");                  startingOffset = 4;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[2] == '$')                  startingOffset = 3;              else              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                      throw new SaltParseException("Invalid salt revision");                  startingOffset = 4;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[startingOffset + 2] > '$')                  throw new SaltParseException("Missing salt rounds");
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: int logRounds = Convert.ToInt32(salt.Substring(startingOffset' 2));
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: string extractedSalt = salt.Substring(startingOffset + 3' 22);
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: string extractedSalt = salt.Substring(startingOffset + 3' 22);
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,HashPassword,The following statement contains a magic number: result.Append(EncodeBase64(hashed' (_BfCryptCiphertext.Length * 4) - 1));
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The following statement contains a magic number: if (workFactor < 4 || workFactor > 31)                  throw new ArgumentOutOfRangeException("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)");
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,GenerateSalt,The following statement contains a magic number: if (workFactor < 4 || workFactor > 31)                  throw new ArgumentOutOfRangeException("workFactor"' workFactor' "The work factor must be between 4 and 31 (inclusive)");
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length)              {                  int c1 = byteArray[off++] & 0xff;                  rs.Append(_Base64Code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  int c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append(_Base64Code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append(_Base64Code[c1 & 0x3f]);                  rs.Append(_Base64Code[c2 & 0x3f]);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length)              {                  int c1 = byteArray[off++] & 0xff;                  rs.Append(_Base64Code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  int c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append(_Base64Code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append(_Base64Code[c1 & 0x3f]);                  rs.Append(_Base64Code[c2 & 0x3f]);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length)              {                  int c1 = byteArray[off++] & 0xff;                  rs.Append(_Base64Code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  int c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append(_Base64Code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append(_Base64Code[c1 & 0x3f]);                  rs.Append(_Base64Code[c2 & 0x3f]);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length)              {                  int c1 = byteArray[off++] & 0xff;                  rs.Append(_Base64Code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  int c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append(_Base64Code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append(_Base64Code[c1 & 0x3f]);                  rs.Append(_Base64Code[c2 & 0x3f]);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EncodeBase64,The following statement contains a magic number: while (off < length)              {                  int c1 = byteArray[off++] & 0xff;                  rs.Append(_Base64Code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  int c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append(_Base64Code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (off >= length)                  {                      rs.Append(_Base64Code[c1 & 0x3f]);                      break;                  }                  c2 = byteArray[off++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append(_Base64Code[c1 & 0x3f]);                  rs.Append(_Base64Code[c2 & 0x3f]);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes)              {                  int c1 = Char64(encodedstring[position++]);                  int c2 = Char64(encodedstring[position++]);                  if (c1 == -1 || c2 == -1)                      break;                    rs.Append((char)((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c3 = Char64(encodedstring[position++]);                  if (c3 == -1)                      break;                    rs.Append((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c4 = Char64(encodedstring[position++]);                  rs.Append((char)(((c3 & 0x03) << 6) | c4));                    ++outputLength;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes)              {                  int c1 = Char64(encodedstring[position++]);                  int c2 = Char64(encodedstring[position++]);                  if (c1 == -1 || c2 == -1)                      break;                    rs.Append((char)((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c3 = Char64(encodedstring[position++]);                  if (c3 == -1)                      break;                    rs.Append((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c4 = Char64(encodedstring[position++]);                  rs.Append((char)(((c3 & 0x03) << 6) | c4));                    ++outputLength;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes)              {                  int c1 = Char64(encodedstring[position++]);                  int c2 = Char64(encodedstring[position++]);                  if (c1 == -1 || c2 == -1)                      break;                    rs.Append((char)((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c3 = Char64(encodedstring[position++]);                  if (c3 == -1)                      break;                    rs.Append((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c4 = Char64(encodedstring[position++]);                  rs.Append((char)(((c3 & 0x03) << 6) | c4));                    ++outputLength;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes)              {                  int c1 = Char64(encodedstring[position++]);                  int c2 = Char64(encodedstring[position++]);                  if (c1 == -1 || c2 == -1)                      break;                    rs.Append((char)((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c3 = Char64(encodedstring[position++]);                  if (c3 == -1)                      break;                    rs.Append((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c4 = Char64(encodedstring[position++]);                  rs.Append((char)(((c3 & 0x03) << 6) | c4));                    ++outputLength;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,DecodeBase64,The following statement contains a magic number: while (position < sourceLength - 1 && outputLength < maximumBytes)              {                  int c1 = Char64(encodedstring[position++]);                  int c2 = Char64(encodedstring[position++]);                  if (c1 == -1 || c2 == -1)                      break;                    rs.Append((char)((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c3 = Char64(encodedstring[position++]);                  if (c3 == -1)                      break;                    rs.Append((char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++outputLength >= maximumBytes || position >= sourceLength)                      break;                    int c4 = Char64(encodedstring[position++]);                  rs.Append((char)(((c3 & 0x03) << 6) | c4));                    ++outputLength;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked              {                  for (round = 0; round <= BLOWFISH_NUM_ROUNDS - 2; )                  {                      // Feistel substitution on left word                      n = _S[(block >> 24) & 0xff];                      n += _S[0x100 | ((block >> 16) & 0xff)];                      n ^= _S[0x200 | ((block >> 8) & 0xff)];                      n += _S[0x300 | (block & 0xff)];                      r ^= n ^ _P[++round];                        // Feistel substitution on right word                      n = _S[(r >> 24) & 0xff];                      n += _S[0x100 | ((r >> 16) & 0xff)];                      n ^= _S[0x200 | ((r >> 8) & 0xff)];                      n += _S[0x300 | (r & 0xff)];                      block ^= n ^ _P[++round];                  }                  blockArray[offset] = r ^ _P[BLOWFISH_NUM_ROUNDS + 1];                  blockArray[offset + 1] = block;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  word = (word << 8) | (uint)(data[offset] & 0xff);                  offset = (offset + 1) % data.Length;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  word = (word << 8) | (uint)(data[offset] & 0xff);                  offset = (offset + 1) % data.Length;              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: for (i = 0; i < plen; i += 2)              {                  Encipher(lr' 0);                  _P[i] = lr[0];                  _P[i + 1] = lr[1];              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,Key,The following statement contains a magic number: for (i = 0; i < slen; i += 2)              {                  Encipher(lr' 0);                  _S[i] = lr[0];                  _S[i + 1] = lr[1];              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: for (i = 0; i < plen; i += 2)              {                  lr[0] ^= StreamToWord(saltBytes' ref saltOffset);                  lr[1] ^= StreamToWord(saltBytes' ref saltOffset);                  Encipher(lr' 0);                  _P[i] = lr[0];                  _P[i + 1] = lr[1];              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,EKSKey,The following statement contains a magic number: for (i = 0; i < slen; i += 2)              {                  lr[0] ^= StreamToWord(saltBytes' ref saltOffset);                  lr[1] ^= StreamToWord(saltBytes' ref saltOffset);                  Encipher(lr' 0);                  _S[i] = lr[0];                  _S[i + 1] = lr[1];              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)                  throw new ArgumentException("Bad number of rounds"' "logRounds");
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)                  throw new ArgumentException("Bad number of rounds"' "logRounds");
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  for (int j = 0; j < (clen >> 1); j++)                      Encipher(cdata' j << 1);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: byte[] ret = new byte[clen * 4];
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte)((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte)(cdata[i] & 0xff);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte)((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte)(cdata[i] & 0xff);              }
Magic Number,BCrypt.Net,BCrypt,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\BCrypt\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte)((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte)((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte)(cdata[i] & 0xff);              }
Missing Default,Aerospike.Client,AsyncMultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Async\AsyncMultiCommand.cs,ParseKey,The following switch statement is missing a default case: switch (fieldtype)  				{  					case FieldType.DIGEST_RIPE:  						digest = new byte[size];  						Array.Copy(dataBuffer' dataOffset' digest' 0' size);  						dataOffset += size;  						break;    					case FieldType.NAMESPACE:  						ns = ByteUtil.Utf8ToString(dataBuffer' dataOffset' size);  						dataOffset += size;  						break;    					case FieldType.TABLE:  						setName = ByteUtil.Utf8ToString(dataBuffer' dataOffset' size);  						dataOffset += size;  						break;    					case FieldType.KEY:  						int type = dataBuffer[dataOffset++];  						size--;  						userKey = ByteUtil.BytesToKeyValue(type' dataBuffer' dataOffset' size);  						dataOffset += size;  						break;  				}
Missing Default,Aerospike.Client,MapPolicy,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\CDT\MapPolicy.cs,MapPolicy,The following switch statement is missing a default case: switch (writeMode)  			{  				case MapWriteMode.UPDATE:  					itemCommand = MapBase.PUT;  					itemsCommand = MapBase.PUT_ITEMS;  					break;    				case MapWriteMode.UPDATE_ONLY:  					itemCommand = MapBase.REPLACE;  					itemsCommand = MapBase.REPLACE_ITEMS;  					break;    				case MapWriteMode.CREATE_ONLY:  					itemCommand = MapBase.ADD;  					itemsCommand = MapBase.ADD_ITEMS;  					break;  			}
Missing Default,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following switch statement is missing a default case: switch (policy.recordExistsAction)  			{  			case RecordExistsAction.UPDATE:  				break;  			case RecordExistsAction.UPDATE_ONLY:  				infoAttr |= Command.INFO3_UPDATE_ONLY;  				break;  			case RecordExistsAction.REPLACE:  				infoAttr |= Command.INFO3_CREATE_OR_REPLACE;  				break;  			case RecordExistsAction.REPLACE_ONLY:  				infoAttr |= Command.INFO3_REPLACE_ONLY;  				break;  			case RecordExistsAction.CREATE_ONLY:  				writeAttr |= Command.INFO2_CREATE_ONLY;  				break;  			}
Missing Default,Aerospike.Client,Command,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\Command.cs,WriteHeader,The following switch statement is missing a default case: switch (policy.generationPolicy)  			{  			case GenerationPolicy.NONE:  				break;  			case GenerationPolicy.EXPECT_GEN_EQUAL:  				generation = policy.generation;  				writeAttr |= Command.INFO2_GENERATION;  				break;  			case GenerationPolicy.EXPECT_GEN_GT:  				generation = policy.generation;  				writeAttr |= Command.INFO2_GENERATION_GT;  				break;  			}
Missing Default,Aerospike.Client,MultiCommand,C:\repos\aerospike_aerospike-client-csharp\Core\AerospikeClient\Command\MultiCommand.cs,ParseKey,The following switch statement is missing a default case: switch (fieldtype)   				{  				case FieldType.DIGEST_RIPE:  					digest = new byte[size];  					Array.Copy(dataBuffer' 1' digest' 0' size);  					break;  			  				case FieldType.NAMESPACE:  					ns = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;  				  				case FieldType.TABLE:  					setName = ByteUtil.Utf8ToString(dataBuffer' 1' size);  					break;    				case FieldType.KEY:  					userKey = ByteUtil.BytesToKeyValue(dataBuffer[1]' dataBuffer' 2' size-1);  					break;  				}
Missing Default,Aerospike.Client,LuaAerospike,C:\repos\aerospike_aerospike-client-csharp\Framework\AerospikeClient\Lua\LuaAerospike.cs,log,The following switch statement is missing a default case: switch (level)  			{  				case 1:  					Log.LogMessage(Log.Level.WARN' message);  					break;  				case 2:  					Log.LogMessage(Log.Level.INFO' message);  					break;  				case 3:  				case 4:  					Log.LogMessage(Log.Level.DEBUG' message);  					break;  			}
