Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,Cyclomatic complexity of the method is 13
Long Statement,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnDraw,The length of the statement  "                    //Game.PrintChat("{0} ({1}): {2}"' obj.BaseSkinName' obj.BoundingRadius' string.Join(" | "' obj.Buffs.Select(b => b.DisplayName))); " is 131.
Long Statement,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnDraw,The length of the statement  "                    Render.Circle.DrawCircle(entry.Key.Position' entry.Value.BoundingRadius' (Config.Enabled && entry.Value.MenuState.Value) ? Color.White : Color.Red); " is 148.
Long Statement,Avoid,UpdateChecker,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\UpdateChecker.cs,Initialize,The length of the statement  "                        var data = await client.DownloadStringTaskAsync(string.Format("https://raw.github.com/{0}/Properties/AssemblyInfo.cs"' path)); " is 126.
Complex Conditional,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnPropertyChange,The conditional expression  "sender.Name == "Noxious Trap" &&                      args.Property == "mPercentBubbleRadiusMod" &&                      args.OldValue == -1 &&                      args.NewValue == 0"  is complex.
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following statement contains a magic number: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnDraw,The following statement contains a magic number: !obj.IsMe && ObjectManager.Player.Distance(obj.Position' true) < 400 * 400
Magic Number,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnDraw,The following statement contains a magic number: !obj.IsMe && ObjectManager.Player.Distance(obj.Position' true) < 400 * 400
Magic Number,Avoid,Extensions,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Extensions.cs,ToCell,The following statement contains a magic number: var nav = new Vector2(position.X / 50 + 1' position.Y / 50 - 17);
Magic Number,Avoid,Extensions,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Extensions.cs,ToCell,The following statement contains a magic number: var nav = new Vector2(position.X / 50 + 1' position.Y / 50 - 17);
Magic Number,Avoid,Extensions,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Extensions.cs,ToCell,The following statement contains a magic number: var nav = new Vector2(position.X / 50 + 1' position.Y / 50 - 17);
Magic Number,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following statement contains a magic number: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
Magic Number,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following statement contains a magic number: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
Magic Number,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following statement contains a magic number: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
Magic Number,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following statement contains a magic number: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
Magic Number,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following statement contains a magic number: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
Magic Number,Avoid,UpdateChecker,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\UpdateChecker.cs,Initialize,The following statement contains a magic number: new Thread(async () =>                  {                      try                      {                          var data = await client.DownloadStringTaskAsync(string.Format("https://raw.github.com/{0}/Properties/AssemblyInfo.cs"' path));                                                var version =                              System.Version.Parse(new Regex("AssemblyFileVersion\\((\"(.+?)\")\\)").Match(data).Groups[1].Value.Replace(                                  "\""' ""));                            // Compare both versions                          var assemblyName = Assembly.GetExecutingAssembly().GetName();                          if (version > assemblyName.Version)                          {                              Utility.DelayAction.Add(5000' () =>                              {                                  Game.PrintChat("[{0}] Update available: {1} => {2}!"'                                      assemblyName.Name'                                      assemblyName.Version'                                      version);                              });                          }                      }                      catch (Exception e)                      {                          Console.WriteLine("An error occured while trying to check for an update:\n{0}"' e.Message);                      }                  }).Start();
Missing Default,Avoid,Avoid,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\Avoid.cs,OnIssueOrder,The following switch statement is missing a default case: switch (args.Order)                  {                      case GameObjectOrder.AttackTo:                      case GameObjectOrder.MoveTo:                            // Skip everything if we are stuck                          if (_avoidableObjects.Any(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      Geometry.CircleCircleIntersection(                                          ObjectManager.Player.ServerPosition.To2D()'                                          o.Key.Position.To2D()'                                          ObjectManager.Player.BoundingRadius'                                          o.Value.BoundingRadius).Length > 1))                          {                              return;                          }                            var path = ObjectManager.Player.GetPath(args.TargetPosition);                          for (int i = 1; i < path.Length; i++)                          {                              var start = path[i - 1].To2D();                              var end = path[i].To2D();                                                                 // Minimalize the amount of avoidable objects to loop through                              var distanceSqr = start.Distance(end' true);                              var entries = _avoidableObjects.Where(                                  o =>                                      o.Value.MenuState.Value &&                                      o.Value.ShouldBeAvoided(o.Key) &&                                      start.Distance(o.Key.Position' true) < distanceSqr &&                                      end.Distance(o.Key.Position' true) < distanceSqr)                                          .OrderBy(                                              o =>                                                  ObjectManager.Player.Distance(o.Key.Position.To2D()' true));                                foreach (var entry in entries)                              {                                  var avoidPosition = entry.Key.Position.To2D();                                  var length = start.Distance(end) + ObjectManager.Player.BoundingRadius;                                  for (int j = 25; j < length; j += 25)                                  {                                      // Get the next check point                                      var checkPoint = start.Extend(end' j);                                        // Calculate intersection points                                      var intersections = Geometry.CircleCircleIntersection(                                          checkPoint'                                          avoidPosition'                                          ObjectManager.Player.BoundingRadius'                                          entry.Value.BoundingRadius);                                        if (intersections.Length > 1)                                      {                                          // Update NavCells                                          var cells = new Dictionary<NavMeshCell' CollisionFlags>();                                          var step = 2 * Math.PI / 8;                                          for (var theta = 0d; theta < 2 * Math.PI + step; theta += step)                                          {                                              var pos = NavMesh.WorldToGrid((float)(avoidPosition.X + entry.Value.BoundingRadius * Math.Cos(theta))'                                                                            (float)(avoidPosition.Y - entry.Value.BoundingRadius * Math.Sin(theta)));                                                                                            var cell = pos.ToCell();                                              if (!cells.Keys.Any(o => o.GridX == cell.GridX && o.GridY == cell.GridY))                                              {                                                  cells.Add(cell' cell.CollFlags);                                                  cell.CollFlags = CollisionFlags.Wall;                                              }                                          }                                            // Get new path                                          var newPath = ObjectManager.Player.GetPath(args.TargetPosition);                                            // Revert old flags                                          foreach (var cell in cells)                                          {                                              cell.Key.CollFlags = cell.Value;                                          }                                            // Get new end                                          for (var k = 0; k < newPath.Length; k++)                                          {                                              if (newPath[k].To2D().Distance(start' true) < 10 * 10 &&                                                  k + 1 < newPath.Length)                                              {                                                  // Move to new end and cancel the current order                                                  ObjectManager.Player.IssueOrder(args.Order' newPath[k + 1]' false);                                                  args.Process = false;                                                  return;                                              }                                          }                                      }                                  }                              }                          }                            break;                  }
Missing Default,Avoid,ObjectDatabase,D:\research\architectureSmells\repos\Hellsing_LeagueSharp\Avoid\ObjectDatabase.cs,ObjectDatabase,The following switch statement is missing a default case: switch (enemy.ChampionName)                  {                      case "Caitlyn":                            // W                          _avoidObjects.Add(new AvoidObject("Caitlyn - Yordle Snap Trap (W)"' "caitlyntrap"' 65' "CaitlynYordleTrap"));                          break;                        case "Jinx":                            // E                          _avoidObjects.Add(new AvoidObject("Jinx - Flame Chompers! (E)"' "jinxmine"' 75' "JinxEMine"));                          break;                        case "Nidalee":                            // W                          _avoidObjects.Add(new AvoidObject("Nidalee - Bushwhack (W)"' "Nidalee_Spear"' 65' ""));                          break;                        case "Teemo":                            // R                          _avoidObjects.Add(new AvoidObject("Teemo - Noxious Trap (R)"' "teemomushroom"' 75' "Noxious Trap"));                          break;                        case "Ziggs":                            // E  #if DEBUG                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_green.troy"' 50));  #else                          _avoidObjects.Add(new AvoidObject("Ziggs - Hexplosive Minefield (E)"' "ZiggsE_red.troy"' 50));  #endif                          break;                  }
