Implementation smell,Namespace,Class,File,Method,Description
Long Method,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The method has 143 lines of code.
Long Method,KalistaResurrection.Modes,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\WaveClear.cs,Execute,The method has 116 lines of code.
Complex Method,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,Cyclomatic complexity of the method is 18
Complex Method,KalistaResurrection.Modes,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\WaveClear.cs,Execute,Cyclomatic complexity of the method is 20
Complex Method,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,Cyclomatic complexity of the method is 8
Long Identifier,KalistaResurrection,Damages,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Damages.cs,,The length of the parameter rawRendDamagePerSpearMultiplier is 31.
Long Statement,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The length of the statement  "                    RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200); " is 129.
Long Statement,KalistaResurrection,DamageIndicator,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\DamageIndicator.cs,Drawing_OnDraw,The length of the statement  "                    var startPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + damagePercentage * BAR_WIDTH)' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5); " is 150.
Long Statement,KalistaResurrection,DamageIndicator,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\DamageIndicator.cs,Drawing_OnDraw,The length of the statement  "                    var endPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + currentHealthPercentage * BAR_WIDTH) + 1' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5); " is 159.
Long Statement,KalistaResurrection,Damages,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Damages.cs,GetRendDamage,The length of the statement  "            return ((float)Player.CalcDamage(target' Damage.DamageType.Physical' GetRawRendDamage(target' customStacks)) - 20) * 0.98f; " is 123.
Long Statement,KalistaResurrection,Damages,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Damages.cs,GetRawRendDamage,The length of the statement  "                return (rawRendDamage[SpellManager.E.Level - 1] + rawRendDamageMultiplier[SpellManager.E.Level - 1] * Player.TotalAttackDamage()) + // Base damage " is 146.
Long Statement,KalistaResurrection,Damages,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Damages.cs,GetRawRendDamage,The length of the statement  "                       (rawRendDamagePerSpear[SpellManager.E.Level - 1] + rawRendDamagePerSpearMultiplier[SpellManager.E.Level - 1] * Player.TotalAttackDamage()); // Damage per spear " is 159.
Long Statement,KalistaResurrection,ModeLogic,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\ModeLogic.cs,Initialize,The length of the statement  "                    Console.WriteLine("Failed to create new instance of {0}' Namespace: {1}!\nException: {2}\nTrace:\n{3}"' type.Name' type.Namespace' e.Message' e.StackTrace); " is 156.
Long Statement,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The length of the statement  "                    if ((!(sender is Obj_AI_Hero) || args.SData.IsAutoAttack()) && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) " is 131.
Long Statement,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The length of the statement  "                        _incomingDamage.Add(SoulBound.ServerPosition.Distance(sender.ServerPosition) / args.SData.MissileSpeed + Game.Time' (float)sender.GetAutoAttackDamage(SoulBound)); " is 162.
Long Statement,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The length of the statement  "                            if (slot == attacker.GetSpellSlot("SummonerDot") && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) " is 120.
Long Statement,KalistaResurrection,UpdateChecker,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\UpdateChecker.cs,Initialize,The length of the statement  "                        var data = await client.DownloadStringTaskAsync(string.Format("https://raw.github.com/{0}/Properties/AssemblyInfo.cs"' path)); " is 126.
Long Statement,KalistaResurrection,VectorHelper,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\VectorHelper.cs,GetDashObjects,The length of the statement  "            var apexPoint = Player.ServerPosition.To2D() + (Player.ServerPosition.To2D() - Game.CursorPos.To2D()).Normalized() * Orbwalking.GetRealAutoAttackRange(Player); " is 159.
Long Statement,KalistaResurrection,VectorHelper,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\VectorHelper.cs,GetDashObjects,The length of the statement  "            return objects.Where(o => VectorHelper.IsLyingInCone(o.ServerPosition.To2D()' apexPoint' Player.ServerPosition.To2D()' Math.PI)).OrderBy(o => o.Distance(apexPoint' true)).ToList(); " is 180.
Long Statement,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,OnDraw,The length of the statement  "                Render.Circle.DrawCircle(FleePosition' 50' IsJumpPossible ? Color.Green : SpellManager.Q.IsReady() ? Color.Red : Color.Teal' 10); " is 129.
Long Statement,KalistaResurrection.Modes,PermaActive,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\PermaActive.cs,Execute,The length of the statement  "                    ObjectManager.Get<Obj_AI_Minion>().Any(m => m.IsValidTarget(E.Range) && (m.BaseSkinName.Contains("MinionSiege") || m.BaseSkinName.Contains("Dragon") || m.BaseSkinName.Contains("Baron")) && m.IsRendKillable())) " is 209.
Long Statement,KalistaResurrection.Modes,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\WaveClear.cs,Execute,The length of the statement  "                            var colliding = LeagueSharp.Common.Collision.GetCollision(new List<Vector3>() { Player.ServerPosition.Extend(Prediction.GetPrediction(input).UnitPosition' Q.Range) }' input) " is 173.
Long Statement,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The length of the statement  "            var target = TargetSelector.GetTarget((Settings.UseQ && Q.IsReady()) ? Q.Range : (E.Range * 1.2f)' TargetSelector.DamageType.Physical); " is 135.
Long Statement,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The length of the statement  "                if (Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff()) " is 129.
Long Statement,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The length of the statement  "                            // Check if a minion can die with one AA and E. Also' the AA minion has be be behind the player direction for a further leap " is 124.
Long Statement,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The length of the statement  "                            var minion = VectorHelper.GetDashObjects(minions).Find(m => m.Health > Player.GetAutoAttackDamage(m) && m.Health < Player.GetAutoAttackDamage(m) + Damages.GetRendDamage(m' (m.HasRendBuff() ? m.GetRendBuff().Count + 1 : 1))); " is 224.
Complex Conditional,KalistaResurrection,Extensions,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Extensions.cs,HasUndyingBuff,The conditional expression  "target.ChampionName == "Tryndamere" &&                  target.Buffs.Any(b => b.Caster.NetworkId == target.NetworkId && b.IsValidBuff() && b.DisplayName == "Undying Rage")"  is complex.
Complex Conditional,KalistaResurrection,Extensions,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Extensions.cs,HasUndyingBuff,The conditional expression  "HeroManager.Allies.Any(o =>                      !o.IsMe &&                      o.Buffs.Any(b => b.Caster.NetworkId == target.NetworkId && b.IsValidBuff() && b.DisplayName == "PoppyDITarget"))"  is complex.
Complex Conditional,KalistaResurrection,ItemManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\ItemManager.cs,UseBotrk,The conditional expression  "Settings.UseBotrk && BOTRK.IsReady() && target.IsValidTarget(BOTRK.Range) &&                  player.Health + player.GetItemDamage(target' Damage.DamageItems.Botrk) < player.MaxHealth"  is complex.
Complex Conditional,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The conditional expression  "(!(sender is Obj_AI_Hero) || args.SData.IsAutoAttack()) && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId"  is complex.
Complex Conditional,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The conditional expression  "slot.HasFlag(SpellSlot.Q | SpellSlot.W | SpellSlot.E | SpellSlot.R) &&                                  ((args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) ||                                  args.End.Distance(SoulBound.ServerPosition) < Math.Pow(args.SData.LineWidth' 2))"  is complex.
Complex Conditional,KalistaResurrection.Modes,PermaActive,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\PermaActive.cs,Execute,The conditional expression  "Settings.UseEBig &&                      ObjectManager.Get<Obj_AI_Minion>().Any(m => m.IsValidTarget(E.Range) && (m.BaseSkinName.Contains("MinionSiege") || m.BaseSkinName.Contains("Dragon") || m.BaseSkinName.Contains("Baron")) && m.IsRendKillable())"  is complex.
Complex Conditional,KalistaResurrection.Modes,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\WaveClear.cs,Execute,The conditional expression  "!(Settings.UseQ && Q.IsReady()) &&                  !(Settings.UseE && E.IsReady())"  is complex.
Complex Conditional,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The conditional expression  "!(Settings.UseQ && Q.IsReady()) && !(Settings.UseE && E.IsReady())"  is complex.
Complex Conditional,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The conditional expression  "Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff()"  is complex.
Magic Number,KalistaResurrection,Keys,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Combo == null)                  {                      // Combo                      Config.Combo.Menu.AddSeparator();                      Combo = Config.Combo.Menu.AddLinkedKeyBind("Active"' 32' KeyBindType.Press);                        // Harass                      Config.Harass.Menu.AddSeparator();                      Harass = Config.Harass.Menu.AddLinkedKeyBind("Active"' 'C'' KeyBindType.Press);                        // WaveClear                      Config.WaveClear.Menu.AddSeparator();                      WaveClear = Config.WaveClear.Menu.AddLinkedKeyBind("Active"' 'V'' KeyBindType.Press);                        // JungleClear                      Config.JungleClear.Menu.AddSeparator();                      JungleClear = Config.JungleClear.Menu.AddLinkedKeyBind("Active"' 'V'' KeyBindType.Press);                        // Flee                      Config.Flee.Menu.AddSeparator();                      Flee = Config.Flee.Menu.AddLinkedKeyBind("Active"' 'T'' KeyBindType.Press);                        ActiveModeLinks = new Dictionary<KeyBindLink' ActiveModes>()                      {                          { Combo' ActiveModes.Combo }'                          { Harass' ActiveModes.Harass }'                          { WaveClear' ActiveModes.WaveClear }'                          { JungleClear' ActiveModes.JungleClear }'                          { Flee' ActiveModes.Flee }'                      };                      AllKeys = ActiveModeLinks.Keys.Select(o => o.Value.Key).ToArray();                  }
Magic Number,KalistaResurrection,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Combo");                        _useQ = Menu.AddLinkedBool("Use Q");                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Min stacks to use E"' 5' 1' 20);                      Menu.AddSeparator();                      _useItems = Menu.AddLinkedBool("Use items");                  }
Magic Number,KalistaResurrection,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Combo");                        _useQ = Menu.AddLinkedBool("Use Q");                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Min stacks to use E"' 5' 1' 20);                      Menu.AddSeparator();                      _useItems = Menu.AddLinkedBool("Use items");                  }
Magic Number,KalistaResurrection,Harass,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Harass");                        _useQ = Menu.AddLinkedBool("Use Q");                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("WaveClear");                        _useQ = Menu.AddLinkedBool("Use Q");                      _numQ = Menu.AddLinkedSlider("Minion kill number for Q"' 3' 1' 10);                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Minion kill number for E"' 2' 1' 10);                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("WaveClear");                        _useQ = Menu.AddLinkedBool("Use Q");                      _numQ = Menu.AddLinkedSlider("Minion kill number for Q"' 3' 1' 10);                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Minion kill number for E"' 2' 1' 10);                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("WaveClear");                        _useQ = Menu.AddLinkedBool("Use Q");                      _numQ = Menu.AddLinkedSlider("Minion kill number for Q"' 3' 1' 10);                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Minion kill number for E"' 2' 1' 10);                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("WaveClear");                        _useQ = Menu.AddLinkedBool("Use Q");                      _numQ = Menu.AddLinkedSlider("Minion kill number for Q"' 3' 1' 10);                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Minion kill number for E"' 2' 1' 10);                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("WaveClear");                        _useQ = Menu.AddLinkedBool("Use Q");                      _numQ = Menu.AddLinkedSlider("Minion kill number for Q"' 3' 1' 10);                      _useE = Menu.AddLinkedBool("Use E");                      _numE = Menu.AddLinkedSlider("Minion kill number for E"' 2' 1' 10);                      Menu.AddSeparator();                      _mana = Menu.AddLinkedSlider("Minimum mana in %"' 30);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Drawing,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Config.cs,Initialize,The following statement contains a magic number: if (Menu == null)                  {                      Menu = Config.Menu.MainMenu.AddSubMenu("Drawing");                        HealthbarE = Menu.AddLinkedCircle("E damage on healthbar"' true' Color.FromArgb(150' Color.Green)' 0);                      RangeQ = Menu.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' SpellManager.Q.Range);                      RangeW = Menu.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.MediumPurple)' SpellManager.W.Range);                      RangeELeaving = Menu.AddLinkedCircle("E range (leaving)"' false' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range - 200);                      RangeE = Menu.AddLinkedCircle("E range (actual)"' true' Color.FromArgb(150' Color.DarkRed)' SpellManager.E.Range);                      RangeR = Menu.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' SpellManager.R.Range);                  }
Magic Number,KalistaResurrection,Core,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Core.cs,OnUpdate,The following statement contains a magic number: if (Environment.TickCount - _lastTick >= 50)              {                  _lastTick = Environment.TickCount;                  if (OnPreTick != null)                  {                      OnPreTick(_emptyArgs);                  }                  if (OnTick != null)                  {                      OnTick(_emptyArgs);                  }                  if (OnPostTick != null)                  {                      OnPostTick(_emptyArgs);                  }              }
Magic Number,KalistaResurrection,DamageIndicator,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\DamageIndicator.cs,Drawing_OnDraw,The following statement contains a magic number: if (Enabled)              {                  foreach (var unit in HeroManager.Enemies.Where(u => u.IsValidTarget() && u.IsHPBarRendered))                  {                      // Get damage to unit                      var damage = damageToUnit(unit);                        // Continue on 0 damage                      if (damage <= 0)                          continue;                        // Get remaining HP after damage applied in percent and the current percent of health                      var damagePercentage = ((unit.Health - damage) > 0 ? (unit.Health - damage) : 0) / unit.MaxHealth;                      var currentHealthPercentage = unit.Health / unit.MaxHealth;                        // Calculate start and end point of the bar indicator                      var startPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + damagePercentage * BAR_WIDTH)' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5);                      var endPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + currentHealthPercentage * BAR_WIDTH) + 1' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5);                        // Draw the line                      Drawing.DrawLine(startPoint' endPoint' LINE_THICKNESS' DrawingColor);                  }              }
Magic Number,KalistaResurrection,DamageIndicator,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\DamageIndicator.cs,Drawing_OnDraw,The following statement contains a magic number: if (Enabled)              {                  foreach (var unit in HeroManager.Enemies.Where(u => u.IsValidTarget() && u.IsHPBarRendered))                  {                      // Get damage to unit                      var damage = damageToUnit(unit);                        // Continue on 0 damage                      if (damage <= 0)                          continue;                        // Get remaining HP after damage applied in percent and the current percent of health                      var damagePercentage = ((unit.Health - damage) > 0 ? (unit.Health - damage) : 0) / unit.MaxHealth;                      var currentHealthPercentage = unit.Health / unit.MaxHealth;                        // Calculate start and end point of the bar indicator                      var startPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + damagePercentage * BAR_WIDTH)' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5);                      var endPoint = new Vector2((int)(unit.HPBarPosition.X + BarOffset.X + currentHealthPercentage * BAR_WIDTH) + 1' (int)(unit.HPBarPosition.Y + BarOffset.Y) - 5);                        // Draw the line                      Drawing.DrawLine(startPoint' endPoint' LINE_THICKNESS' DrawingColor);                  }              }
Magic Number,KalistaResurrection,Damages,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Damages.cs,GetRendDamage,The following statement contains a magic number: return ((float)Player.CalcDamage(target' Damage.DamageType.Physical' GetRawRendDamage(target' customStacks)) - 20) * 0.98f;
Magic Number,KalistaResurrection,ItemManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\ItemManager.cs,UseYoumuu,The following statement contains a magic number: if (Settings.UseGhostblade && YOUMUU.IsReady() && target.IsValidTarget(Orbwalking.GetRealAutoAttackRange(player) + 50))              {                  return YOUMUU.Cast();              }
Magic Number,KalistaResurrection,Program,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Program.cs,OnProcessSpellCast,The following statement contains a magic number: if (sender.IsMe)              {                  // E - Rend                  if (args.SData.Name == "KalistaExpungeWrapper")                  {                      // Make the orbwalker attack again' might get stuck after casting E                      Utility.DelayAction.Add(250' Orbwalking.ResetAutoAttackTimer);                  }              }
Magic Number,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnUpdate,The following statement contains a magic number: if (SoulBound == null)              {                  // TODO: Get the buff display name' I'm not at home so I needed to use xQx' method' which I don't like :D                  SoulBound = HeroManager.Allies.Find(h => h.Buffs.Any(b => b.Caster.IsMe && b.Name.Contains("kalistacoopstrikeally")));              }              else if (Settings.SaveSouldBound && R.IsReady())              {                  // Ult casting                  if (SoulBound.HealthPercentage() < 5 && SoulBound.CountEnemiesInRange(500) > 0 ||                      IncomingDamage > SoulBound.Health)                      R.Cast();              }
Magic Number,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnUpdate,The following statement contains a magic number: if (SoulBound == null)              {                  // TODO: Get the buff display name' I'm not at home so I needed to use xQx' method' which I don't like :D                  SoulBound = HeroManager.Allies.Find(h => h.Buffs.Any(b => b.Caster.IsMe && b.Name.Contains("kalistacoopstrikeally")));              }              else if (Settings.SaveSouldBound && R.IsReady())              {                  // Ult casting                  if (SoulBound.HealthPercentage() < 5 && SoulBound.CountEnemiesInRange(500) > 0 ||                      IncomingDamage > SoulBound.Health)                      R.Cast();              }
Magic Number,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The following statement contains a magic number: if (sender.IsEnemy)              {                  // Calculations to save your souldbound                  if (SoulBound != null && Settings.SaveSouldBound)                  {                      // Auto attacks                      if ((!(sender is Obj_AI_Hero) || args.SData.IsAutoAttack()) && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                      {                          // Calculate arrival time and damage                          _incomingDamage.Add(SoulBound.ServerPosition.Distance(sender.ServerPosition) / args.SData.MissileSpeed + Game.Time' (float)sender.GetAutoAttackDamage(SoulBound));                      }                      // Sender is a hero                      else if (sender is Obj_AI_Hero)                      {                          var attacker = (Obj_AI_Hero)sender;                          var slot = attacker.GetSpellSlot(args.SData.Name);                            if (slot != SpellSlot.Unknown)                          {                              if (slot == attacker.GetSpellSlot("SummonerDot") && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                              {                                  // Ingite damage (dangerous)                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSummonerSpellDamage(SoulBound' Damage.SummonerSpell.Ignite));                              }                              else if (slot.HasFlag(SpellSlot.Q | SpellSlot.W | SpellSlot.E | SpellSlot.R) &&                                  ((args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) ||                                  args.End.Distance(SoulBound.ServerPosition) < Math.Pow(args.SData.LineWidth' 2)))                              {                                  // Instant damage to target                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSpellDamage(SoulBound' slot));                              }                          }                      }                  }              }
Magic Number,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The following statement contains a magic number: if (sender.IsEnemy)              {                  // Calculations to save your souldbound                  if (SoulBound != null && Settings.SaveSouldBound)                  {                      // Auto attacks                      if ((!(sender is Obj_AI_Hero) || args.SData.IsAutoAttack()) && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                      {                          // Calculate arrival time and damage                          _incomingDamage.Add(SoulBound.ServerPosition.Distance(sender.ServerPosition) / args.SData.MissileSpeed + Game.Time' (float)sender.GetAutoAttackDamage(SoulBound));                      }                      // Sender is a hero                      else if (sender is Obj_AI_Hero)                      {                          var attacker = (Obj_AI_Hero)sender;                          var slot = attacker.GetSpellSlot(args.SData.Name);                            if (slot != SpellSlot.Unknown)                          {                              if (slot == attacker.GetSpellSlot("SummonerDot") && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                              {                                  // Ingite damage (dangerous)                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSummonerSpellDamage(SoulBound' Damage.SummonerSpell.Ignite));                              }                              else if (slot.HasFlag(SpellSlot.Q | SpellSlot.W | SpellSlot.E | SpellSlot.R) &&                                  ((args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) ||                                  args.End.Distance(SoulBound.ServerPosition) < Math.Pow(args.SData.LineWidth' 2)))                              {                                  // Instant damage to target                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSpellDamage(SoulBound' slot));                              }                          }                      }                  }              }
Magic Number,KalistaResurrection,SoulBoundSaver,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SoulBoundSaver.cs,OnProcessSpellCast,The following statement contains a magic number: if (sender.IsEnemy)              {                  // Calculations to save your souldbound                  if (SoulBound != null && Settings.SaveSouldBound)                  {                      // Auto attacks                      if ((!(sender is Obj_AI_Hero) || args.SData.IsAutoAttack()) && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                      {                          // Calculate arrival time and damage                          _incomingDamage.Add(SoulBound.ServerPosition.Distance(sender.ServerPosition) / args.SData.MissileSpeed + Game.Time' (float)sender.GetAutoAttackDamage(SoulBound));                      }                      // Sender is a hero                      else if (sender is Obj_AI_Hero)                      {                          var attacker = (Obj_AI_Hero)sender;                          var slot = attacker.GetSpellSlot(args.SData.Name);                            if (slot != SpellSlot.Unknown)                          {                              if (slot == attacker.GetSpellSlot("SummonerDot") && args.Target != null && args.Target.NetworkId == SoulBound.NetworkId)                              {                                  // Ingite damage (dangerous)                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSummonerSpellDamage(SoulBound' Damage.SummonerSpell.Ignite));                              }                              else if (slot.HasFlag(SpellSlot.Q | SpellSlot.W | SpellSlot.E | SpellSlot.R) &&                                  ((args.Target != null && args.Target.NetworkId == SoulBound.NetworkId) ||                                  args.End.Distance(SoulBound.ServerPosition) < Math.Pow(args.SData.LineWidth' 2)))                              {                                  // Instant damage to target                                  _instantDamage.Add(Game.Time + 2' (float)attacker.GetSpellDamage(SoulBound' slot));                              }                          }                      }                  }              }
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: Q = new Spell(SpellSlot.Q' 1200);
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: W = new Spell(SpellSlot.W' 5000);
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: E = new Spell(SpellSlot.E' 1000);
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: R = new Spell(SpellSlot.R' 1500);
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: Q.SetSkillshot(0.35f' 40' 2400' true' SkillshotType.SkillshotLine);
Magic Number,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,SpellManager,The following statement contains a magic number: Q.SetSkillshot(0.35f' 40' 2400' true' SkillshotType.SkillshotLine);
Magic Number,KalistaResurrection,UpdateChecker,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\UpdateChecker.cs,Initialize,The following statement contains a magic number: using (var client = new WebClient())              {                  new Thread(async () =>                  {                      try                      {                          var data = await client.DownloadStringTaskAsync(string.Format("https://raw.github.com/{0}/Properties/AssemblyInfo.cs"' path));                            var version =                              System.Version.Parse(new Regex("AssemblyFileVersion\\((\"(.+?)\")\\)").Match(data).Groups[1].Value.Replace(                                  "\""' ""));                            // Compare both versions                          var assemblyName = Assembly.GetExecutingAssembly().GetName();                          if (version > assemblyName.Version)                          {                              Utility.DelayAction.Add(5000' () =>                              {                                  Game.PrintChat("[{0}] Update available: {1} => {2}!"'                                      assemblyName.Name'                                      assemblyName.Version'                                      version);                              });                          }                      }                      catch (Exception e)                      {                          Console.WriteLine("An error occured while trying to check for an update:\n{0}"' e.Message);                      }                  }).Start();              }
Magic Number,KalistaResurrection,VectorHelper,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\VectorHelper.cs,IsLyingInCone,The following statement contains a magic number: double halfAperture = aperture / 2;
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Target != Vector3.Zero)              {                  // Move to the target                  Player.IssueOrder(GameObjectOrder.MoveTo' Target);                    // This is only to validate when the jump get aborted by' for example' stuns                  if (Environment.TickCount - InitTime > 500)                  {                      Target = Vector3.Zero;                      InitTime = 0;                  }                  else                  {                      return;                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,Execute,The following statement contains a magic number: if (Settings.UseWallJumps)              {                  // We need to define a new move position since jumping over walls                  // requires you to be close to the specified wall. Therefore we set the move                  // point to be that specific piont. People will need to get used to it'                  // but this is how it works.                  var wallCheck = VectorHelper.GetFirstWallPoint(Player.Position' Game.CursorPos);                    // Be more precise                  if (wallCheck != null)                  {                      wallCheck = VectorHelper.GetFirstWallPoint((Vector3)wallCheck' Game.CursorPos' 5);                  }                    // Define more position point                  Vector3 movePosition = wallCheck != null ? (Vector3)wallCheck : Game.CursorPos;                    // Update fleeTargetPosition                  var tempGrid = NavMesh.WorldToGrid(movePosition.X' movePosition.Y);                  FleePosition = NavMesh.GridToWorld((short)tempGrid.X' (short)tempGrid.Y);                    // Also check if we want to AA aswell                  Obj_AI_Base target = null;                  if (Settings.UseAutoAttacks)                  {                      var dashObjects = VectorHelper.GetDashObjects();                      if (dashObjects.Count > 0)                      {                          target = dashObjects[0];                      }                  }                    // Reset walljump indicators                  IsJumpPossible = false;                    // Only calculate stuff when our Q is up and there is a wall inbetween                  if (Q.IsReady() && wallCheck != null)                  {                      // Get our wall position to calculate from                      Vector3 wallPosition = movePosition;                        // Check 300 units to the cursor position in a 160 degree cone for a valid non-wall spot                      Vector2 direction = (Game.CursorPos.To2D() - wallPosition.To2D()).Normalized();                      float maxAngle = 80;                      float step = maxAngle / 20;                      float currentAngle = 0;                      float currentStep = 0;                      bool jumpTriggered = false;                      while (true)                      {                          // Validate the counter' break if no valid spot was found in previous loops                          if (currentStep > maxAngle && currentAngle < 0)                          {                              break;                          }                            // Check next angle                          if ((currentAngle == 0 || currentAngle < 0) && currentStep != 0)                          {                              currentAngle = (currentStep) * (float)Math.PI / 180;                              currentStep += step;                          }                          else if (currentAngle > 0)                          {                              currentAngle = -currentAngle;                          }                            Vector3 checkPoint;                            // One time only check for direct line of sight without rotating                          if (currentStep == 0)                          {                              currentStep = step;                              checkPoint = wallPosition + 300 * direction.To3D();                          }                          // Rotated check                          else                          {                              checkPoint = wallPosition + 300 * direction.Rotated(currentAngle).To3D();                          }                            // Check if the point is not a wall                          if (!checkPoint.IsWall())                          {                              // Check if there is a wall between the checkPoint and wallPosition                              wallCheck = VectorHelper.GetFirstWallPoint(checkPoint' wallPosition);                              if (wallCheck != null)                              {                                  // There is a wall inbetween' get the closes point to the wall' as precise as possible                                  Vector3 wallPositionOpposite = (Vector3)VectorHelper.GetFirstWallPoint((Vector3)wallCheck' wallPosition' 5);                                    // Check if it's worth to jump considering the path length                                  if (Player.GetPath(wallPositionOpposite).ToList().To2D().PathLength() - Player.Distance(wallPositionOpposite) > 200)                                  {                                      // Check the distance to the opposite side of the wall                                      if (Player.Distance(wallPositionOpposite' true) < Math.Pow(300 - Player.BoundingRadius / 2' 2))                                      {                                          // Make the jump happen                                          InitTime = Environment.TickCount;                                          Target = wallPositionOpposite;                                          Q.Cast(wallPositionOpposite);                                            // Update jumpTriggered value to not orbwalk now since we want to jump                                          jumpTriggered = true;                                            // Break the loop                                          break;                                      }                                      // If we are not able to jump due to the distance' draw the spot to                                      // make the user notice the possibliy                                      else                                      {                                          // Update indicator values                                          IsJumpPossible = true;                                      }                                  }                              }                          }                      }                        // Check if the loop triggered the jump' if not just orbwalk                      if (!jumpTriggered)                      {                          Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                      }                  }                  // Either no wall or Q on cooldown' just move towards to wall then                  else                  {                      Orbwalking.Orbwalk(target' movePosition' 90f' 0f' false' false);                  }              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,OnDraw,The following statement contains a magic number: if (FleePosition != Vector3.Zero)              {                  Render.Circle.DrawCircle(FleePosition' 50' IsJumpPossible ? Color.Green : SpellManager.Q.IsReady() ? Color.Red : Color.Teal' 10);              }
Magic Number,KalistaResurrection.Modes,Flee,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Flee.cs,OnDraw,The following statement contains a magic number: if (FleePosition != Vector3.Zero)              {                  Render.Circle.DrawCircle(FleePosition' 50' IsJumpPossible ? Color.Green : SpellManager.Q.IsReady() ? Color.Red : Color.Teal' 10);              }
Magic Number,KalistaResurrection.Modes,PermaActive,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\PermaActive.cs,Execute,The following statement contains a magic number: if (E.IsReady())              {                  #region Killsteal                    if (Settings.UseKillsteal &&                      HeroManager.Enemies.Any(h => h.IsValidTarget(E.Range) && h.IsRendKillable()))                  {                      E.Cast();                  }                    #endregion                    #region E on big mobs                    else if (Settings.UseEBig &&                      ObjectManager.Get<Obj_AI_Minion>().Any(m => m.IsValidTarget(E.Range) && (m.BaseSkinName.Contains("MinionSiege") || m.BaseSkinName.Contains("Dragon") || m.BaseSkinName.Contains("Baron")) && m.IsRendKillable()))                  {                      E.Cast();                  }                    #endregion                    #region E combo (minion + champ)                    else if (Settings.UseHarassPlus)                  {                      var enemy = HeroManager.Enemies.Where(o => o.HasRendBuff()).OrderBy(o => o.Distance(Player' true)).FirstOrDefault();                      if (enemy != null)                      {                          if (enemy.Distance(Player' true) < Math.Pow(E.Range + 200' 2))                          {                              if (ObjectManager.Get<Obj_AI_Minion>().Any(o => o.IsRendKillable() && E.IsInRange(o)))                              {                                  E.Cast();                              }                          }                      }                  }                    #endregion              }
Magic Number,KalistaResurrection.Modes,PermaActive,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\PermaActive.cs,Execute,The following statement contains a magic number: if (E.IsReady())              {                  #region Killsteal                    if (Settings.UseKillsteal &&                      HeroManager.Enemies.Any(h => h.IsValidTarget(E.Range) && h.IsRendKillable()))                  {                      E.Cast();                  }                    #endregion                    #region E on big mobs                    else if (Settings.UseEBig &&                      ObjectManager.Get<Obj_AI_Minion>().Any(m => m.IsValidTarget(E.Range) && (m.BaseSkinName.Contains("MinionSiege") || m.BaseSkinName.Contains("Dragon") || m.BaseSkinName.Contains("Baron")) && m.IsRendKillable()))                  {                      E.Cast();                  }                    #endregion                    #region E combo (minion + champ)                    else if (Settings.UseHarassPlus)                  {                      var enemy = HeroManager.Enemies.Where(o => o.HasRendBuff()).OrderBy(o => o.Distance(Player' true)).FirstOrDefault();                      if (enemy != null)                      {                          if (enemy.Distance(Player' true) < Math.Pow(E.Range + 200' 2))                          {                              if (ObjectManager.Get<Obj_AI_Minion>().Any(o => o.IsRendKillable() && E.IsInRange(o)))                              {                                  E.Cast();                              }                          }                      }                  }                    #endregion              }
Magic Number,KalistaResurrection.Modes,WaveClear,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\WaveClear.cs,Execute,The following statement contains a magic number: if (((Player.Mana / Player.MaxMana) * 100) < Settings.MinMana)              {                  return;              }
Magic Number,KalistaResurrection.Modes,Harass,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Harass.cs,Execute,The following statement contains a magic number: if (((Player.Mana / Player.MaxMana) * 100) < Settings.MinMana)              {                  return;              }
Magic Number,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The following statement contains a magic number: if (target != null)              {                  // Q usage                  if (Settings.UseQ && Q.IsReady() && !Player.IsDashing())                  {                      Q.Cast(target);                  }                    // E usage                  if (Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff())                  {                      // Target is not in range but has E stacks on                      if (Player.Distance(target' true) > Math.Pow(Orbwalking.GetRealAutoAttackRange(target)' 2))                      {                          // Get minions around                          var minions = ObjectManager.Get<Obj_AI_Minion>().Where(m => m.IsValidTarget(Orbwalking.GetRealAutoAttackRange(m)));                            // Check if a minion can die with the current E stacks                          if (minions.Any(m => m.IsRendKillable()))                          {                              E.Cast(true);                          }                          else                          {                              // Check if a minion can die with one AA and E. Also' the AA minion has be be behind the player direction for a further leap                              var minion = VectorHelper.GetDashObjects(minions).Find(m => m.Health > Player.GetAutoAttackDamage(m) && m.Health < Player.GetAutoAttackDamage(m) + Damages.GetRendDamage(m' (m.HasRendBuff() ? m.GetRendBuff().Count + 1 : 1)));                              if (minion != null)                              {                                  Config.Menu.Orbwalker.ForceTarget(minion);                              }                          }                      }                      // Target is in E range                      else if (E.IsInRange(target))                      {                          // Check if the target would die from E                          if (target.IsRendKillable())                          {                              E.Cast(true);                          }                          // Check if target has the desired amount of E stacks on                          else if (target.GetRendBuff().Count >= Settings.MinNumberE)                          {                              // Check if target is about to leave our E range or the buff is about to run out                              if (target.ServerPosition.Distance(Player.ServerPosition' true) > Math.Pow(E.Range * 0.8' 2) ||                                  target.GetRendBuff().EndTime - Game.Time < 0.3)                              {                                  E.Cast(true);                              }                          }                      }                  }              }
Magic Number,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The following statement contains a magic number: if (target != null)              {                  // Q usage                  if (Settings.UseQ && Q.IsReady() && !Player.IsDashing())                  {                      Q.Cast(target);                  }                    // E usage                  if (Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff())                  {                      // Target is not in range but has E stacks on                      if (Player.Distance(target' true) > Math.Pow(Orbwalking.GetRealAutoAttackRange(target)' 2))                      {                          // Get minions around                          var minions = ObjectManager.Get<Obj_AI_Minion>().Where(m => m.IsValidTarget(Orbwalking.GetRealAutoAttackRange(m)));                            // Check if a minion can die with the current E stacks                          if (minions.Any(m => m.IsRendKillable()))                          {                              E.Cast(true);                          }                          else                          {                              // Check if a minion can die with one AA and E. Also' the AA minion has be be behind the player direction for a further leap                              var minion = VectorHelper.GetDashObjects(minions).Find(m => m.Health > Player.GetAutoAttackDamage(m) && m.Health < Player.GetAutoAttackDamage(m) + Damages.GetRendDamage(m' (m.HasRendBuff() ? m.GetRendBuff().Count + 1 : 1)));                              if (minion != null)                              {                                  Config.Menu.Orbwalker.ForceTarget(minion);                              }                          }                      }                      // Target is in E range                      else if (E.IsInRange(target))                      {                          // Check if the target would die from E                          if (target.IsRendKillable())                          {                              E.Cast(true);                          }                          // Check if target has the desired amount of E stacks on                          else if (target.GetRendBuff().Count >= Settings.MinNumberE)                          {                              // Check if target is about to leave our E range or the buff is about to run out                              if (target.ServerPosition.Distance(Player.ServerPosition' true) > Math.Pow(E.Range * 0.8' 2) ||                                  target.GetRendBuff().EndTime - Game.Time < 0.3)                              {                                  E.Cast(true);                              }                          }                      }                  }              }
Magic Number,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The following statement contains a magic number: if (target != null)              {                  // Q usage                  if (Settings.UseQ && Q.IsReady() && !Player.IsDashing())                  {                      Q.Cast(target);                  }                    // E usage                  if (Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff())                  {                      // Target is not in range but has E stacks on                      if (Player.Distance(target' true) > Math.Pow(Orbwalking.GetRealAutoAttackRange(target)' 2))                      {                          // Get minions around                          var minions = ObjectManager.Get<Obj_AI_Minion>().Where(m => m.IsValidTarget(Orbwalking.GetRealAutoAttackRange(m)));                            // Check if a minion can die with the current E stacks                          if (minions.Any(m => m.IsRendKillable()))                          {                              E.Cast(true);                          }                          else                          {                              // Check if a minion can die with one AA and E. Also' the AA minion has be be behind the player direction for a further leap                              var minion = VectorHelper.GetDashObjects(minions).Find(m => m.Health > Player.GetAutoAttackDamage(m) && m.Health < Player.GetAutoAttackDamage(m) + Damages.GetRendDamage(m' (m.HasRendBuff() ? m.GetRendBuff().Count + 1 : 1)));                              if (minion != null)                              {                                  Config.Menu.Orbwalker.ForceTarget(minion);                              }                          }                      }                      // Target is in E range                      else if (E.IsInRange(target))                      {                          // Check if the target would die from E                          if (target.IsRendKillable())                          {                              E.Cast(true);                          }                          // Check if target has the desired amount of E stacks on                          else if (target.GetRendBuff().Count >= Settings.MinNumberE)                          {                              // Check if target is about to leave our E range or the buff is about to run out                              if (target.ServerPosition.Distance(Player.ServerPosition' true) > Math.Pow(E.Range * 0.8' 2) ||                                  target.GetRendBuff().EndTime - Game.Time < 0.3)                              {                                  E.Cast(true);                              }                          }                      }                  }              }
Magic Number,KalistaResurrection.Modes,Combo,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Modes\Combo.cs,Execute,The following statement contains a magic number: if (target != null)              {                  // Q usage                  if (Settings.UseQ && Q.IsReady() && !Player.IsDashing())                  {                      Q.Cast(target);                  }                    // E usage                  if (Settings.UseE && (E.Instance.State == SpellState.Ready || E.Instance.State == SpellState.Surpressed) && target.HasRendBuff())                  {                      // Target is not in range but has E stacks on                      if (Player.Distance(target' true) > Math.Pow(Orbwalking.GetRealAutoAttackRange(target)' 2))                      {                          // Get minions around                          var minions = ObjectManager.Get<Obj_AI_Minion>().Where(m => m.IsValidTarget(Orbwalking.GetRealAutoAttackRange(m)));                            // Check if a minion can die with the current E stacks                          if (minions.Any(m => m.IsRendKillable()))                          {                              E.Cast(true);                          }                          else                          {                              // Check if a minion can die with one AA and E. Also' the AA minion has be be behind the player direction for a further leap                              var minion = VectorHelper.GetDashObjects(minions).Find(m => m.Health > Player.GetAutoAttackDamage(m) && m.Health < Player.GetAutoAttackDamage(m) + Damages.GetRendDamage(m' (m.HasRendBuff() ? m.GetRendBuff().Count + 1 : 1)));                              if (minion != null)                              {                                  Config.Menu.Orbwalker.ForceTarget(minion);                              }                          }                      }                      // Target is in E range                      else if (E.IsInRange(target))                      {                          // Check if the target would die from E                          if (target.IsRendKillable())                          {                              E.Cast(true);                          }                          // Check if target has the desired amount of E stacks on                          else if (target.GetRendBuff().Count >= Settings.MinNumberE)                          {                              // Check if target is about to leave our E range or the buff is about to run out                              if (target.ServerPosition.Distance(Player.ServerPosition' true) > Math.Pow(E.Range * 0.8' 2) ||                                  target.GetRendBuff().EndTime - Game.Time < 0.3)                              {                                  E.Cast(true);                              }                          }                      }                  }              }
Missing Default,KalistaResurrection,Hero,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\Hero.cs,OnWndProc,The following switch statement is missing a default case: switch (args.Msg)                  {                      case (uint)WindowsMessages.WM_KEYDOWN:                            ActiveMode = ActiveMode | mode;                          break;                        case (uint)WindowsMessages.WM_KEYUP:                            ActiveMode = ActiveMode ^ mode;                          break;                  }
Missing Default,KalistaResurrection,SpellManager,C:\repos\Hellsing_LeagueSharp\KalistaResurrection\SpellManager.cs,GetSpellFromSlot,The following switch statement is missing a default case: switch (slot)              {                  case SpellSlot.Q:                      return Q;                  case SpellSlot.W:                      return W;                  case SpellSlot.E:                      return E;                  case SpellSlot.R:                      return R;              }
