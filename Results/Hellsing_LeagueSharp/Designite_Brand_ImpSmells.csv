Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnWaveClear,Cyclomatic complexity of the method is 12
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The length of the statement  "                        ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready " is 127.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The length of the statement  "                        if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f) " is 148.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The length of the statement  "                            if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0) " is 304.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The length of the statement  "                        ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready " is 127.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnWaveClear,The length of the statement  "                var farmLocation = MinionManager.GetBestCircularFarmLocation(minions.Select(minion => minion.ServerPosition.To2D()).ToList()' W.Width' W.Range); " is 144.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,HasIgnite,The length of the statement  "                return ignite != null && ignite.Slot != SpellSlot.Unknown && (checkReady ? player.Spellbook.CanUseSpell(ignite.Slot) == SpellState.Ready && player.Distance(target' true) < 400 * 400 : true); " is 190.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The length of the statement  "            circleLinks.Add("drawRangeQ"' drawings.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' Q.Range)); " is 120.
Long Statement,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The length of the statement  "            circleLinks.Add("drawRangeW"' drawings.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.IndianRed)' W.Range)); " is 120.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The conditional expression  "(mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The conditional expression  "(mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The conditional expression  "(mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The conditional expression  "(useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The conditional expression  "ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The conditional expression  "target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The conditional expression  "(!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))"  is complex.
Complex Conditional,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The conditional expression  "(!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))"  is complex.
Magic Number,Brand,CustomDamageIndicator,C:\repos\Hellsing_LeagueSharp\Brand\CustomDamageIndicator.cs,Drawing_OnDraw,The following statement contains a magic number: var barColor = new ColorBGRA(Color.R' Color.G' Color.B' 155);
Magic Number,Brand,CustomDamageIndicator,C:\repos\Hellsing_LeagueSharp\Brand\CustomDamageIndicator.cs,Drawing_OnDraw,The following statement contains a magic number: foreach (var unit in ObjectManager.Get<Obj_AI_Hero>().Where(u => u.IsValidTarget()))              {                  // Get damage to unit                  var damage = damageToUnit(unit);                    // Continue on 0 damage                  if (Math.Abs(damage) < float.Epsilon)                  {                      continue;                  }                    // Get remaining HP after damage applied in percent and the current percent of health                  var damagePercentage = ((unit.Health - damage) > 0 ? (unit.Health - damage) : 0) / unit.MaxHealth;                  var currentHealthPercentage = unit.Health / unit.MaxHealth;                    // Calculate start and end point of the bar indicator                  var startPoint = new Vector2(                      (int) (unit.HPBarPosition.X + BarOffset.X + damagePercentage * BAR_WIDTH)'                      (int) (unit.HPBarPosition.Y + BarOffset.Y) + 4);                  var endPoint =                      new Vector2(                          (int) (unit.HPBarPosition.X + BarOffset.X + currentHealthPercentage * BAR_WIDTH) + 1'                          (int) (unit.HPBarPosition.Y + BarOffset.Y) + 4);                    // Draw the DirectX line                  line.Begin();                  line.Draw(new[] { startPoint' endPoint }' barColor);                  line.End();              }
Magic Number,Brand,CustomDamageIndicator,C:\repos\Hellsing_LeagueSharp\Brand\CustomDamageIndicator.cs,Drawing_OnDraw,The following statement contains a magic number: foreach (var unit in ObjectManager.Get<Obj_AI_Hero>().Where(u => u.IsValidTarget()))              {                  // Get damage to unit                  var damage = damageToUnit(unit);                    // Continue on 0 damage                  if (Math.Abs(damage) < float.Epsilon)                  {                      continue;                  }                    // Get remaining HP after damage applied in percent and the current percent of health                  var damagePercentage = ((unit.Health - damage) > 0 ? (unit.Health - damage) : 0) / unit.MaxHealth;                  var currentHealthPercentage = unit.Health / unit.MaxHealth;                    // Calculate start and end point of the bar indicator                  var startPoint = new Vector2(                      (int) (unit.HPBarPosition.X + BarOffset.X + damagePercentage * BAR_WIDTH)'                      (int) (unit.HPBarPosition.Y + BarOffset.Y) + 4);                  var endPoint =                      new Vector2(                          (int) (unit.HPBarPosition.X + BarOffset.X + currentHealthPercentage * BAR_WIDTH) + 1'                          (int) (unit.HPBarPosition.Y + BarOffset.Y) + 4);                    // Draw the DirectX line                  line.Begin();                  line.Draw(new[] { startPoint' endPoint }' barColor);                  line.End();              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: Q = new Spell(SpellSlot.Q' 1050);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: W = new Spell(SpellSlot.W' 900);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: E = new Spell(SpellSlot.E' 625);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: R = new Spell(SpellSlot.R' 750);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: Q.SetSkillshot(0.25f' 80' 1200' true' SkillshotType.SkillshotLine);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: Q.SetSkillshot(0.25f' 80' 1200' true' SkillshotType.SkillshotLine);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: W.SetSkillshot(1' 200' float.MaxValue' false' SkillshotType.SkillshotCircle);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,Game_OnGameLoad,The following statement contains a magic number: R.SetTargetted(0.25f' 1000);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnCombo,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useW && !useE) || // Casting when not using W and E                          (target.IsAblazed()) || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((mainComboKillable && inMinimumRange) || // Main combo killable                          (!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (target.ServerPosition.Distance(player.Position' true) > Math.Pow(E.Range + 100' 2)) ||                          (!E.IsReady() && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((mainComboKillable) || // Main combo killable                              (!useQ && !useW) || // Casting when not using Q and W                              (E.Level >= 4) || // E level high' damage output higher                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target' true);                          }                      }                  }                  // R                  else if (spell.Slot == SpellSlot.R && useR)                  {                      // Distance check                      if (R.IsInRange(target.ServerPosition))                      {                          // Logic prechecks                          if ((useQ && Q.IsReady() && Q.GetPrediction(target).Hitchance == HitChance.High || useW && W.IsReady()) && player.Health / player.MaxHealth > 0.25f)                              continue;                            // Single hit                          if (mainComboKillable && inMinimumRange || R.IsKillable(target))                              R.CastOnUnit(target);                          // Double bounce combo                          else if (bounceComboKillable && inMinimumRange || R.GetDamage(target) * 2 > target.Health)                          {                              if (ObjectManager.Get<Obj_AI_Base>().Count(enemy => (enemy.Type == GameObjectType.obj_AI_Minion || enemy.NetworkId != target.NetworkId && enemy.Type == GameObjectType.obj_AI_Hero) && enemy.IsValidTarget() && enemy.ServerPosition.Distance(target.ServerPosition' true) < BOUNCE_RADIUS * BOUNCE_RADIUS) > 0)                                  R.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnHarass,The following statement contains a magic number: foreach (var spell in spellList)              {                  // Continue if spell not ready                  if (!spell.IsReady())                      continue;                    // Q                  if (spell.Slot == SpellSlot.Q && useQ)                  {                      if (target.IsAblazed() || // Ablazed                          (Q.IsKillable(target)) || // Killable                          (!useW && !useE) || // Casting when not using W and E                          (useW && !useE && !W.IsReady(250) && W.IsReady((int)(Q.Cooldown() * 1000))) || // Cooldown substraction W ready                          ((useE && !useW || useW && useE) && !E.IsReady(250) && E.IsReady((int)(Q.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast Q on high hitchance                          Q.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // W                  else if (spell.Slot == SpellSlot.W && useW)                  {                      if ((!useE) || // Casting when not using E                          (target.IsAblazed()) || // Ablazed                          (W.IsKillable(target)) || // Killable                          (E.IsInRange(target.ServerPosition)) ||                          (!E.IsReady(250) && E.IsReady((int)(W.Cooldown() * 1000)))) // Cooldown substraction E ready                      {                          // Cast W on high hitchance                          W.CastIfHitchanceEquals(target' HitChance.High);                      }                  }                  // E                  else if (spell.Slot == SpellSlot.E && useE)                  {                      // Distance check                      if (E.IsInRange(target.ServerPosition))                      {                          if ((!useQ && !useW) || // Casting when not using Q and W                              E.IsKillable(target) || // Killable                              (useQ && (Q.IsReady(250) || Q.Cooldown() < 5)) || // Q ready                              (useW && W.IsReady(250))) // W ready                          {                              // Cast E on target                              E.CastOnUnit(target);                          }                      }                  }              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,OnWaveClear,The following statement contains a magic number: var minions = MinionManager.GetMinions(player.Position' W.Range + W.Width / 2);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,GetMainComboDamage,The following statement contains a magic number: if (W.IsReady())                  damage += player.GetSpellDamage(target' SpellSlot.W) * (target.IsAblazed() ? 1.25 : 1);
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,HasIgnite,The following statement contains a magic number: if (target.IsMe)              {                  var ignite = player.Spellbook.GetSpell(player.GetSpellSlot("SummonerDot"));                  return ignite != null && ignite.Slot != SpellSlot.Unknown && (checkReady ? player.Spellbook.CanUseSpell(ignite.Slot) == SpellState.Ready && player.Distance(target' true) < 400 * 400 : true);              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,HasIgnite,The following statement contains a magic number: if (target.IsMe)              {                  var ignite = player.Spellbook.GetSpell(player.GetSpellSlot("SummonerDot"));                  return ignite != null && ignite.Slot != SpellSlot.Unknown && (checkReady ? player.Spellbook.CanUseSpell(ignite.Slot) == SpellState.Ready && player.Distance(target' true) < 400 * 400 : true);              }
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: keyLinks.Add("comboActive"' combo.AddLinkedKeyBind("Combo active"' 32' KeyBindType.Press));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: sliderLinks.Add("waveNumW"' waveClear.AddLinkedSlider("Minions to hit with W"' 3' 1' 10));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: sliderLinks.Add("waveNumW"' waveClear.AddLinkedSlider("Minions to hit with W"' 3' 1' 10));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: circleLinks.Add("drawRangeQ"' drawings.AddLinkedCircle("Q range"' true' Color.FromArgb(150' Color.IndianRed)' Q.Range));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: circleLinks.Add("drawRangeW"' drawings.AddLinkedCircle("W range"' true' Color.FromArgb(150' Color.IndianRed)' W.Range));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: circleLinks.Add("drawRangeE"' drawings.AddLinkedCircle("E range"' false' Color.FromArgb(150' Color.DarkRed)' E.Range));
Magic Number,Brand,Program,C:\repos\Hellsing_LeagueSharp\Brand\Program.cs,SetuptMenu,The following statement contains a magic number: circleLinks.Add("drawRangeR"' drawings.AddLinkedCircle("R range"' false' Color.FromArgb(150' Color.Red)' R.Range));
