Implementation smell,Namespace,Class,File,Method,Description
Complex Method,TinCan,Context,C:\repos\RusticiSoftware_TinCan.NET\TinCan\Context.cs,Context,Cyclomatic complexity of the method is 10
Complex Method,TinCan,Context,C:\repos\RusticiSoftware_TinCan.NET\TinCan\Context.cs,ToJObject,Cyclomatic complexity of the method is 10
Complex Method,TinCan,ContextActivities,C:\repos\RusticiSoftware_TinCan.NET\TinCan\ContextActivities.cs,ContextActivities,Cyclomatic complexity of the method is 9
Complex Method,TinCan,ContextActivities,C:\repos\RusticiSoftware_TinCan.NET\TinCan\ContextActivities.cs,ToJObject,Cyclomatic complexity of the method is 9
Complex Method,TinCan,StatementsQuery,C:\repos\RusticiSoftware_TinCan.NET\TinCan\StatementsQuery.cs,ToParameterMap,Cyclomatic complexity of the method is 12
Complex Method,TinCan,StatementBase,C:\repos\RusticiSoftware_TinCan.NET\TinCan\StatementBase.cs,StatementBase,Cyclomatic complexity of the method is 10
Complex Method,TinCan,RemoteLRS,C:\repos\RusticiSoftware_TinCan.NET\TinCan\RemoteLRS.cs,MakeSyncRequest,Cyclomatic complexity of the method is 11
Magic Number,TinCan,RemoteLRS,C:\repos\RusticiSoftware_TinCan.NET\TinCan\RemoteLRS.cs,ReadFully,The following statement contains a magic number: if (initialLength < 1)              {                  initialLength = 32768;              }
Magic Number,TinCan,RemoteLRS,C:\repos\RusticiSoftware_TinCan.NET\TinCan\RemoteLRS.cs,ReadFully,The following statement contains a magic number: while ((chunk = stream.Read(buffer' read' buffer.Length - read)) > 0)              {                  read += chunk;                    // If we've reached the end of our buffer' check to see if there's                  // any more information                  if (read == buffer.Length)                  {                      int nextByte = stream.ReadByte();                        // End of stream? If so' we're done                      if (nextByte == -1)                      {                          return buffer;                      }                        // Nope. Resize the buffer' put in the byte we've just                      // read' and continue                      byte[] newBuffer = new byte[buffer.Length * 2];                      Array.Copy(buffer' newBuffer' buffer.Length);                      newBuffer[read] = (byte)nextByte;                      buffer = newBuffer;                      read++;                  }              }
