Implementation smell,Namespace,Class,File,Method,Description
Long Method,Fare,MinimizationOperations,C:\repos\moodmosaic_Fare\Src\Fare\MinimizationOperations.cs,MinimizeHopcroft,The method has 196 lines of code.
Long Method,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,ParseSimpleExp,The method has 108 lines of code.
Complex Method,Fare,Automaton,C:\repos\moodmosaic_Fare\Src\Fare\Automaton.cs,Reduce,Cyclomatic complexity of the method is 8
Complex Method,Fare,BasicAutomata,C:\repos\moodmosaic_Fare\Src\Fare\BasicAutomata.cs,MakeStringMatcher,Cyclomatic complexity of the method is 10
Complex Method,Fare,BasicOperations,C:\repos\moodmosaic_Fare\Src\Fare\BasicOperations.cs,AddEpsilons,Cyclomatic complexity of the method is 12
Complex Method,Fare,BasicOperations,C:\repos\moodmosaic_Fare\Src\Fare\BasicOperations.cs,Determinize,Cyclomatic complexity of the method is 10
Complex Method,Fare,BasicOperations,C:\repos\moodmosaic_Fare\Src\Fare\BasicOperations.cs,Intersection,Cyclomatic complexity of the method is 12
Complex Method,Fare,BasicOperations,C:\repos\moodmosaic_Fare\Src\Fare\BasicOperations.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Fare,MinimizationOperations,C:\repos\moodmosaic_Fare\Src\Fare\MinimizationOperations.cs,MinimizeHopcroft,Cyclomatic complexity of the method is 32
Complex Method,Fare,MinimizationOperations,C:\repos\moodmosaic_Fare\Src\Fare\MinimizationOperations.cs,MinimizeHuffman,Cyclomatic complexity of the method is 19
Complex Method,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,ParseSimpleExp,Cyclomatic complexity of the method is 19
Complex Method,Fare,TransitionComparer,C:\repos\moodmosaic_Fare\Src\Fare\TransitionComparer.cs,Compare,Cyclomatic complexity of the method is 17
Long Parameter List,Fare,BasicAutomata,C:\repos\moodmosaic_Fare\Src\Fare\BasicAutomata.cs,Between,The method has 5 parameters. Parameters: x' y' n' initials' zeros
Long Parameter List,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,FindLeaves,The method has 6 parameters. Parameters: exp' regExpKind' list' automata' automatonProvider' minimize
Long Parameter List,Fare,SpecialOperations,C:\repos\moodmosaic_Fare\Src\Fare\SpecialOperations.cs,GetFiniteStrings,The method has 5 parameters. Parameters: s' pathStates' strings' path' limit
Long Statement,Fare,ListEqualityComparer<T>,C:\repos\moodmosaic_Fare\Src\Fare\ListEqualityComparer.cs,GetHashCode,The length of the statement  "            // http://stackoverflow.com/questions/1079192/is-it-possible-to-combine-hash-codes-for-private-members-to-generate-a-new-hash " is 125.
Complex Conditional,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,MakeConcatenation,The conditional expression  "(exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString)                 && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,MakeConcatenation,The conditional expression  "exp1.kind == Kind.RegexpConcatenation                 && (exp1.exp2.kind == Kind.RegexpChar || exp1.exp2.kind == Kind.RegexpString)                 && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,MakeConcatenation,The conditional expression  "(exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString)                      && exp2.kind == Kind.RegexpConcatenation                      && (exp2.exp1.kind == Kind.RegexpChar || exp2.exp1.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,ParseConcatExp,The conditional expression  "this.More() && !this.Peek(")|") && (!this.Check(RegExpSyntaxOptions.Intersection) || !this.Peek("&"))"  is complex.
Complex Conditional,Fare,Transition,C:\repos\moodmosaic_Fare\Src\Fare\Transition.cs,AppendCharString,The conditional expression  "c >= 0x21 && c <= 0x7e && c != '\\' && c != '"'"  is complex.
Magic Number,Fare,Automaton,C:\repos\moodmosaic_Fare\Src\Fare\Automaton.cs,RecomputeHashCode,The following statement contains a magic number: this.hashCode = (this.NumberOfStates * 3) + (this.NumberOfTransitions * 2);
Magic Number,Fare,Automaton,C:\repos\moodmosaic_Fare\Src\Fare\Automaton.cs,RecomputeHashCode,The following statement contains a magic number: this.hashCode = (this.NumberOfStates * 3) + (this.NumberOfTransitions * 2);
Magic Number,Fare,BasicAutomata,C:\repos\moodmosaic_Fare\Src\Fare\BasicAutomata.cs,MakeStringMatcher,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)              {                  var done = new HashSet<char?>();                  char c = s[i];                  states[i].Transitions.Add(new Transition(c' states[i + 1]));                  done.Add(c);                  for (int j = i; j >= 1; j--)                  {                      char d = s[j - 1];                      if (!done.Contains(d) && s.Substring(0' j - 1).Equals(s.Substring(i - j + 1' i - (i - j + 1))))                      {                          states[i].Transitions.Add(new Transition(d' states[j]));                          done.Add(d);                      }                  }                    var da = new char[done.Count];                  int h = 0;                  foreach (char w in done)                  {                      da[h++] = w;                  }                    Array.Sort(da);                  int from = Char.MinValue;                  int k = 0;                  while (from <= Char.MaxValue)                  {                      while (k < da.Length && da[k] == from)                      {                          k++;                          from++;                      }                        if (from <= Char.MaxValue)                      {                          int to = Char.MaxValue;                          if (k < da.Length)                          {                              to = da[k] - 1;                              k++;                          }                            states[i].Transitions.Add(new Transition((char)from' (char)to' states[0]));                          from = to + 2;                      }                  }              }
Magic Number,Fare,ListEqualityComparer<T>,C:\repos\moodmosaic_Fare\Src\Fare\ListEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Aggregate(17' (current' item) => (current * 31) + item.GetHashCode());
Magic Number,Fare,ListEqualityComparer<T>,C:\repos\moodmosaic_Fare\Src\Fare\ListEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Aggregate(17' (current' item) => (current * 31) + item.GetHashCode());
Magic Number,Fare,MinimizationOperations,C:\repos\moodmosaic_Fare\Src\Fare\MinimizationOperations.cs,MinimizeHopcroft,The following statement contains a magic number: int k = 2;
Magic Number,Fare,State,C:\repos\moodmosaic_Fare\Src\Fare\State.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = id;                  result = (result * 397) ^ Accept.GetHashCode();                  result = (result * 397) ^ Number;                  return result;              }
Magic Number,Fare,State,C:\repos\moodmosaic_Fare\Src\Fare\State.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = id;                  result = (result * 397) ^ Accept.GetHashCode();                  result = (result * 397) ^ Number;                  return result;              }
Magic Number,Fare,State,C:\repos\moodmosaic_Fare\Src\Fare\State.cs,GetHashCode,The following statement contains a magic number: hash ^= (hash * 31) + this.labels.Length;
Magic Number,Fare,State,C:\repos\moodmosaic_Fare\Src\Fare\State.cs,GetHashCode,The following statement contains a magic number: hash = this.labels.Aggregate(hash' (current' c) => current ^ (current * 31) + c);
Magic Number,Fare,StatePair,C:\repos\moodmosaic_Fare\Src\Fare\StatePair.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var result = 0;                  result = (result * 397) ^ (this.FirstState != null ? this.FirstState.GetHashCode() : 0);                  result = (result * 397) ^ (this.SecondState != null ? this.SecondState.GetHashCode() : 0);                  return result;              }
Magic Number,Fare,StatePair,C:\repos\moodmosaic_Fare\Src\Fare\StatePair.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var result = 0;                  result = (result * 397) ^ (this.FirstState != null ? this.FirstState.GetHashCode() : 0);                  result = (result * 397) ^ (this.SecondState != null ? this.SecondState.GetHashCode() : 0);                  return result;              }
Magic Number,Fare,Transition,C:\repos\moodmosaic_Fare\Src\Fare\Transition.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = min.GetHashCode();                  result = (result*397) ^ max.GetHashCode();                  result = (result*397) ^ (to != null ? to.GetHashCode() : 0);                  return result;              }
Magic Number,Fare,Transition,C:\repos\moodmosaic_Fare\Src\Fare\Transition.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = min.GetHashCode();                  result = (result*397) ^ max.GetHashCode();                  result = (result*397) ^ (to != null ? to.GetHashCode() : 0);                  return result;              }
Duplicate Code,Fare,TransitionComparer,C:\repos\moodmosaic_Fare\Src\Fare\TransitionComparer.cs,Compare,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3' 27)' (49' 73))
Missing Default,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,ToAutomaton,The following switch statement is missing a default case: switch (kind)             {                 case Kind.RegexpUnion:                     list = new List<Automaton>();                     this.FindLeaves(exp1' Kind.RegexpUnion' list' automata' automatonProvider' minimize);                     this.FindLeaves(exp2' Kind.RegexpUnion' list' automata' automatonProvider' minimize);                     a = BasicOperations.Union(list);                     a.Minimize();                     break;                 case Kind.RegexpConcatenation:                     list = new List<Automaton>();                     this.FindLeaves(exp1' Kind.RegexpConcatenation' list' automata' automatonProvider' minimize);                     this.FindLeaves(exp2' Kind.RegexpConcatenation' list' automata' automatonProvider' minimize);                     a = BasicOperations.Concatenate(list);                     a.Minimize();                     break;                 case Kind.RegexpIntersection:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize)                         .Intersection(exp2.ToAutomaton(automata' automatonProvider' minimize));                     a.Minimize();                     break;                 case Kind.RegexpOptional:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize).Optional();                     a.Minimize();                     break;                 case Kind.RegexpRepeat:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize).Repeat();                     a.Minimize();                     break;                 case Kind.RegexpRepeatMin:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize).Repeat(min);                     a.Minimize();                     break;                 case Kind.RegexpRepeatMinMax:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize).Repeat(min' max);                     a.Minimize();                     break;                 case Kind.RegexpComplement:                     a = exp1.ToAutomaton(automata' automatonProvider' minimize).Complement();                     a.Minimize();                     break;                 case Kind.RegexpChar:                     a = BasicAutomata.MakeChar(c);                     break;                 case Kind.RegexpCharRange:                     a = BasicAutomata.MakeCharRange(from' to);                     break;                 case Kind.RegexpAnyChar:                     a = BasicAutomata.MakeAnyChar();                     break;                 case Kind.RegexpEmpty:                     a = BasicAutomata.MakeEmpty();                     break;                 case Kind.RegexpString:                     a = BasicAutomata.MakeString(s);                     break;                 case Kind.RegexpAnyString:                     a = BasicAutomata.MakeAnyString();                     break;                 case Kind.RegexpAutomaton:                     Automaton aa = null;                     if (automata != null)                     {                         automata.TryGetValue(s' out aa);                     }                      if (aa == null && automatonProvider != null)                     {                         try                         {                             aa = automatonProvider.GetAutomaton(s);                         }                         catch (IOException e)                         {                             throw new ArgumentException(string.Empty' e);                         }                     }                      if (aa == null)                     {                         throw new ArgumentException("'" + s + "' not found");                     }                      a = aa.Clone(); // Always clone here (ignore allowMutate).                     break;                 case Kind.RegexpInterval:                     a = BasicAutomata.MakeInterval(min' max' digits);                     break;             }
Missing Default,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,ToStringBuilder,The following switch statement is missing a default case: switch (kind)             {                 case Kind.RegexpUnion:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append("|");                     exp2.ToStringBuilder(sb);                     sb.Append(")");                     break;                 case Kind.RegexpConcatenation:                     exp1.ToStringBuilder(sb);                     exp2.ToStringBuilder(sb);                     break;                 case Kind.RegexpIntersection:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append("&");                     exp2.ToStringBuilder(sb);                     sb.Append(")");                     break;                 case Kind.RegexpOptional:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append(")?");                     break;                 case Kind.RegexpRepeat:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append(")*");                     break;                 case Kind.RegexpRepeatMin:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append("){").Append(min).Append("'}");                     break;                 case Kind.RegexpRepeatMinMax:                     sb.Append("(");                     exp1.ToStringBuilder(sb);                     sb.Append("){").Append(min).Append("'").Append(max).Append("}");                     break;                 case Kind.RegexpComplement:                     sb.Append("~(");                     exp1.ToStringBuilder(sb);                     sb.Append(")");                     break;                 case Kind.RegexpChar:                     sb.Append("\\").Append(c);                     break;                 case Kind.RegexpCharRange:                     sb.Append("[\\").Append(from).Append("-\\").Append(to).Append("]");                     break;                 case Kind.RegexpAnyChar:                     sb.Append(".");                     break;                 case Kind.RegexpEmpty:                     sb.Append("#");                     break;                 case Kind.RegexpString:                     sb.Append("\"").Append(s).Append("\"");                     break;                 case Kind.RegexpAnyString:                     sb.Append("@");                     break;                 case Kind.RegexpAutomaton:                     sb.Append("<").Append(s).Append(">");                     break;                 case Kind.RegexpInterval:                     string s1 = Convert.ToDecimal(min).ToString();                     string s2 = Convert.ToDecimal(max).ToString();                     sb.Append("<");                     if (digits > 0)                     {                         for (int i = s1.Length; i < digits; i++)                         {                             sb.Append('0');                         }                     }                      sb.Append(s1).Append("-");                     if (digits > 0)                     {                         for (int i = s2.Length; i < digits; i++)                         {                             sb.Append('0');                         }                     }                      sb.Append(s2).Append(">");                     break;             }
Missing Default,Fare,RegExp,C:\repos\moodmosaic_Fare\Src\Fare\RegExp.cs,GetIdentifiers,The following switch statement is missing a default case: switch (kind)             {                 case Kind.RegexpUnion:                 case Kind.RegexpConcatenation:                 case Kind.RegexpIntersection:                     exp1.GetIdentifiers(set);                     exp2.GetIdentifiers(set);                     break;                 case Kind.RegexpOptional:                 case Kind.RegexpRepeat:                 case Kind.RegexpRepeatMin:                 case Kind.RegexpRepeatMinMax:                 case Kind.RegexpComplement:                     exp1.GetIdentifiers(set);                     break;                 case Kind.RegexpAutomaton:                     set.Add(s);                     break;             }
