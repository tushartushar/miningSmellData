Implementation smell,Namespace,Class,File,Method,Description
Long Method,GoogleApi.Entities.Search.Common.Enums.Extensions,CountryExtension,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\Common\Enums\Extensions\CountryExtension.cs,ToCr,The method has 249 lines of code.
Long Method,GoogleApi.Entities.Search.Common.Enums.Extensions,GeoLocationExtension,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\Common\Enums\Extensions\GeoLocationExtension.cs,ToGl,The method has 249 lines of code.
Long Method,GoogleApi.Entities.Translate.Common.Enums.Extensions,LanguageExtension,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Translate\Common\Enums\Extensions\LanguageExtension.cs,ToCode,The method has 112 lines of code.
Long Method,GoogleApi.Entities.Translate.Common.Enums.Extensions,LanguageExtension,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Translate\Common\Enums\Extensions\LanguageExtension.cs,IsValidNmt,The method has 113 lines of code.
Long Method,GoogleApi.Entities.Translate.Common.Enums.Extensions,StringExtension,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Translate\Common\Enums\Extensions\StringExtension.cs,FromCode,The method has 112 lines of code.
Complex Method,GoogleApi.Entities.Maps.Directions.Request,DirectionsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Directions\Request\DirectionsRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 12
Complex Method,GoogleApi.Entities.Maps.DistanceMatrix.Request,DistanceMatrixRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\DistanceMatrix\Request\DistanceMatrixRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 12
Complex Method,GoogleApi.Entities.Places.AutoComplete.Request,PlacesAutoCompleteRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\AutoComplete\Request\PlacesAutoCompleteRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 9
Complex Method,GoogleApi.Entities.Places.Search,BasePlacesSearchRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\Search\BasePlacesSearchRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 9
Complex Method,GoogleApi.Entities.Search,BaseSearchRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\BaseSearchRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 23
Complex Method,GoogleApi.Entities.Translate.Translate.Request,TranslateRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Translate\Translate\Request\TranslateRequest.cs,GetQueryStringParameters,Cyclomatic complexity of the method is 9
Long Statement,GoogleApi.Entities,BaseRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\BaseRequest.cs,GetUri,The length of the statement  "            var queryString = string.Join("&"' this.GetQueryStringParameters().Select(x => Uri.EscapeDataString(x.Key) + "=" + Uri.EscapeDataString(x.Value))); " is 147.
Long Statement,GoogleApi.Entities.Common,Location,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Common\Location.cs,ToString,The length of the statement  "            return this.Address ?? this.Latitude.ToString(CultureInfo.InvariantCulture) + "'" + this.Longitude.ToString(CultureInfo.InvariantCulture); " is 138.
Long Statement,GoogleApi.Entities.Maps.Directions.Request,DirectionsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Directions\Request\DirectionsRequest.cs,GetQueryStringParameters,The length of the statement  "                parameters.Add("waypoints"' string.Join("|"' this.OptimizeWaypoints ? new[] { "optimize:true" }.Concat(waypoints) : waypoints)); " is 128.
Long Statement,GoogleApi.Entities.Maps.Directions.Request,DirectionsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Directions\Request\DirectionsRequest.cs,GetQueryStringParameters,The length of the statement  "                parameters.Add("arrival_time"' this.ArrivalTime.Value.DateTimeToUnixTimestamp().ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,GoogleApi.Entities.Maps.Directions.Request,DirectionsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Directions\Request\DirectionsRequest.cs,GetQueryStringParameters,The length of the statement  "                parameters.Add("departure_time"' this.DepartureTime.Value.DateTimeToUnixTimestamp().ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,GoogleApi.Entities.Maps.DistanceMatrix.Request,DistanceMatrixRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\DistanceMatrix\Request\DistanceMatrixRequest.cs,GetQueryStringParameters,The length of the statement  "            parameters.Add("destinations"' string.IsNullOrEmpty(this.DestinationsRaw) ? string.Join("|"' this.Destinations) : this.DestinationsRaw); " is 136.
Long Statement,GoogleApi.Entities.Maps.DistanceMatrix.Request,DistanceMatrixRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\DistanceMatrix\Request\DistanceMatrixRequest.cs,GetQueryStringParameters,The length of the statement  "                    parameters.Add("arrival_time"' this.ArrivalTime.Value.DateTimeToUnixTimestamp().ToString(CultureInfo.InvariantCulture)); " is 120.
Long Statement,GoogleApi.Entities.Maps.DistanceMatrix.Request,DistanceMatrixRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\DistanceMatrix\Request\DistanceMatrixRequest.cs,GetQueryStringParameters,The length of the statement  "                    parameters.Add("departure_time"' this.DepartureTime.Value.DateTimeToUnixTimestamp().ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,GoogleApi.Entities.Maps.DistanceMatrix.Request,DistanceMatrixRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\DistanceMatrix\Request\DistanceMatrixRequest.cs,GetQueryStringParameters,The length of the statement  "            parameters.Add("departure_time"' this.DepartureTime.Value.DateTimeToUnixTimestamp().ToString(CultureInfo.InvariantCulture)); " is 124.
Long Statement,GoogleApi.Entities.Maps.Roads.Common,Location,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Roads\Common\Location.cs,ToString,The length of the statement  "            return this.Latitude.ToString(CultureInfo.InvariantCulture) + "'" + this.Longitude.ToString(CultureInfo.InvariantCulture); " is 122.
Long Statement,GoogleApi.Entities.Search,BaseSearchRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\BaseSearchRequest.cs,GetQueryStringParameters,The length of the statement  "                throw new InvalidOperationException($"SafetyLevel is not allowed for specified InterfaceLanguage: {this.Options.InterfaceLanguage}"); " is 133.
Long Statement,GoogleApi,HttpEngine<TRequest;TResponse>,C:\repos\vivet_GoogleApi\GoogleApi\HttpEngine.cs,QueryAsync,The length of the statement  "            var httpHandler = new HttpClientHandler { AutomaticDecompression = request.IsGzip ? DecompressionMethods.GZip | DecompressionMethods.Deflate : DecompressionMethods.None }; " is 171.
Magic Number,GoogleApi.Entities.Maps.Roads.NearestRoads.Request,NearestRoadsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Roads\NearestRoads\Request\NearestRoadsRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Points.Count() > 100)                  throw new ArgumentException("Path must contain less than 100 locations");
Magic Number,GoogleApi.Entities.Maps.Roads.SnapToRoads.Request,SnapToRoadsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Roads\SnapToRoads\Request\SnapToRoadsRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Path.Count() > 100)                  throw new ArgumentException("Path must contain less than 100 locations");
Magic Number,GoogleApi.Entities.Maps.Roads.SpeedLimits.Request,SpeedLimitsRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Maps\Roads\SpeedLimits\Request\SpeedLimitsRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Path == null || !this.Path.Any())              {                  if (this.PlaceIds == null || !this.PlaceIds.Any())                      throw new ArgumentException("Path or PlaceId's is required");                    if (this.PlaceIds.Count() > 100)                      throw new ArgumentException("Max PlaceId's exceeded");                    foreach (var placeId in this.PlaceIds)                  {                      parameters.Add("placeId"' placeId);                  }              }              else              {                  parameters.Add("path"' string.Join("|"' this.Path));              }
Magic Number,GoogleApi.Entities.Places.AutoComplete.Request,PlacesAutoCompleteRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\AutoComplete\Request\PlacesAutoCompleteRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Radius.HasValue && (this.Radius > 50000 || this.Radius < 1))                  throw new ArgumentException("Radius must be greater than or equal to 1 and less than or equal to 50.000");
Magic Number,GoogleApi.Entities.Places.Photos.Request,PlacesPhotosRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\Photos\Request\PlacesPhotosRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.MaxHeight.HasValue && (this.MaxHeight > 1600 || this.MaxHeight < 1))                  throw new ArgumentException("MaxHeight must be greater than or equal to 1 and less than or equal to 1.600");
Magic Number,GoogleApi.Entities.Places.Photos.Request,PlacesPhotosRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\Photos\Request\PlacesPhotosRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.MaxWidth.HasValue && (this.MaxWidth > 1600 || this.MaxWidth < 1))                  throw new ArgumentException("MaxWidth must be greater than or equal to 1 and less than or equal to 1.600");
Magic Number,GoogleApi.Entities.Places.QueryAutoComplete.Request,PlacesQueryAutoCompleteRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\QueryAutoComplete\Request\PlacesQueryAutoCompleteRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Radius.HasValue && (this.Radius > 50000 || this.Radius < 1))                  throw new ArgumentException("Radius must be greater than or equal to 1 and less than or equal to 50.000");
Magic Number,GoogleApi.Entities.Places.Search,BasePlacesSearchRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Places\Search\BasePlacesSearchRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Radius.HasValue && (this.Radius > 50000 || this.Radius < 1))                  throw new ArgumentException("Radius must be greater than or equal to 1 and less than or equal to 50.000");
Magic Number,GoogleApi.Entities.Search,BaseSearchRequest,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\BaseSearchRequest.cs,GetQueryStringParameters,The following statement contains a magic number: if (this.Options.Number != null)              {                  if (this.Options.Number > 10 || this.Options.Number < 1)                      throw new InvalidOperationException("Number must be between 1 and 10");                    parameters.Add("num"' this.Options.Number.ToString());              }
Magic Number,GoogleApi.Entities.Search.Common,SortExpression,C:\repos\vivet_GoogleApi\GoogleApi\Entities\Search\Common\SortExpression.cs,FromString,The following statement contains a magic number: int.TryParse(strings[2]' out var defualtValue);
Magic Number,GoogleApi.Entities.Search.Common,DateRestrict,C:\repos\vivet_GoogleApi\GoogleApi.net45\Entities\Search\Common\DateRestrict.cs,FromString,The following statement contains a magic number: int.TryParse(str.Substring(indexOf + 1' str.Length - indexOf - 2)' out var number);
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,EncodePolyLine,The following statement contains a magic number: var encodeDiff = (Action<int>) (diff =>              {                  var shifted = diff << 1;                  if (diff < 0)                      shifted = ~shifted;                    var rem = shifted;                    while (rem >= 0x20)                  {                      encodedString.Append((char) ((0x20 | (rem & 0x1f)) + 63));                      rem >>= 5;                  }                    encodedString.Append((char) (rem + 63));              });
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,EncodePolyLine,The following statement contains a magic number: var encodeDiff = (Action<int>) (diff =>              {                  var shifted = diff << 1;                  if (diff < 0)                      shifted = ~shifted;                    var rem = shifted;                    while (rem >= 0x20)                  {                      encodedString.Append((char) ((0x20 | (rem & 0x1f)) + 63));                      rem >>= 5;                  }                    encodedString.Append((char) (rem + 63));              });
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,EncodePolyLine,The following statement contains a magic number: var encodeDiff = (Action<int>) (diff =>              {                  var shifted = diff << 1;                  if (diff < 0)                      shifted = ~shifted;                    var rem = shifted;                    while (rem >= 0x20)                  {                      encodedString.Append((char) ((0x20 | (rem & 0x1f)) + 63));                      rem >>= 5;                  }                    encodedString.Append((char) (rem + 63));              });
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,EncodePolyLine,The following statement contains a magic number: foreach (var location in locations)              {                  if (location == null)                      continue;                    var lat = (int) Math.Round(location.Latitude * 1E5);                  var lng = (int) Math.Round(location.Longitude * 1E5);                    encodeDiff(lat - lastLat);                  encodeDiff(lng - lastLng);                    lastLat = lat;                  lastLng = lng;              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,EncodePolyLine,The following statement contains a magic number: foreach (var location in locations)              {                  if (location == null)                      continue;                    var lat = (int) Math.Round(location.Latitude * 1E5);                  var lng = (int) Math.Round(location.Longitude * 1E5);                    encodeDiff(lat - lastLat);                  encodeDiff(lng - lastLng);                    lastLat = lat;                  lastLng = lng;              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
Magic Number,GoogleApi,GoogleFunctions,C:\repos\vivet_GoogleApi\GoogleApi\GoogleFunctions.cs,DecodePolyLine,The following statement contains a magic number: while (index < polylineChars.Length)              {                  // Calculate next latitude                  var sum = 0;                  var shifter = 0;                  int next5Bits;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length)                      break;                    currentLat += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                    // Calculate next longitude                  sum = 0;                  shifter = 0;                    do                  {                      next5Bits = polylineChars[index++] - 63;                      sum |= (next5Bits & 31) << shifter;                      shifter += 5;                  } while (next5Bits >= 32 && index < polylineChars.Length);                    if (index >= polylineChars.Length && next5Bits >= 32)                      break;                    currentLng += (sum & 1) == 1 ? ~(sum >> 1) : sum >> 1;                  yield return new Location(Convert.ToDouble(currentLat) / 1E5' Convert.ToDouble(currentLng) / 1E5);              }
