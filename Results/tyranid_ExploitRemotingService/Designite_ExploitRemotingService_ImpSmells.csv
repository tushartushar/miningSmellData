Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,SetupServer,Cyclomatic complexity of the method is 14
Complex Method,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,Cyclomatic complexity of the method is 8
Complex Method,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,Cyclomatic complexity of the method is 11
Complex Method,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,Cyclomatic complexity of the method is 38
Long Parameter List,ExploitRemotingService,FakeMethod,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeMethod.cs,GetSerializationInfo,The method has 6 parameters.
Long Parameter List,ExploitRemotingService,FakeMethod,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeMethod.cs,Invoke,The method has 5 parameters.
Long Parameter List,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The method has 13 parameters.
Long Statement,ExploitRemotingService,FakeMethod,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeMethod.cs,GetObjectData,The length of the statement  "	GetSerializationInfo (info' _mb.Name' _mb.DeclaringType' _mb.ToString ()' MemberTypes.Method' _mb.GetGenericArguments ()); " is 122.
Long Statement,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,BindStream,The length of the statement  "			NetworkCredential cred = _username == null ? CredentialCache.DefaultNetworkCredentials : new NetworkCredential (_username' _password' _domain); " is 143.
Long Statement,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,BindStream,The length of the statement  "		NamedPipeClientStream stm = new NamedPipeClientStream ("."' _uri.Host' PipeDirection.InOut' PipeOptions.None' TokenImpersonationLevel.Impersonation' HandleInheritability.None); " is 176.
Long Statement,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,GetStaticMethod,The length of the statement  "		throw new InvalidOperationException (String.Format ("Could not get method {0} with types {1}"' name' String.Join ("'"' argTypes.Select (t => t.FullName).ToArray ()))); " is 167.
Long Statement,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,GetCreateInstance,The length of the statement  "	return new FakeMethod (typeof(Activator).GetMethod ("CreateInstance"' new Type[0]).MakeGenericMethod (typeof(T))' _ver); " is 120.
Long Statement,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,The length of the statement  "			CompilerResults res = MakeCall<CompilerResults> (uri' new FakeMethod (typeof(CodeDomProvider).GetMethod ("CompileAssemblyFromSource")' _ver)' cp' new string[] { " is 160.
Empty Catch Block,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,The method has an empty catch block.
Empty Catch Block,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,The method has an empty catch block.
Empty Catch Block,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,The method has an empty catch block.
Empty Catch Block,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,CreateRemoteClass,The method has an empty catch block.
Empty Catch Block,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,DetectMajorVersion,The method has an empty catch block.
Magic Number,ExploitRemotingService,FakeComObjRef,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeComObjRef.cs,MarshalObject,The following statement contains a magic number: return Convert.FromBase64String (displayName.Substring (7' displayName.Length - 8));  
Magic Number,ExploitRemotingService,FakeComObjRef,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeComObjRef.cs,MarshalObject,The following statement contains a magic number: return Convert.FromBase64String (displayName.Substring (7' displayName.Length - 8));  
Magic Number,ExploitRemotingService,FakeType,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\FakeType.cs,GetObjectData,The following statement contains a magic number: info.AddValue ("UnityType"' 4);  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The following statement contains a magic number: _port = 11111;  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The following statement contains a magic number: try {  	List<string> argsleft = p.Parse (args);  	if (debug) {  		Trace.Listeners.Add (new ConsoleTraceListener (true));  	}  	if (argsleft.Count < 2) {  		throw new InvalidOperationException ("Must specify a URI and command");  	}  	_uri = new Uri (argsleft [0]' UriKind.Absolute);  	_cmd = argsleft [1];  	_cmdargs = argsleft;  	_cmdargs.RemoveRange (0' 2);  }  catch (Exception ex) {  	Console.WriteLine (ex.Message);  	showhelp = true;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The following statement contains a magic number: try {  	List<string> argsleft = p.Parse (args);  	if (debug) {  		Trace.Listeners.Add (new ConsoleTraceListener (true));  	}  	if (argsleft.Count < 2) {  		throw new InvalidOperationException ("Must specify a URI and command");  	}  	_uri = new Uri (argsleft [0]' UriKind.Absolute);  	_cmd = argsleft [1];  	_cmdargs = argsleft;  	_cmdargs.RemoveRange (0' 2);  }  catch (Exception ex) {  	Console.WriteLine (ex.Message);  	showhelp = true;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The following statement contains a magic number: if (argsleft.Count < 2) {  	throw new InvalidOperationException ("Must specify a URI and command");  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ProcessArgs,The following statement contains a magic number: _cmdargs.RemoveRange (0' 2);  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: while (token != 0) {  	string name = token.ToString ();  	object value = null;  	switch (token) {  	case 1:  		{  			name = ReadHeaderString (reader);  			value = ReadHeaderString (reader);  		}  		break;  	default:  		byte dataType = reader.ReadByte ();  		switch (dataType) {  		case 0:  			break;  		case 1:  			value = ReadHeaderString (reader);  			break;  		case 2:  			value = reader.ReadByte ();  			break;  		case 3:  			value = reader.ReadUInt16 ();  			break;  		case 4:  			value = reader.ReadInt32 ();  			break;  		default:  			throw new InvalidOperationException ("Unknown header data type");  		}  		break;  	}  	Trace.WriteLine (String.Format ("Header: {0}={1}"' name' value));  	token = reader.ReadUInt16 ();  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: while (token != 0) {  	string name = token.ToString ();  	object value = null;  	switch (token) {  	case 1:  		{  			name = ReadHeaderString (reader);  			value = ReadHeaderString (reader);  		}  		break;  	default:  		byte dataType = reader.ReadByte ();  		switch (dataType) {  		case 0:  			break;  		case 1:  			value = ReadHeaderString (reader);  			break;  		case 2:  			value = reader.ReadByte ();  			break;  		case 3:  			value = reader.ReadUInt16 ();  			break;  		case 4:  			value = reader.ReadInt32 ();  			break;  		default:  			throw new InvalidOperationException ("Unknown header data type");  		}  		break;  	}  	Trace.WriteLine (String.Format ("Header: {0}={1}"' name' value));  	token = reader.ReadUInt16 ();  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: while (token != 0) {  	string name = token.ToString ();  	object value = null;  	switch (token) {  	case 1:  		{  			name = ReadHeaderString (reader);  			value = ReadHeaderString (reader);  		}  		break;  	default:  		byte dataType = reader.ReadByte ();  		switch (dataType) {  		case 0:  			break;  		case 1:  			value = ReadHeaderString (reader);  			break;  		case 2:  			value = reader.ReadByte ();  			break;  		case 3:  			value = reader.ReadUInt16 ();  			break;  		case 4:  			value = reader.ReadInt32 ();  			break;  		default:  			throw new InvalidOperationException ("Unknown header data type");  		}  		break;  	}  	Trace.WriteLine (String.Format ("Header: {0}={1}"' name' value));  	token = reader.ReadUInt16 ();  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (token) {  case 1:  	{  		name = ReadHeaderString (reader);  		value = ReadHeaderString (reader);  	}  	break;  default:  	byte dataType = reader.ReadByte ();  	switch (dataType) {  	case 0:  		break;  	case 1:  		value = ReadHeaderString (reader);  		break;  	case 2:  		value = reader.ReadByte ();  		break;  	case 3:  		value = reader.ReadUInt16 ();  		break;  	case 4:  		value = reader.ReadInt32 ();  		break;  	default:  		throw new InvalidOperationException ("Unknown header data type");  	}  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (token) {  case 1:  	{  		name = ReadHeaderString (reader);  		value = ReadHeaderString (reader);  	}  	break;  default:  	byte dataType = reader.ReadByte ();  	switch (dataType) {  	case 0:  		break;  	case 1:  		value = ReadHeaderString (reader);  		break;  	case 2:  		value = reader.ReadByte ();  		break;  	case 3:  		value = reader.ReadUInt16 ();  		break;  	case 4:  		value = reader.ReadInt32 ();  		break;  	default:  		throw new InvalidOperationException ("Unknown header data type");  	}  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (token) {  case 1:  	{  		name = ReadHeaderString (reader);  		value = ReadHeaderString (reader);  	}  	break;  default:  	byte dataType = reader.ReadByte ();  	switch (dataType) {  	case 0:  		break;  	case 1:  		value = ReadHeaderString (reader);  		break;  	case 2:  		value = reader.ReadByte ();  		break;  	case 3:  		value = reader.ReadUInt16 ();  		break;  	case 4:  		value = reader.ReadInt32 ();  		break;  	default:  		throw new InvalidOperationException ("Unknown header data type");  	}  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (dataType) {  case 0:  	break;  case 1:  	value = ReadHeaderString (reader);  	break;  case 2:  	value = reader.ReadByte ();  	break;  case 3:  	value = reader.ReadUInt16 ();  	break;  case 4:  	value = reader.ReadInt32 ();  	break;  default:  	throw new InvalidOperationException ("Unknown header data type");  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (dataType) {  case 0:  	break;  case 1:  	value = ReadHeaderString (reader);  	break;  case 2:  	value = reader.ReadByte ();  	break;  case 3:  	value = reader.ReadUInt16 ();  	break;  case 4:  	value = reader.ReadInt32 ();  	break;  default:  	throw new InvalidOperationException ("Unknown header data type");  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ReadHeaders,The following statement contains a magic number: switch (dataType) {  case 0:  	break;  case 1:  	value = ReadHeaderString (reader);  	break;  case 2:  	value = reader.ReadByte ();  	break;  case 3:  	value = reader.ReadUInt16 ();  	break;  case 4:  	value = reader.ReadInt32 ();  	break;  default:  	throw new InvalidOperationException ("Unknown header data type");  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,SendRequest,The following statement contains a magic number: writer.Write ((ushort)4);  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: switch (_cmd) {  case "exec":  	{  		bool wait = false;  		if (_cmdargs.Count > 0) {  			if (_cmdargs [0].Equals ("-wait"' StringComparison.OrdinalIgnoreCase)) {  				wait = true;  				_cmdargs.RemoveAt (0);  			}  		}  		if ((_cmdargs.Count == 0) || (_cmdargs.Count > 2)) {  			Console.Error.WriteLine ("Must specify at least 1 or two options for exec command");  		}  		else {  			string cmd = _cmdargs [0];  			string cmdline = _cmdargs.Count > 1 ? _cmdargs [1] : String.Empty;  			Process p = c.RunProcess (cmd' cmdline);  			Console.WriteLine ("Received new process id {0}"' p.Id);  			if (wait) {  				p.WaitForExit ();  			}  		}  	}  	break;  case "cmd":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for cmd command");  	}  	else {  		string ret = c.RunCommand (_cmdargs [0]);  		Console.WriteLine (ret);  	}  	break;  case "ls":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for ls command");  	}  	else {  		DirectoryInfo dir = c.GetDirectory (_cmdargs [0]);  		Console.WriteLine ("Listing {0} directory"' dir.FullName);  		foreach (DirectoryInfo d in dir.GetDirectories ()) {  			Console.WriteLine ("<DIR> {0}"' d.Name);  		}  		foreach (FileInfo f in dir.GetFiles ()) {  			Console.WriteLine ("{0} - Length {1}"' f.Name' f.Length);  		}  	}  	break;  case "put":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = File.ReadAllBytes (_cmdargs [0]);  		c.WriteFile (_cmdargs [1].ToString ()' data);  	}  	break;  case "get":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = c.ReadFile (_cmdargs [0]);  		File.WriteAllBytes (_cmdargs [1]' data);  	}  	break;  case "run":  	if (_cmdargs.Count < 1) {  		Console.Error.WriteLine ("Must specify an assembly file to upload");  	}  	else {  		byte[] asm = File.ReadAllBytes (_cmdargs [0]);  		string[] args = _cmdargs.Skip (1).ToArray ();  		Console.WriteLine ("Result: {0}"' c.ExecuteAssembly (asm' args));  	}  	break;  case "user":  	Console.WriteLine ("User: {0}"' c.GetUsername ());  	break;  case "osver":  	Console.WriteLine ("OS: {0}"' c.GetOSVersion ());  	break;  default:  	Console.Error.WriteLine (String.Format ("Unknown command {0}"' _cmd));  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: switch (_cmd) {  case "exec":  	{  		bool wait = false;  		if (_cmdargs.Count > 0) {  			if (_cmdargs [0].Equals ("-wait"' StringComparison.OrdinalIgnoreCase)) {  				wait = true;  				_cmdargs.RemoveAt (0);  			}  		}  		if ((_cmdargs.Count == 0) || (_cmdargs.Count > 2)) {  			Console.Error.WriteLine ("Must specify at least 1 or two options for exec command");  		}  		else {  			string cmd = _cmdargs [0];  			string cmdline = _cmdargs.Count > 1 ? _cmdargs [1] : String.Empty;  			Process p = c.RunProcess (cmd' cmdline);  			Console.WriteLine ("Received new process id {0}"' p.Id);  			if (wait) {  				p.WaitForExit ();  			}  		}  	}  	break;  case "cmd":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for cmd command");  	}  	else {  		string ret = c.RunCommand (_cmdargs [0]);  		Console.WriteLine (ret);  	}  	break;  case "ls":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for ls command");  	}  	else {  		DirectoryInfo dir = c.GetDirectory (_cmdargs [0]);  		Console.WriteLine ("Listing {0} directory"' dir.FullName);  		foreach (DirectoryInfo d in dir.GetDirectories ()) {  			Console.WriteLine ("<DIR> {0}"' d.Name);  		}  		foreach (FileInfo f in dir.GetFiles ()) {  			Console.WriteLine ("{0} - Length {1}"' f.Name' f.Length);  		}  	}  	break;  case "put":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = File.ReadAllBytes (_cmdargs [0]);  		c.WriteFile (_cmdargs [1].ToString ()' data);  	}  	break;  case "get":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = c.ReadFile (_cmdargs [0]);  		File.WriteAllBytes (_cmdargs [1]' data);  	}  	break;  case "run":  	if (_cmdargs.Count < 1) {  		Console.Error.WriteLine ("Must specify an assembly file to upload");  	}  	else {  		byte[] asm = File.ReadAllBytes (_cmdargs [0]);  		string[] args = _cmdargs.Skip (1).ToArray ();  		Console.WriteLine ("Result: {0}"' c.ExecuteAssembly (asm' args));  	}  	break;  case "user":  	Console.WriteLine ("User: {0}"' c.GetUsername ());  	break;  case "osver":  	Console.WriteLine ("OS: {0}"' c.GetOSVersion ());  	break;  default:  	Console.Error.WriteLine (String.Format ("Unknown command {0}"' _cmd));  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: switch (_cmd) {  case "exec":  	{  		bool wait = false;  		if (_cmdargs.Count > 0) {  			if (_cmdargs [0].Equals ("-wait"' StringComparison.OrdinalIgnoreCase)) {  				wait = true;  				_cmdargs.RemoveAt (0);  			}  		}  		if ((_cmdargs.Count == 0) || (_cmdargs.Count > 2)) {  			Console.Error.WriteLine ("Must specify at least 1 or two options for exec command");  		}  		else {  			string cmd = _cmdargs [0];  			string cmdline = _cmdargs.Count > 1 ? _cmdargs [1] : String.Empty;  			Process p = c.RunProcess (cmd' cmdline);  			Console.WriteLine ("Received new process id {0}"' p.Id);  			if (wait) {  				p.WaitForExit ();  			}  		}  	}  	break;  case "cmd":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for cmd command");  	}  	else {  		string ret = c.RunCommand (_cmdargs [0]);  		Console.WriteLine (ret);  	}  	break;  case "ls":  	if (_cmdargs.Count != 1) {  		Console.Error.WriteLine ("Must specify 1 argument for ls command");  	}  	else {  		DirectoryInfo dir = c.GetDirectory (_cmdargs [0]);  		Console.WriteLine ("Listing {0} directory"' dir.FullName);  		foreach (DirectoryInfo d in dir.GetDirectories ()) {  			Console.WriteLine ("<DIR> {0}"' d.Name);  		}  		foreach (FileInfo f in dir.GetFiles ()) {  			Console.WriteLine ("{0} - Length {1}"' f.Name' f.Length);  		}  	}  	break;  case "put":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = File.ReadAllBytes (_cmdargs [0]);  		c.WriteFile (_cmdargs [1].ToString ()' data);  	}  	break;  case "get":  	if (_cmdargs.Count != 2) {  		Console.Error.WriteLine ("Must specify localfile and remotefile argument");  	}  	else {  		byte[] data = c.ReadFile (_cmdargs [0]);  		File.WriteAllBytes (_cmdargs [1]' data);  	}  	break;  case "run":  	if (_cmdargs.Count < 1) {  		Console.Error.WriteLine ("Must specify an assembly file to upload");  	}  	else {  		byte[] asm = File.ReadAllBytes (_cmdargs [0]);  		string[] args = _cmdargs.Skip (1).ToArray ();  		Console.WriteLine ("Result: {0}"' c.ExecuteAssembly (asm' args));  	}  	break;  case "user":  	Console.WriteLine ("User: {0}"' c.GetUsername ());  	break;  case "osver":  	Console.WriteLine ("OS: {0}"' c.GetOSVersion ());  	break;  default:  	Console.Error.WriteLine (String.Format ("Unknown command {0}"' _cmd));  	break;  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: if ((_cmdargs.Count == 0) || (_cmdargs.Count > 2)) {  	Console.Error.WriteLine ("Must specify at least 1 or two options for exec command");  }  else {  	string cmd = _cmdargs [0];  	string cmdline = _cmdargs.Count > 1 ? _cmdargs [1] : String.Empty;  	Process p = c.RunProcess (cmd' cmdline);  	Console.WriteLine ("Received new process id {0}"' p.Id);  	if (wait) {  		p.WaitForExit ();  	}  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: if (_cmdargs.Count != 2) {  	Console.Error.WriteLine ("Must specify localfile and remotefile argument");  }  else {  	byte[] data = File.ReadAllBytes (_cmdargs [0]);  	c.WriteFile (_cmdargs [1].ToString ()' data);  }  
Magic Number,ExploitRemotingService,Program,C:\repos\tyranid_ExploitRemotingService\ExploitRemotingService\Program.cs,ExecuteCommand,The following statement contains a magic number: if (_cmdargs.Count != 2) {  	Console.Error.WriteLine ("Must specify localfile and remotefile argument");  }  else {  	byte[] data = c.ReadFile (_cmdargs [0]);  	File.WriteAllBytes (_cmdargs [1]' data);  }  
