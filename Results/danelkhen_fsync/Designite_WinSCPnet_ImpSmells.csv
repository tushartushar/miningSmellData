Implementation smell,Namespace,Class,File,Method,Description
Long Method,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseUrl,The method has 100 lines of code.
Complex Method,WinSCP,Session,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Extensions\Session.cs,SynchronizeDirectories2,Cyclomatic complexity of the method is 30
Complex Method,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ExeSessionProcess,Cyclomatic complexity of the method is 10
Complex Method,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvent,Cyclomatic complexity of the method is 24
Complex Method,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,Cyclomatic complexity of the method is 14
Complex Method,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeConsole,Cyclomatic complexity of the method is 11
Complex Method,WinSCP,TransferOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\TransferOptions.cs,ToSwitches,Cyclomatic complexity of the method is 24
Complex Method,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseUrl,Cyclomatic complexity of the method is 18
Complex Method,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseProtocol,Cyclomatic complexity of the method is 8
Complex Method,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,Cyclomatic complexity of the method is 9
Complex Method,WinSCP,TransferResumeSupport,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\TransferResumeSupport.cs,ToString,Cyclomatic complexity of the method is 15
Long Parameter List,WinSCP,Session,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Extensions\Session.cs,SynchronizeDirectories2,The method has 8 parameters.
Long Parameter List,WinSCP,GenericSecurity,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\GenericSecurity.cs,AccessRuleFactory,The method has 6 parameters.
Long Parameter List,WinSCP,GenericSecurity,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\GenericSecurity.cs,AuditRuleFactory,The method has 6 parameters.
Long Parameter List,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,PatientFileStream,The method has 5 parameters.
Long Parameter List,WinSCP,UnsafeNativeMethods,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\UnsafeNativeMethods.cs,CreateFileMapping,The method has 6 parameters.
Long Parameter List,WinSCP,UnsafeNativeMethods,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\UnsafeNativeMethods.cs,MapViewOfFile,The method has 5 parameters.
Long Parameter List,WinSCP,UnsafeNativeMethods,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\UnsafeNativeMethods.cs,RegGetValue,The method has 7 parameters.
Long Statement,WinSCP,Session,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Extensions\Session.cs,SynchronizeDirectories2,The length of the statement  "		WriteCommand (string.Format (CultureInfo.InvariantCulture' "synchronize {0} {1} {2} {3} {7} -criteria=\"{4}\" -- \"{5}\" \"{6}\""' modeName' BooleanSwitch (removeFiles' "delete")' BooleanSwitch (mirror' "mirror")' options.ToSwitches ()' criteriaName' Tools.ArgumentEscape (localPath)' Tools.ArgumentEscape (remotePath)' BooleanSwitch (options2.Preview' "preview"))); " is 366.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeChild,The length of the statement  "		_process.StartInfo.Arguments += string.Format (CultureInfo.InvariantCulture' " /console /consoleinstance={0}"' _instanceName); " is 126.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GrantAccess,The length of the statement  "		GenericSecurity security = new GenericSecurity (false' ResourceType.WindowObject' safeHandle' AccessControlSections.Access); " is 124.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GrantAccess,The length of the statement  "		security.AddAccessRule (new GenericAccessRule (new NTAccount (_session.ExecutableProcessUserName)' accessMask' AccessControlType.Allow)); " is 137.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The length of the statement  "				_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2))); " is 129.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The length of the statement  "				_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false))); " is 123.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessChoiceEvent,The length of the statement  "		_logger.WriteLine ("Options: [{0}]' Timer: [{1}]' Timeouting: [{2}]' Timeouted: [{3}]' Break: [{4}]' Result: [{5}]"' e.Options' e.Timer' e.Timeouting' e.Timeouted' e.Break' e.Result); " is 183.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,The length of the statement  "		_logger.WriteLine ("File Name [{0}] - Directory [{1}] - Overall Progress [{2}] - File Progress [{3}] - CPS [{4}]"' e.FileName' e.Directory' e.OverallProgress' e.FileProgress' e.CPS); " is 182.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeConsole,The length of the statement  "					throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "File mapping {0} already exists"' fileMappingName)); " is 141.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeConsole,The length of the statement  "					throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "Cannot create file mapping {0}"' fileMappingName)); " is 140.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CreateFileMapping,The length of the statement  "		return UnsafeNativeMethods.CreateFileMapping (new SafeFileHandle (new IntPtr (-1)' true)' securityAttributesPtr' FileMapProtection.PageReadWrite' 0' ConsoleCommStruct.Size' fileMappingName); " is 190.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,TryCreateEvent,The length of the statement  "	_logger.WriteLine ("Created event {0} with handle {1} with security {2}' new {3}"' name' ev.SafeWaitHandle.DangerousGetHandle ()' (security != null ? security.GetSecurityDescriptorSddlForm (AccessControlSections.All) : "none")' createdNew); " is 240.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CreateSecurity,The length of the statement  "	// When "running as user"' we have to grant the target user permissions to the objects (events and file mapping) explicitly " is 123.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CreateSecurity,The length of the statement  "			throw new SessionLocalException (_session' string.Format (CultureInfo.CurrentCulture' "Error resolving account {0}"' _session.ExecutableProcessUserName)' e); " is 157.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CreateEvent,The length of the statement  "		throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "Event {0} already exists"' name)); " is 123.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,AddInput,The length of the statement  "		throw new SessionLocalException (_session' string.Format (CultureInfo.CurrentCulture' "Input [{0}] is too long ({1} limit)"' str' marshalAsAttribute.SizeConst)); " is 161.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GetExecutablePath,The length of the statement  "				throw new SessionLocalException (_session' string.Format (CultureInfo.CurrentCulture' "{0} does not exists."' executablePath)); " is 127.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GetExecutablePath,The length of the statement  "			if (!TryFindExecutableInPath (GetAssemblyPath ()' out executablePath) && !TryFindExecutableInPath (GetInstallationPath (RegistryHive.CurrentUser)' out executablePath) && !TryFindExecutableInPath (GetInstallationPath (RegistryHive.LocalMachine)' out executablePath) && !TryFindExecutableInPath (GetDefaultInstallationPath ()' out executablePath)) { " is 347.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GetExecutablePath,The length of the statement  "				throw new SessionLocalException (_session' string.Format (CultureInfo.CurrentCulture' "The {0} executable was not found at location of the assembly ({1})' nor in an installation path. You may use Session.ExecutablePath property to explicitly set path to {0}."' ExeExecutableFileName' GetAssemblyPath ())); " is 305.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CheckVersion,The length of the statement  "		_logger.WriteLine ("Version of {0} is {1}' product {2} version is {3}"' exePath' version.FileVersion' version.ProductName' version.ProductVersion); " is 147.
Long Statement,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,CheckVersion,The length of the statement  "			throw new SessionLocalException (_session' string.Format (CultureInfo.CurrentCulture' "The version of {0} ({1}) does not match version of this assembly {2} ({3})."' exePath' version.ProductVersion' _logger.GetAssemblyFilePath ()' assemblyVersion.ProductVersion)); " is 263.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,GetAssemblyFilePath,The length of the statement  "			WriteLine (string.Format (CultureInfo.CurrentCulture' "Cannot locate path of assembly [{0}] neither from its code base [{1}]' nor from its location [{2}]"' assembly' codeBase' location)); " is 187.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,WriteCounters,The length of the statement  "				WriteLine ("{0}{1}{2} = [{3}]"' counter.CounterName' (string.IsNullOrEmpty (counter.InstanceName) ? string.Empty : "/")' counter.InstanceName' counter.NextValue ()); " is 165.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,WriteProcesses,The length of the statement  "				WriteLine ("{0}:{1} - {2} - {3}"' process.Id' process.ProcessName' GetProcessStartTime (process)' GetTotalProcessorTime (process)); " is 131.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,DoWriteLine,The length of the statement  "	string s = string.Format (CultureInfo.InvariantCulture' "[{0:yyyy-MM-dd HH:mm:ss.fffZ}] [{1:x4}] {2}{3}"' DateTime.Now' Thread.CurrentThread.ManagedThreadId' (indent > 0 ? new string (' '' indent * 2) : string.Empty)' message); " is 227.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,WriteEnvironmentInfo,The length of the statement  "	WriteLine ("Executing Assembly: {0}; Path: {1}; Location: {2}; Product: {3}"' assembly' path' assembly.Location' ((version != null) ? version.ProductVersion : "unknown")); " is 171.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,WriteEnvironmentInfo,The length of the statement  "	WriteLine ("User: {0}@{1}@{2}; Interactive: {3}"' Environment.UserName' Environment.UserDomainName' Environment.MachineName' Environment.UserInteractive); " is 154.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,WriteEnvironmentInfo,The length of the statement  "	WriteLine ("Console encoding: Input: {0} ({1}); Output: {2} ({3})"' Console.InputEncoding.EncodingName' Console.InputEncoding.CodePage' Console.OutputEncoding.EncodingName' Console.OutputEncoding.CodePage); " is 206.
Long Statement,WinSCP,Logger,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Logger.cs,SetLogLevel,The length of the statement  "		throw new ArgumentOutOfRangeException (string.Format (CultureInfo.CurrentCulture' "Logging level has to be in range 0-1")); " is 123.
Long Statement,WinSCP,Tools,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Tools.cs,AddRawParameters,The length of the statement  "			arguments += string.Format (CultureInfo.InvariantCulture' " {0}=\"{1}\""' rawSetting.Key' ArgumentEscape (rawSetting.Value)); " is 125.
Long Statement,WinSCP,RemoteFileInfo,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\RemoteFileInfo.cs,GetLength32,The length of the statement  "		throw new OverflowException (string.Format (CultureInfo.CurrentCulture' "Size {0} cannot be represented using 32-bit value"' Length)); " is 134.
Long Statement,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseUrl,The length of the statement  "			throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "{0} is not a valid port number"' portNumber)' "url"); " is 128.
Long Statement,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseUrl,The length of the statement  "				throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' "Unsupported connection parameter {0}"' parameterName)' "url"); " is 135.
Long Statement,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,GetIsTls,The length of the statement  "	return ((Protocol == Protocol.Ftp) && (FtpSecure != FtpSecure.None)) || ((Protocol == Protocol.Webdav) && WebdavSecure); " is 120.
Long Statement,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,SetSshHostKeyFingerprint,The length of the statement  "			throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' "SSH host key fingerprint \"{0}\" does not match pattern /{1}/"' s' _sshHostKeyRegex)); " is 159.
Long Statement,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,SetHostTlsCertificateFingerprint,The length of the statement  "			throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' "TLS host certificate fingerprint \"{0}\" does not match pattern /{1}/"' s' _tlsCertificateRegex)); " is 171.
Long Statement,WinSCP,SessionLocalException,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionLocalException.cs,CreateElementNotFound,The length of the statement  "	return new SessionLocalException (session' string.Format (CultureInfo.CurrentCulture' "Element \"{0}\" not found in the log file"' localName)); " is 143.
Long Statement,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The length of the statement  "				Session.Logger.WriteLine ("Read node {0}: {1} {2}{3}{4}"' _position' _reader.NodeType' _reader.Name' (_reader.HasValue && !string.IsNullOrEmpty (_reader.Name) && !string.IsNullOrEmpty (_reader.Value) ? "=" : string.Empty)' _reader.Value); " is 238.
Long Statement,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,LogContents,The length of the statement  "			using (StreamReader reader = new StreamReader (new FileStream (Session.XmlLogPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)' Encoding.UTF8)) { " is 154.
Complex Conditional,WinSCP,Callstack,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\Callstack.cs,Callstack,The conditional expression  "(method.IsConstructor && method.DeclaringType.IsAssignableFrom (type)) || ((method.MemberType == MemberTypes.Method) && ((MethodInfo)method).ReturnType.IsAssignableFrom (type))"  is complex.
Complex Conditional,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GetExecutablePath,The conditional expression  "!TryFindExecutableInPath (GetAssemblyPath ()' out executablePath) && !TryFindExecutableInPath (GetInstallationPath (RegistryHive.CurrentUser)' out executablePath) && !TryFindExecutableInPath (GetInstallationPath (RegistryHive.LocalMachine)' out executablePath) && !TryFindExecutableInPath (GetDefaultInstallationPath ()' out executablePath)"  is complex.
Magic Number,WinSCP,ConsoleCommStruct,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ConsoleCommStruct.cs,ConsoleCommStruct,The following statement contains a magic number: _payloadPtr = new IntPtr (_ptr.ToInt64 () + 12);  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	while (!AbortedOrExited ()) {  		_logger.WriteLineLevel (1' "Waiting for request event");  		if (_requestEvent.WaitOne (100' false)) {  			_logger.WriteLineLevel (1' "Got request event");  			ProcessEvent ();  		}  		if (_logger.LogLevel >= 1) {  			_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  			_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false)));  		}  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	while (!AbortedOrExited ()) {  		_logger.WriteLineLevel (1' "Waiting for request event");  		if (_requestEvent.WaitOne (100' false)) {  			_logger.WriteLineLevel (1' "Got request event");  			ProcessEvent ();  		}  		if (_logger.LogLevel >= 1) {  			_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  			_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false)));  		}  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: while (!AbortedOrExited ()) {  	_logger.WriteLineLevel (1' "Waiting for request event");  	if (_requestEvent.WaitOne (100' false)) {  		_logger.WriteLineLevel (1' "Got request event");  		ProcessEvent ();  	}  	if (_logger.LogLevel >= 1) {  		_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  		_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false)));  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: while (!AbortedOrExited ()) {  	_logger.WriteLineLevel (1' "Waiting for request event");  	if (_requestEvent.WaitOne (100' false)) {  		_logger.WriteLineLevel (1' "Got request event");  		ProcessEvent ();  	}  	if (_logger.LogLevel >= 1) {  		_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  		_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false)));  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: if (_requestEvent.WaitOne (100' false)) {  	_logger.WriteLineLevel (1' "Got request event");  	ProcessEvent ();  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: if (_logger.LogLevel >= 1) {  	_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  	_logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "Total memory allocated: {0}"' GC.GetTotalMemory (false)));  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessEvents,The following statement contains a magic number: _logger.WriteLine (string.Format (CultureInfo.InvariantCulture' "2nd generation collection count: {0}"' GC.CollectionCount (2)));  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInputEvent,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	while (!AbortedOrExited ()) {  		lock (_input) {  			if (_input.Count > 0) {  				e.Str = _input [0];  				e.Result = true;  				_input.RemoveAt (0);  				Print (false' e.Str + "\n");  				return;  			}  		}  		_inputEvent.WaitOne (100' false);  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInputEvent,The following statement contains a magic number: while (!AbortedOrExited ()) {  	lock (_input) {  		if (_input.Count > 0) {  			e.Str = _input [0];  			e.Result = true;  			_input.RemoveAt (0);  			Print (false' e.Str + "\n");  			return;  		}  	}  	_inputEvent.WaitOne (100' false);  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInputEvent,The following statement contains a magic number: _inputEvent.WaitOne (100' false);  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInitEvent,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	e.InputType = 3;  	// pipe  	e.OutputType = 3;  	// pipe  	e.WantsProgress = _session.WantsProgress;  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInitEvent,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	e.InputType = 3;  	// pipe  	e.OutputType = 3;  	// pipe  	e.WantsProgress = _session.WantsProgress;  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInitEvent,The following statement contains a magic number: e.InputType = 3;  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessInitEvent,The following statement contains a magic number: e.OutputType = 3;  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	_logger.WriteLine ("File Name [{0}] - Directory [{1}] - Overall Progress [{2}] - File Progress [{3}] - CPS [{4}]"' e.FileName' e.Directory' e.OverallProgress' e.FileProgress' e.CPS);  	FileTransferProgressEventArgs args = new FileTransferProgressEventArgs ();  	switch (e.Operation) {  	case ConsoleProgressEventStruct.ProgressOperation.Copy:  		args.Operation = ProgressOperation.Transfer;  		break;  	default:  		throw new ArgumentOutOfRangeException ("Unknown progress operation"' (Exception)null);  	}  	switch (e.Side) {  	case ConsoleProgressEventStruct.ProgressSide.Local:  		args.Side = ProgressSide.Local;  		break;  	case ConsoleProgressEventStruct.ProgressSide.Remote:  		args.Side = ProgressSide.Remote;  		break;  	default:  		throw new ArgumentOutOfRangeException ("Unknown progress side"' (Exception)null);  	}  	args.FileName = e.FileName;  	args.Directory = e.Directory;  	args.OverallProgress = ((double)e.OverallProgress) / 100;  	args.FileProgress = ((double)e.FileProgress) / 100;  	args.CPS = (int)e.CPS;  	_session.ProcessProgress (args);  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	_logger.WriteLine ("File Name [{0}] - Directory [{1}] - Overall Progress [{2}] - File Progress [{3}] - CPS [{4}]"' e.FileName' e.Directory' e.OverallProgress' e.FileProgress' e.CPS);  	FileTransferProgressEventArgs args = new FileTransferProgressEventArgs ();  	switch (e.Operation) {  	case ConsoleProgressEventStruct.ProgressOperation.Copy:  		args.Operation = ProgressOperation.Transfer;  		break;  	default:  		throw new ArgumentOutOfRangeException ("Unknown progress operation"' (Exception)null);  	}  	switch (e.Side) {  	case ConsoleProgressEventStruct.ProgressSide.Local:  		args.Side = ProgressSide.Local;  		break;  	case ConsoleProgressEventStruct.ProgressSide.Remote:  		args.Side = ProgressSide.Remote;  		break;  	default:  		throw new ArgumentOutOfRangeException ("Unknown progress side"' (Exception)null);  	}  	args.FileName = e.FileName;  	args.Directory = e.Directory;  	args.OverallProgress = ((double)e.OverallProgress) / 100;  	args.FileProgress = ((double)e.FileProgress) / 100;  	args.CPS = (int)e.CPS;  	_session.ProcessProgress (args);  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,The following statement contains a magic number: args.OverallProgress = ((double)e.OverallProgress) / 100;  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,ProcessProgressEvent,The following statement contains a magic number: args.FileProgress = ((double)e.FileProgress) / 100;  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeConsole,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	int attempts = 0;  	Random random = new Random ();  	int process = Process.GetCurrentProcess ().Id;  	do {  		if (attempts > MaxAttempts) {  			throw new SessionLocalException (_session' "Cannot find unique name for event object.");  		}  		int instanceNumber = random.Next (1000);  		_instanceName = string.Format (CultureInfo.InvariantCulture' "_{0}_{1}_{2}"' process' GetHashCode ()' instanceNumber);  		_logger.WriteLine ("Trying event {0}"' _instanceName);  		if (!TryCreateEvent (ConsoleEventRequest + _instanceName' out _requestEvent)) {  			_logger.WriteLine ("Event {0} is not unique"' _instanceName);  			_requestEvent.Close ();  			_requestEvent = null;  		}  		else {  			_logger.WriteLine ("Event {0} is unique"' _instanceName);  			_responseEvent = CreateEvent (ConsoleEventResponse + _instanceName);  			_cancelEvent = CreateEvent (ConsoleEventCancel + _instanceName);  			string fileMappingName = ConsoleMapping + _instanceName;  			_fileMapping = CreateFileMapping (fileMappingName);  			if (Marshal.GetLastWin32Error () == UnsafeNativeMethods.ERROR_ALREADY_EXISTS) {  				throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "File mapping {0} already exists"' fileMappingName));  			}  			if (_fileMapping.IsInvalid) {  				throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "Cannot create file mapping {0}"' fileMappingName));  			}  		}  		++attempts;  	}  	while (_requestEvent == null);  	using (ConsoleCommStruct commStruct = AcquireCommStruct ()) {  		commStruct.InitHeader ();  	}  	if (_session.GuardProcessWithJobInternal) {  		string jobName = ConsoleJob + _instanceName;  		_job = new Job (_logger' jobName);  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,InitializeConsole,The following statement contains a magic number: do {  	if (attempts > MaxAttempts) {  		throw new SessionLocalException (_session' "Cannot find unique name for event object.");  	}  	int instanceNumber = random.Next (1000);  	_instanceName = string.Format (CultureInfo.InvariantCulture' "_{0}_{1}_{2}"' process' GetHashCode ()' instanceNumber);  	_logger.WriteLine ("Trying event {0}"' _instanceName);  	if (!TryCreateEvent (ConsoleEventRequest + _instanceName' out _requestEvent)) {  		_logger.WriteLine ("Event {0} is not unique"' _instanceName);  		_requestEvent.Close ();  		_requestEvent = null;  	}  	else {  		_logger.WriteLine ("Event {0} is unique"' _instanceName);  		_responseEvent = CreateEvent (ConsoleEventResponse + _instanceName);  		_cancelEvent = CreateEvent (ConsoleEventCancel + _instanceName);  		string fileMappingName = ConsoleMapping + _instanceName;  		_fileMapping = CreateFileMapping (fileMappingName);  		if (Marshal.GetLastWin32Error () == UnsafeNativeMethods.ERROR_ALREADY_EXISTS) {  			throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "File mapping {0} already exists"' fileMappingName));  		}  		if (_fileMapping.IsInvalid) {  			throw new SessionLocalException (_session' string.Format (CultureInfo.InvariantCulture' "Cannot create file mapping {0}"' fileMappingName));  		}  	}  	++attempts;  }  while (_requestEvent == null);  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,Close,The following statement contains a magic number: using (_logger.CreateCallstack ()) {  	int timeout;  	#if DEBUG  	// in debug build' we expect the winscp.exe to run in tracing mode' being very slow  	timeout = 10000;  	#else  	                timeout = 2000;                 #endif  	_logger.WriteLine ("Waiting for process to exit ({0} ms)"' timeout);  	if (!_process.WaitForExit (timeout)) {  		_logger.WriteLine ("Killing process");  		_process.Kill ();  	}  }  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,Close,The following statement contains a magic number: timeout = 10000;  
Magic Number,WinSCP,ExeSessionProcess,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\ExeSessionProcess.cs,GetDefaultInstallationPath,The following statement contains a magic number: if (IntPtr.Size == 8) {  	// In .NET 4 we can use Environment.SpecialFolder.ProgramFilesX86  	programFiles = Environment.GetEnvironmentVariable ("ProgramFiles(x86)");  }  else {  	programFiles = Environment.GetFolderPath (Environment.SpecialFolder.ProgramFiles);  }  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: do {  	result = base.Read (array' offset' count);  	if (result == 0) {  		_session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  		_session.DispatchEvents (interval);  		_session.CheckForTimeout ();  		if (interval < 500) {  			interval *= 2;  		}  	}  }  // We always want to return something.  // No attempt to detect end real of file is needed'  // as we should not try to read beyond the final closing tag  while (result == 0);  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: do {  	result = base.Read (array' offset' count);  	if (result == 0) {  		_session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  		_session.DispatchEvents (interval);  		_session.CheckForTimeout ();  		if (interval < 500) {  			interval *= 2;  		}  	}  }  // We always want to return something.  // No attempt to detect end real of file is needed'  // as we should not try to read beyond the final closing tag  while (result == 0);  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: if (result == 0) {  	_session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  	_session.DispatchEvents (interval);  	_session.CheckForTimeout ();  	if (interval < 500) {  		interval *= 2;  	}  }  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: if (result == 0) {  	_session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  	_session.DispatchEvents (interval);  	_session.CheckForTimeout ();  	if (interval < 500) {  		interval *= 2;  	}  }  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: if (interval < 500) {  	interval *= 2;  }  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: if (interval < 500) {  	interval *= 2;  }  
Magic Number,WinSCP,PatientFileStream,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\PatientFileStream.cs,Read,The following statement contains a magic number: interval *= 2;  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,TextToNumeric,The following statement contains a magic number: for (int i = text.Length - 1; i >= 0; i--) {  	if (text [i] == UnsetSymbol) {  		// noop  	}  	else if (text [i] == CombinedSymbols [i]) {  		result |= flag | extendedFlag;  	}  	else if (text [i] == ExtendedSymbols [i]) {  		result |= extendedFlag;  	}  	else {  		result |= flag;  	}  	flag <<= 1;  	if (i % 3 == 0) {  		extendedFlag <<= 1;  	}  }  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,TextToNumeric,The following statement contains a magic number: if (i % 3 == 0) {  	extendedFlag <<= 1;  }  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,NumericToText,The following statement contains a magic number: while (i >= 0) {  	char symbol;  	if (extendedPos && ((numeric & (flag | extendedFlag)) == (flag | extendedFlag))) {  		symbol = CombinedSymbols [i];  	}  	else if ((numeric & flag) != 0) {  		symbol = BasicSymbols [i];  	}  	else if (extendedPos && ((numeric & extendedFlag) != 0)) {  		symbol = ExtendedSymbols [i];  	}  	else {  		symbol = UnsetSymbol;  	}  	buf [i] = symbol;  	flag <<= 1;  	i--;  	extendedPos = ((i % 3) == 2);  	if (extendedPos) {  		extendedFlag <<= 1;  	}  }  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,NumericToText,The following statement contains a magic number: while (i >= 0) {  	char symbol;  	if (extendedPos && ((numeric & (flag | extendedFlag)) == (flag | extendedFlag))) {  		symbol = CombinedSymbols [i];  	}  	else if ((numeric & flag) != 0) {  		symbol = BasicSymbols [i];  	}  	else if (extendedPos && ((numeric & extendedFlag) != 0)) {  		symbol = ExtendedSymbols [i];  	}  	else {  		symbol = UnsetSymbol;  	}  	buf [i] = symbol;  	flag <<= 1;  	i--;  	extendedPos = ((i % 3) == 2);  	if (extendedPos) {  		extendedFlag <<= 1;  	}  }  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,NumericToText,The following statement contains a magic number: extendedPos = ((i % 3) == 2);  
Magic Number,WinSCP,FilePermissions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\FilePermissions.cs,NumericToText,The following statement contains a magic number: extendedPos = ((i % 3) == 2);  
Magic Number,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,SessionOptions,The following statement contains a magic number: Timeout = new TimeSpan (0' 0' 15);  
Magic Number,WinSCP,SessionOptions,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\SessionOptions.cs,ParseUrl,The following statement contains a magic number: if ((hostInfo.Length >= 2) && (hostInfo [0] == '[') && ((index = hostInfo.IndexOf (']')) > 0)) {  	HostName = hostInfo.Substring (1' index - 1).Trim ();  	hostInfo = hostInfo.Substring (index + 1).Trim ();  	if (hostInfo.Length > 0) {  		if (hostInfo [0] != ':') {  			throw new ArgumentException ("Unexpected syntax after ]"' "url");  		}  		else {  			portNumber = hostInfo.Substring (1);  		}  	}  }  else {  	HostName = UriUnescape (CutToChar (ref hostInfo' ':'));  	portNumber = hostInfo;  }  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: do {  	if (_reader == null) {  		OpenLog ();  	}  	Debug.Assert (_reader != null);  	try {  		result = _reader.Read ();  		if (result) {  			++_position;  			Session.Logger.WriteLine ("Read node {0}: {1} {2}{3}{4}"' _position' _reader.NodeType' _reader.Name' (_reader.HasValue && !string.IsNullOrEmpty (_reader.Name) && !string.IsNullOrEmpty (_reader.Value) ? "=" : string.Empty)' _reader.Value);  			Session.GotOutput ();  		}  		else {  			Session.Logger.WriteLine ("Cannot read");  			if (!_closed) {  				// this should not happen as when the log is not closed'  				// we should get XmlException on reaching the end  				_closed = true;  				Cleanup ();  			}  			Session.CheckForTimeout ();  		}  	}  	catch (XmlException e) {  		Cleanup ();  		// We hope this code is not needed anymore.  		// keeping it just in case the XmlLogReader by passes  		// our override of PatientFileStream.Read uing other read method.  		#if !DEBUG  		                    if (!_closed)                     {                         // If log was not closed' it is likely the XML is not well-formed                         // (at least top-level <session/> tag is not closed)'                         // so we swallow the parsing errors here.                         Session.Logger.WriteLine("Error parsing session log file' but it is not closed yet' will retry");                         result = false;                     }                     else #endif  		{  			// check if the the root cause was session abort  			Session.CheckForTimeout ();  			LogContents ();  			throw new SessionLocalException (Session' "Error parsing session log file"' e);  		}  	}  	if (!result && !_closed) {  		Session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  		Session.DispatchEvents (interval);  		if (interval < 500) {  			interval *= 2;  		}  	}  }  while (!result && !_closed);  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: do {  	if (_reader == null) {  		OpenLog ();  	}  	Debug.Assert (_reader != null);  	try {  		result = _reader.Read ();  		if (result) {  			++_position;  			Session.Logger.WriteLine ("Read node {0}: {1} {2}{3}{4}"' _position' _reader.NodeType' _reader.Name' (_reader.HasValue && !string.IsNullOrEmpty (_reader.Name) && !string.IsNullOrEmpty (_reader.Value) ? "=" : string.Empty)' _reader.Value);  			Session.GotOutput ();  		}  		else {  			Session.Logger.WriteLine ("Cannot read");  			if (!_closed) {  				// this should not happen as when the log is not closed'  				// we should get XmlException on reaching the end  				_closed = true;  				Cleanup ();  			}  			Session.CheckForTimeout ();  		}  	}  	catch (XmlException e) {  		Cleanup ();  		// We hope this code is not needed anymore.  		// keeping it just in case the XmlLogReader by passes  		// our override of PatientFileStream.Read uing other read method.  		#if !DEBUG  		                    if (!_closed)                     {                         // If log was not closed' it is likely the XML is not well-formed                         // (at least top-level <session/> tag is not closed)'                         // so we swallow the parsing errors here.                         Session.Logger.WriteLine("Error parsing session log file' but it is not closed yet' will retry");                         result = false;                     }                     else #endif  		{  			// check if the the root cause was session abort  			Session.CheckForTimeout ();  			LogContents ();  			throw new SessionLocalException (Session' "Error parsing session log file"' e);  		}  	}  	if (!result && !_closed) {  		Session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  		Session.DispatchEvents (interval);  		if (interval < 500) {  			interval *= 2;  		}  	}  }  while (!result && !_closed);  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: if (!result && !_closed) {  	Session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  	Session.DispatchEvents (interval);  	if (interval < 500) {  		interval *= 2;  	}  }  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: if (!result && !_closed) {  	Session.Logger.WriteLine ("Waiting for log update and dispatching events for {0}"' interval);  	Session.DispatchEvents (interval);  	if (interval < 500) {  		interval *= 2;  	}  }  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: if (interval < 500) {  	interval *= 2;  }  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: if (interval < 500) {  	interval *= 2;  }  
Magic Number,WinSCP,SessionLogReader,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\Internal\SessionLogReader.cs,DoRead,The following statement contains a magic number: interval *= 2;  
Magic Number,WinSCP,TransferResumeSupport,C:\repos\danelkhen_fsync\lib-src\winscp\dotnet\TransferResumeSupport.cs,TransferResumeSupport,The following statement contains a magic number: _threshold = 100;  
