Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Data.Linq,DBConvert,C:\repos\FransBouma_LinqToSQL2\src\Miscellaneous\DbConvert.cs,ChangeType,The method has 168 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitSelect,The method has 104 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlHelpers,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlHelpers.cs,TranslateVBLikePattern,The method has 167 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,GetDbType,The method has 140 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,Parse,The method has 111 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The method has 104 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMethodCall,The method has 109 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The method has 108 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The method has 497 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The method has 219 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The method has 190 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Initialize,The method has 101 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,CreateDatabase,The method has 194 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Execute,The method has 124 lines of code.
Long Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The method has 165 lines of code.
Long Method,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,VisitSource,The method has 112 lines of code.
Long Method,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateNew,The method has 114 lines of code.
Long Method,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The method has 256 lines of code.
Long Method,System.Data.Linq.Provider.Common,SqlComparer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlComparer.cs,AreEqual,The method has 281 lines of code.
Long Method,System.Data.Linq.Provider.Common,SqlProjectionComparer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlProjectionComparer.cs,CanBeCompared,The method has 149 lines of code.
Long Method,System.Data.Linq.Provider.Common,SqlProjectionComparer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlProjectionComparer.cs,AreSimilar,The method has 228 lines of code.
Long Method,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,The method has 121 lines of code.
Long Method,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The method has 336 lines of code.
Long Method,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitInsert,The method has 120 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,ExpressionDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ExpressionDuplicator.cs,ExpandTogether,The method has 257 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The method has 182 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitUnaryOperator,The method has 124 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,AccessMember,The method has 241 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,ConvertToFetchedExpression,The method has 112 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,SqlVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlVisitor.cs,Visit,The method has 223 lines of code.
Long Method,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitMethodCall,The method has 112 lines of code.
Complex Method,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,SynchDependentData,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,IsMemberPendingGeneration,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,TrackUntrackedObjects,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,BuildEdgeMaps,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,Compare,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetRelations,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetCachedObject,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetKeyFromPredicate,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,Table<TEntity>,C:\repos\FransBouma_LinqToSQL2\src\Mapping\Table.cs,Attach,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq,Table<TEntity>,C:\repos\FransBouma_LinqToSQL2\src\Mapping\Table.cs,Attach,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitColumnRef,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitSelect,Cyclomatic complexity of the method is 20
Complex Method,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitInsert,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlHelpers,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlHelpers.cs,TranslateVBLikePattern,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,BuildFieldDeclarations,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMethodSupport,Cyclomatic complexity of the method is 14
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,CreateDatabase,Cyclomatic complexity of the method is 13
Complex Method,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,VisitSource,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateNew,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Provider.Common,SqlComparer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlComparer.cs,AreEqual,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Linq.Provider.Common,TypeSystem,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\TypeSystem.cs,FindIEnumerable,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Provider.Common,TypeSystem,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\TypeSystem.cs,ArgsMatchExact,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateEquals,Cyclomatic complexity of the method is 13
Complex Method,System.Data.Linq.Provider.Visitors,ColumnLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ColumnLifter.cs,VisitSelect,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,ConvertToFetchedSequence,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Visitors,OrderByLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\OrderByLifter.cs,VisitSelect,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Provider.Visitors,OrderByLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\OrderByLifter.cs,VisitRowNumber,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Linq.Provider.Visitors,CaseSimplifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\CaseSimplifier.cs,VisitSimpleCase,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Visitors,QueryUnionizer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\QueryUnionizer.cs,VisitSelect,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Provider.Visitors,SelectionLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SelectionLifter.cs,VisitSelect,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Linq.Provider.Visitors,SqlDuplicateColumnDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlDuplicateColumnDeflator.cs,VisitSelect,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Provider.Visitors,SingleTableQueryVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SingleTableQueryVisitor.cs,VisitNew,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,VisitBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitMethodCall,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Linq.Mapping,AttributedMetaAssociation,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaAssociation.cs,AttributedMetaAssociation,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Mapping,AttributedMetaType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaType.cs,InitDataMembers,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Mapping,AttributedMetaType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaType.cs,InitSpecialMember,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.Mapping,AttributedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedRootType.cs,AttributedRootType,Cyclomatic complexity of the method is 15
Complex Method,System.Data.Linq.Mapping,AttributedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedRootType.cs,Validate,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Linq.Mapping,AttributedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaModel.cs,InitStaticTables,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq.Mapping,AttributedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaModel.cs,InitFunctions,Cyclomatic complexity of the method is 12
Complex Method,System.Data.Linq.Mapping,MappedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedMetaModel.cs,InitStaticTableTypes,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Mapping,MappedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedRootType.cs,Validate,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Mapping,MappedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedRootType.cs,InitInheritedType,Cyclomatic complexity of the method is 10
Complex Method,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,InitDataMembers,Cyclomatic complexity of the method is 17
Complex Method,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,InitSpecialMember,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq.Mapping,MappingSource,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\MappingSource.cs,GetModel,Cyclomatic complexity of the method is 9
Long Parameter List,System.Data.Linq,StandardChangeTracker,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,Track,The method has 5 parameters. Parameters: mt' obj' visited' recurse' level
Long Parameter List,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,StandardTrackedObject,The method has 5 parameters. Parameters: tracker' type' current' original' isWeaklyTracked
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 6 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 7 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 8 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 9 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 10 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 11 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 12 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 13 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 14 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 15 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The method has 16 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,System.Data.Linq,SecurityUtils,C:\repos\FransBouma_LinqToSQL2\src\Miscellaneous\SecurityUtils.cs,SecureConstructorInvoke,The method has 5 parameters. Parameters: type' argTypes' args' allowNonPublic' extraFlags
Long Parameter List,System.Data.Linq,IProvider,C:\repos\FransBouma_LinqToSQL2\src\Interfaces\IProvider.cs,Execute,The method has 7 parameters. Parameters: query' queryInfo' factory' parentArgs' userArgs' subQueries' lastResult
Long Parameter List,System.Data.Linq,IProvider,C:\repos\FransBouma_LinqToSQL2\src\Interfaces\IProvider.cs,ExecuteAll,The method has 5 parameters. Parameters: query' queryInfos' factory' userArguments' subQueries
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlFactory,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlFactory.cs,FunctionCallDateAdd,The method has 5 parameters. Parameters: partName' value' expr' sourceExpression' asNullable
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlFactory,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlFactory.cs,FunctionCallDateTimeOffsetAdd,The method has 5 parameters. Parameters: partName' value' expr' sourceExpression' asNullable
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Execute,The method has 7 parameters. Parameters: query' queryInfo' factory' parentArgs' userArgs' subQueries' lastResult
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,ExecuteAll,The method has 5 parameters. Parameters: query' queryInfos' factory' userArguments' subQueries
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Execute,The method has 7 parameters. Parameters: query' queryInfo' factory' parentArgs' userArgs' subQueries' lastResult
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,ExecuteAll,The method has 5 parameters. Parameters: query' queryInfos' factory' userArguments' subQueries
Long Parameter List,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The method has 5 parameters. Parameters: resultShape' resultType' node' parentParameters' annotations
Long Parameter List,System.Data.Linq.Provider.Common,ExecuteResult,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ExecuteResult.cs,ExecuteResult,The method has 5 parameters. Parameters: command' parameters' session' value' useReturnValue
Long Parameter List,System.Data.Linq.Provider.Common,AdoCompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompiledQuery.cs,AdoCompiledQuery,The method has 5 parameters. Parameters: provider' query' queryInfos' factory' subQueries
Long Parameter List,System.Data.Linq.Provider.Common,QueryInfo,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryInfo.cs,QueryInfo,The method has 5 parameters. Parameters: query' commandText' parameters' resultShape' resultType
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReader<TDataReader;TObject>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReader.cs,ObjectReader,The method has 7 parameters. Parameters: session' namedColumns' globals' arguments' numberOfLocals' disposeSession' materializeFunc
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderBase<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderBase.cs,ObjectReaderBase,The method has 5 parameters. Parameters: session' namedColumns' globals' arguments' nLocals
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderFactory<TDataReader;TObject>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactory.cs,Create,The method has 6 parameters. Parameters: dataReader' disposeDataReader' provider' parentArgs' userArgs' subQueries
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderFactoryCache,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactoryCache.cs,GetFactory,The method has 5 parameters. Parameters: elementType' dataReaderType' mapping' options' projection
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderFactoryCache,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactoryCache.cs,AddFactory,The method has 6 parameters. Parameters: elementType' dataReaderType' mapping' options' projection' factory
Long Parameter List,System.Data.Linq.Provider.Common,CacheInfo,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactoryCache.cs,CacheInfo,The method has 6 parameters. Parameters: elementType' dataReaderType' mapping' options' projection' factory
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderSession<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderSession.cs,ObjectReaderSession,The method has 5 parameters. Parameters: dataReader' provider' parentArgs' userArgs' subQueries
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderSession<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderSession.cs,CreateReader,The method has 5 parameters. Parameters: fnMaterialize' namedColumns' globals' nLocals' disposeDataReader
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderSession<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderSession.cs,GetNextResult,The method has 5 parameters. Parameters: fnMaterialize' namedColumns' globals' nLocals' disposeDataReader
Long Parameter List,System.Data.Linq.Provider.Common,Rereader,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Rereader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.Linq.Provider.Common,Rereader,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Rereader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,FunctionCallDateAdd,The method has 5 parameters. Parameters: partName' value' expr' sourceExpression' asNullable
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,FunctionCallDateTimeOffsetAdd,The method has 5 parameters. Parameters: partName' value' expr' sourceExpression' asNullable
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Value,The method has 5 parameters. Parameters: clrType' sqlType' value' isClientSpecified' sourceExpression
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Binary,The method has 5 parameters. Parameters: nodeType' left' right' method' clrType
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Case,The method has 5 parameters. Parameters: clrType' discriminator' matches' values' sourceExpression
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,TypeCase,The method has 5 parameters. Parameters: clrType' rowType' discriminator' whens' sourceExpression
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,New,The method has 6 parameters. Parameters: type' cons' args' argMembers' bindings' sourceExpression
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,MethodCall,The method has 5 parameters. Parameters: returnType' method' obj' args' sourceExpression
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,FunctionCall,The method has 5 parameters. Parameters: clrType' sqlType' name' args' source
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,TableValuedFunctionCall,The method has 5 parameters. Parameters: rowType' clrType' name' args' source
Long Parameter List,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,MakeJoin,The method has 5 parameters. Parameters: joinType' location' alias' condition' source
Long Parameter List,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitJoin,The method has 5 parameters. Parameters: outerSequence' innerSequence' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitGroupJoin,The method has 5 parameters. Parameters: outerSequence' innerSequence' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Data.Linq.Provider.Common,SqlBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlBinder.cs,SqlBinder,The method has 6 parameters. Parameters: translator' sqlFactory' model' shape' columnizer' canUseOuterApply
Long Parameter List,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjection,The method has 5 parameters. Parameters: item' rowType' allowDeferred' link' source
Long Parameter List,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjectionInternal,The method has 6 parameters. Parameters: item' rowType' members' allowDeferred' link' source
Long Parameter List,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateAssociation,The method has 5 parameters. Parameters: context' association' otherSource' keyValues' thisInstance
Long Parameter List,System.Data.Linq.Provider.Common,ObjectReaderCompiler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderCompiler.cs,CreateSession,The method has 5 parameters. Parameters: reader' provider' parentArgs' userArgs' subQueries
Long Parameter List,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,MemberAccessBinder,The method has 7 parameters. Parameters: binder' translator' columnizer' sqlFactory' model' shape' canUseOuterApply
Long Parameter List,System.Data.Linq.Provider.Visitors,CaseSimplifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\CaseSimplifier.cs,TryToWriteAsReducedCase,The method has 5 parameters. Parameters: caseType' discriminator' newWhens' elseCandidate' originalWhenCount
Long Parameter List,System.Data.Linq.Provider.Interfaces,IObjectReaderCompiler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Interfaces\IObjectReaderCompiler.cs,CreateSession,The method has 5 parameters. Parameters: reader' provider' parentArgs' userArgs' subQueries
Long Parameter List,System.Data.Linq.Provider.Interfaces,IObjectReaderFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Interfaces\IObjectReaderFactory.cs,Create,The method has 6 parameters. Parameters: reader' disposeReader' provider' parentArgs' userArgs' subQueries
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlBetween,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlBetween.cs,SqlBetween,The method has 6 parameters. Parameters: clrType' sqlType' expr' start' end' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlBinary,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlBinary.cs,SqlBinary,The method has 5 parameters. Parameters: nt' clrType' sqlType' left' right
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlBinary,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlBinary.cs,SqlBinary,The method has 6 parameters. Parameters: nt' clrType' sqlType' left' right' method
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlColumn,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlColumn.cs,SqlColumn,The method has 6 parameters. Parameters: clrType' sqlType' name' member' expr' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlFunctionCall,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlFunctionCall.cs,SqlFunctionCall,The method has 5 parameters. Parameters: clrType' sqlType' name' args' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlFunctionCall,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlFunctionCall.cs,SqlFunctionCall,The method has 6 parameters. Parameters: nodeType' clrType' sqlType' name' args' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlGrouping,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlGrouping.cs,SqlGrouping,The method has 5 parameters. Parameters: clrType' sqlType' key' group' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlIn,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlIn.cs,SqlIn,The method has 5 parameters. Parameters: clrType' sqlType' expression' values' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlJoin,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlJoin.cs,SqlJoin,The method has 5 parameters. Parameters: type' left' right' cond' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlJoinedCollection,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlJoinedCollection.cs,SqlJoinedCollection,The method has 5 parameters. Parameters: clrType' sqlType' expression' count' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlLike,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlLike.cs,SqlLike,The method has 6 parameters. Parameters: clrType' sqlType' expr' pattern' escape' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlLink,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlLink.cs,SqlLink,The method has 9 parameters. Parameters: id' rowType' clrType' sqlType' expression' member' keyExpressions' expansion' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlMethodCall,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlMethodCall.cs,SqlMethodCall,The method has 6 parameters. Parameters: clrType' sqlType' method' obj' args' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlNew,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlNew.cs,SqlNew,The method has 7 parameters. Parameters: metaType' sqlType' cons' args' argMembers' members' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlTableValuedFunctionCall,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlTableValuedFunctionCall.cs,SqlTableValuedFunctionCall,The method has 6 parameters. Parameters: rowType' clrType' sqlType' name' args' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlTypeCase,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlTypeCase.cs,SqlTypeCase,The method has 6 parameters. Parameters: clrType' sqlType' rowType' discriminator' whens' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlUnary,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlUnary.cs,SqlUnary,The method has 5 parameters. Parameters: nt' clrType' sqlType' expr' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlUnary,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlUnary.cs,SqlUnary,The method has 6 parameters. Parameters: nt' clrType' sqlType' expr' method' sourceExpression
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlUserColumn,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlUserColumn.cs,SqlUserColumn,The method has 6 parameters. Parameters: clrType' sqlType' query' name' isRequired' source
Long Parameter List,System.Data.Linq.Provider.NodeTypes,SqlValue,C:\repos\FransBouma_LinqToSQL2\src\Provider\NodeTypes\SqlValue.cs,SqlValue,The method has 5 parameters. Parameters: clrType' sqlType' value' isClientSpecified' sourceExpression
Long Parameter List,System.Data.Linq.Mapping,Accessor<T;V;V2>,C:\repos\FransBouma_LinqToSQL2\src\Mapping\Accesssors\PropertyAccessor.cs,Accessor,The method has 5 parameters. Parameters: pi' dget' dset' drset' storage
Long Parameter List,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The method has 5 parameters. Parameters: objectDeclaringType' accessor' accessorValue' accessorDeferredValue' accessorDeferredSource
Long Parameter List,System.Data.Linq.Mapping,MethodFinder,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\MethodFinder.cs,FindMethod,The method has 5 parameters. Parameters: type' name' flags' argTypes' allowInherit
Long Parameter List,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The method has 5 parameters. Parameters: declaringType' accessor' accessorValue' accessorDeferredValue' accessorDeferredSource
Long Parameter List,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,MappedType,The method has 5 parameters. Parameters: model' table' typeMapping' type' inheritanceRoot
Long Identifier,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,,The length of the parameter haveInitializedDeferredLoaders is 30.
Long Identifier,System.Data.Linq,SecurityUtils,C:\repos\FransBouma_LinqToSQL2\src\Miscellaneous\SecurityUtils.cs,,The length of the parameter restrictedMemberAccessPermission is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InconsistentAssociationAndKeyChange is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotRemoveRelationshipBecauseOneSideCannotBeNull is 52.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter EntitySetModifiedDuringEnumeration is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ProviderDoesNotImplementRequiredInterface is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter OptionsCannotBeModifiedAfterQuery is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter DeferredLoadingRequiresObjectTracking is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SubqueryDoesNotSupportOperator is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter LoadOptionsChangeNotAllowedAfterQuery is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter DataContextCannotBeUsedAfterDispose is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotPerformCUDOnReadOnlyTable is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter DatabaseGeneratedAlreadyExistingKey is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter EntitySetDataBindingWithAbstractBaseClass is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter EntitySetDataBindingWithNonPublicDefaultConstructor is 51.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InvalidLoadOptionsLoadMemberSpecification is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotAttachAlreadyExistingEntity is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotAttachAsModifiedWithoutOriginalState is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotPerformOperationDuringSubmitChanges is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotPerformOperationOutsideSubmitChanges is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotPerformOperationForUntrackedObject is 40.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter QueryWasCompiledForDifferentMappingSource is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotCreateAccessorToProperty is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnableToAssignValueToReadonlyProperty is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InheritanceTypeDoesNotDeriveFromRoot is 36.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter AbstractClassAssignInheritanceDiscriminator is 43.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotGetInheritanceDefaultFromNonInheritanceClass is 50.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InheritanceTypeHasMultipleDiscriminators is 40.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InheritanceCodeUsedForMultipleTypes is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InheritanceTypeHasMultipleDefaults is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InheritanceHierarchyDoesNotDefineDefault is 40.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NonInheritanceClassHasDiscriminator is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter IncorrectAutoSyncSpecification is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TwoMembersMarkedAsPrimaryKeyAndDBGenerated is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TwoMembersMarkedAsInheritanceDiscriminator is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotFindRuntimeTypeForMapping is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotFindElementTypeInModel is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter BadFunctionTypeInMethodMapping is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter IncorrectNumberOfParametersMappedForMethod is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InvalidDeleteOnNullSpecification is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MappedMemberHadNoCorrespondingMemberInType is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TooManyResultTypesDeclaredForFunction is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NoResultTypesDeclaredForFunction is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter DiscriminatorClrTypeNotSupported is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter PrimaryKeyInSubTypeNotSupported is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InvalidUseOfGenericMethodAsMappedFunction is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MappingOfInterfacesMemberIsNotSupported is 39.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter VbLikeDoesNotSupportMultipleCharacterRanges is 43.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ProviderCannotBeUsedAfterDispose is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotDetermineDbGeneratedSqlType is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CreateDatabaseFailedBecauseOfClassWithNoMembers is 47.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CreateDatabaseFailedBecauseOfContextWithNoTables is 48.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CreateDatabaseFailedBecauseSqlCEDatabaseAlreadyExists is 53.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter DistributedTransactionsAreNotAllowed is 36.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotEnumerateResultsMoreThanOnce is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MethodNotMappedToStoredProcedure is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ToStringOnlySupportedForPrimitiveTypes is 38.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TransactionDoesNotMatchConnection is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnsupportedDateTimeConstructorForm is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnsupportedDateTimeOffsetConstructorForm is 40.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnsupportedStringConstructorForm is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnsupportedTimeSpanConstructorForm is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnsupportedTypeConstructorForm is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter WrongNumberOfValuesInCollectionArgument is 39.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NonConstantExpressionsNotSupportedFor is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NonConstantExpressionsNotSupportedForRounding is 45.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CompiledQueryAgainstMultipleShapesNotSupported is 46.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TextNTextAndImageCannotOccurInDistinct is 38.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TextNTextAndImageCannotOccurInUnion is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter IndexOfWithStringComparisonArgNotSupported is 42.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter LastIndexOfWithStringComparisonArgNotSupported is 46.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ConvertToCharFromBoolNotSupported is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ConvertToDateTimeOnlyForDateTimeOrString is 40.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotTranslateExpressionToSql is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SkipIsValidOnlyOverOrderedQueries is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SkipRequiresSingleTableQueryWithPKs is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NoMethodInTypeMatchingArguments is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ExpressionNotDeferredQuerySource is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CannotCompareItemsAssociatedWithDifferentTable is 46.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ClrBoolDoesNotAgreeWithSqlType is 30.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ColumnClrTypeDoesNotAgreeWithExpressionsClrType is 47.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ColumnIsDefinedInMultiplePlaces is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ColumnIsNotAccessibleThroughGroupBy is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ColumnIsNotAccessibleThroughDistinct is 36.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CapturedValuesCannotBeSequences is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotTranslateExpressionForReading is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter InvalidReferenceToRemovedAliasDuringDeflation is 45.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MethodHasNoSupportConversionToSql is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MethodFormHasNoSupportConversionToSql is 37.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter QueryOperatorOverloadNotSupported is 33.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter TypeBinaryOperatorNotRecognized is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnexpectedSharedExpressionReference is 35.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter UnionOfIncompatibleDynamicTypes is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter IntersectNotSupportedForHierarchicalTypes is 41.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter ExceptNotSupportedForHierarchicalTypes is 38.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter NonCountAggregateFunctionsAreNotValidOnProjections is 50.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter GroupingNotSupportedAsOrderCriterion is 36.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SelectManyDoesNotSupportStrings is 31.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SequenceOperatorsNotSupportedForType is 36.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter SkipNotSupportedForSequenceTypes is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter QueryOnLocalCollectionNotSupported is 34.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter GeneralCollectionMaterializationNotSupported is 44.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter CouldNotConvertToPropertyOrField is 32.
Long Identifier,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,,The length of the parameter MappedTypeMustHaveDefaultConstructor is 36.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the parameter startPlusDaysPlusMsecPlusUSecPlusNSec is 37.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the parameter getStringContainsPatternForced is 30.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the parameter getStringStartsWithPatternForced is 32.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the parameter getStringEndsWithPatternForced is 30.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Initialize,The length of the parameter fileOrServerOrConnectionString is 30.
Long Identifier,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetConnectionString,The length of the parameter fileOrServerOrConnectionString is 30.
Long Identifier,System.Data.Linq.Provider.Common,SqlCrossApplyToCrossJoin,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlCrossApplyToCrossJoin.cs,Reduce,The length of the parameter providerModesWithIncompatibilities is 34.
Long Identifier,System.Data.Linq.Provider.Common,Reducer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlCrossApplyToCrossJoin.cs,Reducer,The length of the parameter providerModesWithIncompatibilities is 34.
Long Identifier,System.Data.Linq.Provider.Common,Reducer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlCrossApplyToCrossJoin.cs,,The length of the parameter _providerModesWithIncompatibilities is 35.
Long Identifier,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,,The length of the parameter _parameterExpressionToSqlExpression is 35.
Long Identifier,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,,The length of the parameter _parameterExpressionToExpression is 32.
Long Statement,System.Data.Linq,StandardChangeTracker,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,AcceptChanges,The length of the statement  "			List<StandardTrackedObject> list = new List<StandardTrackedObject>((IEnumerable<StandardTrackedObject>)this.items.Values); " is 122.
Long Statement,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,InitializeDeferredLoaders,The length of the statement  "					IEnumerable<MetaDataMember> deferredMembers = this.Type.PersistentDataMembers.Where(p => p.IsDeferred && !p.IsAssociation); " is 123.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,SubmitChanges,The length of the statement  "				// First we need to rollback any value that have already been auto-[....]'d' since the values are no longer valid on the server " is 127.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,SubmitChanges,The length of the statement  "					Debug.Assert(syncDependentItem.IsNew || syncDependentItem.IsPossiblyModified' "SynchDependent data should only be rolled back for new and modified objects."); " is 158.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeyReferences,The length of the statement  "					// This cache lookup is only possible if the other key is the primary key' since that is the only way items can be found in the cache. " is 134.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeyReferences,The length of the statement  "								System.Collections.IList collection = assoc.OtherMember.MemberAccessor.GetBoxedValue(cached) as System.Collections.IList; " is 121.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeyReferences,The length of the statement  "						// We are explicitly not calling ClearForeignKeysHelper because it breaks existing shipped behavior and we want to maintain backward compatibility " is 146.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeyReferences,The length of the statement  "						// This is a unidirectional relationship or we have no way to look up the other side in the cache' so just clear our own side " is 125.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeysHelper,The length of the statement  "			// If this member is one of our deferred loaders' and it does not already have a value' explicitly set the deferred source to " is 125.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeysHelper,The length of the statement  "			// This is only necessary if the value has not already been assigned or set' because otherwise we won't implicitly load anyway when the member is accessed. " is 155.
Long Statement,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,ClearForeignKeysHelper,The length of the statement  "				!(thisMember.StorageAccessor.HasAssignedValue(trackedInstance) || thisMember.StorageAccessor.HasLoadedValue(trackedInstance))) " is 126.
Long Statement,System.Data.Linq,EntitySet<TEntity>,C:\repos\FransBouma_LinqToSQL2\src\Mapping\EntitySet.cs,AddRange,The length of the statement  "			// convert to List in case adding elements here removes them from the 'collection' (ie entityset to entityset assignment) " is 121.
Long Statement,System.Data.Linq,EntitySet<TEntity>,C:\repos\FransBouma_LinqToSQL2\src\Mapping\EntitySet.cs,Remove,The length of the statement  "				// so we shouldn't fire the event since the list itself will not be changed' even though the Remove will still be tracked " is 121.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TResult>; " is 126.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TArg11' TResult>; " is 134.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TArg11' TArg12' TResult>; " is 142.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TArg11' TArg12' TArg13' TResult>; " is 150.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TArg11' TArg12' TArg13' TArg14' TResult>; " is 158.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Compile,The length of the statement  "                return new CompiledQuery(query).Invoke<TArg0' TArg1' TArg2' TArg3' TArg4' TArg5' TArg6' TArg7' TArg8' TArg9' TArg10' TArg11' TArg12' TArg13' TArg14' TArg15' TResult>; " is 166.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10}); " is 123.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11}); " is 130.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12}); " is 137.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13}); " is 144.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14}); " is 151.
Long Statement,System.Data.Linq,CompiledQuery,C:\repos\FransBouma_LinqToSQL2\src\Querying\CompiledQuery.cs,Invoke,The length of the statement  "            return (TResult) this.ExecuteQuery(arg0' new object[] {arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15}); " is 158.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,GetTable,The length of the statement  "				tb = (ITable)Activator.CreateInstance(tbType' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new object[] { this' metaTable }' null); " is 162.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ValidateTable,The length of the statement  "					throw Error.NonEntityAssociationMapping(assoc.ThisMember.DeclaringType.Type' assoc.ThisMember.Name' assoc.ThisMember.DeclaringType.Type); " is 137.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ValidateTable,The length of the statement  "					throw Error.NonEntityAssociationMapping(assoc.ThisMember.DeclaringType.Type' assoc.ThisMember.Name' assoc.OtherType.Type); " is 122.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ExecuteQuery,The length of the statement  "			return (IEnumerable<TResult>)this.ExecuteMethodCall(this' ((MethodInfo)MethodInfo.GetCurrentMethod()).MakeGenericMethod(typeof(TResult))' query' parameters).ReturnValue; " is 169.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ExecuteQuery,The length of the statement  "				_miExecuteQuery = typeof(DataContext).GetMethods().Single(m => m.Name == "ExecuteQuery" && m.GetParameters().Length == 2); " is 122.
Long Statement,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ExecuteQuery,The length of the statement  "			return (IEnumerable)this.ExecuteMethodCall(this' _miExecuteQuery.MakeGenericMethod(elementType)' query' parameters).ReturnValue; " is 128.
Long Statement,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetObjectQuery,The length of the statement  "			return Expression.Call(typeof(Queryable)' "Where"' new Type[] { table.ElementType }' table.Expression' Expression.Lambda(whereExpression' serverItem)); " is 151.
Long Statement,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetDataMemberQuery,The length of the statement  "					thisSource = Expression.Call(typeof(Enumerable)' "Cast"' new Type[] { association.ThisMember.DeclaringType.Type }' thisSource); " is 127.
Long Statement,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetDataMemberQuery,The length of the statement  "				Expression thisInstance = Expression.Call(typeof(Enumerable)' "FirstOrDefault"' new Type[] { association.ThisMember.DeclaringType.Type }' " is 137.
Long Statement,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetObjectByKey,The length of the statement  "				target = ((IEnumerable)this._context.Provider.Execute(this.GetObjectQuery(type' keyValues)).ReturnValue).OfType<object>().SingleOrDefault(); " is 140.
Long Statement,System.Data.Linq,DeferredSourceFactory<T>,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,ExecuteKeyQuery,The length of the statement  "					ReadOnlyCollection<MetaDataMember> members = this.member.IsAssociation ? this.member.Association.OtherKey : this.member.DeclaringType.IdentityMembers; " is 150.
Long Statement,System.Data.Linq,DeferredSourceFactory<T>,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,ExecuteKeyQuery,The length of the statement  "				return ((IEnumerable<T>)this.query.Execute(this.services.Context.Provider' new object[] { keyValues }).ReturnValue).GetEnumerator(); " is 132.
Long Statement,System.Data.Linq,DBConvert,C:\repos\FransBouma_LinqToSQL2\src\Miscellaneous\DbConvert.cs,ChangeType,The length of the statement  "                    return Enum.ToObject(toType' Convert.ChangeType(value' Enum.GetUnderlyingType(toType)' Globalization.CultureInfo.InvariantCulture)); " is 132.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetInsertCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Insert"' new Type[] { item.Type.InheritanceRoot.Type' resultSelector.Body.Type }' Expression.Constant(item.Current)' resultSelector); " is 188.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetInsertCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Insert"' new Type[] { item.Type.InheritanceRoot.Type }' Expression.Constant(item.Current)); " is 146.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,AutoSyncMembers,The length of the statement  "			System.Diagnostics.Debug.Assert(item.IsNew || item.IsPossiblyModified' "AutoSyncMembers should only be called for new and modified objects."); " is 142.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetUpdateCommand,The length of the statement  "					return Expression.Call(typeof(DMLMethodPlaceholders)' "Update"' new Type[] { rowTypeRoot.Type' resultSelector.Body.Type }' Expression.Constant(tracked.Current)' check' resultSelector); " is 184.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetUpdateCommand,The length of the statement  "					return Expression.Call(typeof(DMLMethodPlaceholders)' "Update"' new Type[] { rowTypeRoot.Type' resultSelector.Body.Type }' Expression.Constant(tracked.Current)' resultSelector); " is 177.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetUpdateCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Update"' new Type[] { rowTypeRoot.Type }' Expression.Constant(tracked.Current)' check); " is 142.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetUpdateCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Update"' new Type[] { rowTypeRoot.Type }' Expression.Constant(tracked.Current)); " is 135.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetDeleteCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Delete"' new Type[] { rowTypeRoot.Type }' Expression.Constant(original)' check); " is 135.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetDeleteCommand,The length of the statement  "				return Expression.Call(typeof(DMLMethodPlaceholders)' "Delete"' new Type[] { rowTypeRoot.Type }' Expression.Constant(original)); " is 128.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetDeleteVerificationCommand,The length of the statement  "			Expression where = Expression.Call(typeof(Queryable)' "Where"' new Type[] { table.ElementType }' table.Expression' pred); " is 121.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetDeleteVerificationCommand,The length of the statement  "			Expression select = Expression.Call(typeof(Queryable)' "Select"' new Type[] { table.ElementType' typeof(int?) }' where' selector); " is 130.
Long Statement,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetDeleteVerificationCommand,The length of the statement  "			Expression singleOrDefault = Expression.Call(typeof(Queryable)' "SingleOrDefault"' new Type[] { typeof(int?) }' select); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,BuildFieldDeclarations,The length of the statement  "							sb.Append(string.Format(Globalization.CultureInfo.InvariantCulture' "  {0} "' SqlIdentifier.QuoteCompoundIdentifier(mm.MappedName))); " is 133.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlParameterInfoProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlParameterInfoProducer.cs,VisitStoredProcedureCall,The length of the statement  "			SqlParameter p = new SqlParameter(typeof(int?)' this.parameterizer.TypeProvider.From(typeof(int))' "@RETURN_VALUE"' spc.SourceExpression); " is 138.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlParameterInfoProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlParameterInfoProducer.cs,VisitClientParameter,The length of the statement  "				SqlParameter p = new SqlParameter(cp.ClrType' cp.SqlType' this.parameterizer.CreateParameterName()' cp.SourceExpression); " is 121.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,InitializeParameter,The length of the statement  "						piPrecision.SetValue(parameter' Convert.ChangeType(sqlType.Precision' piPrecision.PropertyType' CultureInfo.InvariantCulture)' null); " is 133.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,InitializeParameter,The length of the statement  "						piScale.SetValue(parameter' Convert.ChangeType(sqlType.Scale' piScale.PropertyType' CultureInfo.InvariantCulture)' null); " is 121.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitSelect,The length of the statement  "						this.annotations.Add(select.Top' new CompatibilityAnnotation(Strings.SourceExpressionAnnotation(select.Top.SourceExpression)' SqlServerProviderMode.Sql2000)); " is 158.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitSelect,The length of the statement  "											 Strings.TextNTextAndImageCannotOccurInDistinct(select.SourceExpression)' SqlServerProviderMode.Sql2000' SqlServerProviderMode.SqlCE)); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitUnion,The length of the statement  "						Strings.TextNTextAndImageCannotOccurInUnion(su.SourceExpression)' SqlServerProviderMode.Sql2000' SqlServerProviderMode.SqlCE)); " is 127.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewString,The length of the statement  "					return sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { sox.Args[0]' sox.Args[1] }' sox.SourceExpression); " is 125.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source); " is 143.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120) " is 123.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second); " is 136.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source); " is 150.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source); " is 142.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source); " is 126.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The length of the statement  "							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source); " is 150.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source); " is 134.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source); " is 142.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second); " is 136.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source); " is 164.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source); " is 140.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms); " is 123.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source); " is 164.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The length of the statement  "                                                    sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute))) " is 124.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks " is 146.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression); " is 128.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression); " is 148.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression); " is 135.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression); " is 163.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression); " is 143.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression); " is 179.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression); " is 151.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The length of the statement  "							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression); " is 195.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object))); " is 140.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object))); " is 140.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source); " is 133.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse))); " is 127.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source); " is 137.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse))); " is 127.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s))); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1 " is 159.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source); " is 137.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse))); " is 127.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source)); " is 131.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s))); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The length of the statement  "							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source); " is 120.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The length of the statement  "								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX)); " is 128.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The length of the statement  "								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2); " is 130.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The length of the statement  "							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source); " is 168.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The length of the statement  "						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset."); " is 129.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeFromDateAndTicks,The length of the statement  "				SqlExpression daysAdded = sql.FunctionCallDateAdd("day"' sql.Divide(sqlTicks' TimeSpan.TicksPerDay)' sqlDate' source' asNullable); " is 130.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeFromDateAndTicks,The length of the statement  "				return sql.FunctionCallDateAdd("ms"' sql.Mod(sql.Divide(sqlTicks' TimeSpan.TicksPerMillisecond)' 86400000)' daysAdded' source' asNullable); " is 139.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndTicks,The length of the statement  "				SqlExpression daysAdded = sql.FunctionCallDateTimeOffsetAdd("day"' sql.Divide(sqlTicks' TimeSpan.TicksPerDay)' sqlDate' source' asNullable); " is 140.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndTicks,The length of the statement  "				return sql.FunctionCallDateTimeOffsetAdd("ms"' sql.Mod(sql.Divide(sqlTicks' TimeSpan.TicksPerMillisecond)' 86400000)' daysAdded' source' asNullable); " is 149.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndMs,The length of the statement  "				SqlExpression daysAdded = sql.FunctionCallDateTimeOffsetAdd("day"' sql.Divide(msBigint' 86400000)' sqlDate' source' asNullable); " is 128.
Long Statement,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateVbLikeString,The length of the statement  "							Expression.Call(typeof(SqlHelpers)' "TranslateVBLikePattern"' Type.EmptyTypes' cp.Accessor.Body' Expression.Constant('~'))' " is 123.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlTypeConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeConverter.cs,OldWillFitInNew,The length of the statement  "				|| !newSqlType.HasSizeOrIsLarge                 // if the type is not large' and doesn't have a size specified' assume OK " is 121.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlTypeConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeConverter.cs,VisitUnaryOperator,The length of the statement  "				return sql.FunctionCall(newClrType' sql.TypeProvider.From(typeof(int))' "UNICODE"' new SqlExpression[] { uo.Operand }' uo.SourceExpression); " is 140.
Long Statement,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsVbLike,The length of the statement  "				   (mc.Method.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.LikeOperator" && mc.Method.Name == "LikeString") " is 125.
Long Statement,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsVbLike,The length of the statement  "				   || (mc.Method.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.Operators" && mc.Method.Name == "LikeString"); " is 126.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Initialize,The length of the statement  "			_conManager = new ConnectionManager(this' con' maxUsersPerConnection' fileOrServerOrConnectionString != null /*disposeConnection*/); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,CreateDatabase,The length of the statement  "							engineType.InvokeMember("CreateDatabase"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.InvokeMethod' null' engine' new object[] { }' CultureInfo.InvariantCulture); " is 177.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,CompileSubQuery,The length of the statement  "			QueryInfo[] qis = this.BuildQuery(ResultShape.Sequence' TypeSystem.GetSequenceType(elementType)' query' parameters' annotations); " is 129.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,LogCommand,The length of the statement  "				writer.WriteLine("-- Context: {0}({1}) Model: {2} Build: {3}"' this.GetType().Name' this.Mode' _services.Model.GetType().Name' "1.0 (placeholder)"); " is 148.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Translate,The length of the statement  "			return (IEnumerable)Activator.CreateInstance(enumerableType' BindingFlags.Instance | BindingFlags.NonPublic' null' new object[] { e }' null); " is 141.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,CompileSubQuery,The length of the statement  "			return this.CompileSubQuery(query' elementType' parameters as ReadOnlyCollection<System.Data.Linq.Provider.NodeTypes.SqlParameter>); " is 132.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The length of the statement  "			bool canUseOuterApply = (this.Mode == SqlServerProviderMode.Sql2005 || this.Mode == SqlServerProviderMode.Sql2008 || this.Mode == SqlServerProviderMode.SqlCE); " is 159.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The length of the statement  "			SqlBinder binder = new SqlBinder(_translator' _sqlFactory' _services.Model' _services.Context.LoadOptions' columnizer' canUseOuterApply); " is 137.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The length of the statement  "				validator.AddValidator(new ExpectRationalizedBooleans()); /* From now on all boolean expressions should remain rationalized. */ " is 127.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetDefaultFactory,The length of the statement  "				SqlUserColumn col = new SqlUserColumn(rowType.Type' _typeProvider.From(rowType.Type)' suq' ""' false' suq.SourceExpression); " is 124.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetDefaultFactory,The length of the statement  "				SqlUserRow rowExp = new SqlUserRow(rowType.InheritanceRoot' _typeProvider.GetApplicationType((int)ConverterSpecialTypes.Row)' suq' tmp); " is 136.
Long Statement,System.Data.Linq.DbEngines.SqlServer,SqlTypeSystem,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeSystem.cs,Create,The length of the statement  "			else if(type == SqlDbType.Decimal && precision == ProviderConstants.DefaultDecimalPrecision && scale == ProviderConstants.DefaultDecimalScale) " is 142.
Long Statement,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,VisitSource,The length of the statement  "								List<List<SqlColumn>> liftedSelections = SqlSelectionLifter.Lift(leftOuter.Right' leftProducedAliases' liftedExpressions); " is 122.
Long Statement,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,AnnotateSqlIncompatibility,The length of the statement  "				this.annotations.Add(node' new CompatibilityAnnotation(Strings.SourceExpressionAnnotation(node.SourceExpression)' providers)); " is 126.
Long Statement,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,PushSourceDown,The length of the statement  "				SqlSelect ns = new SqlSelect(new SqlNop(cols[0].ClrType' cols[0].SqlType' sqlSource.SourceExpression)' sqlSource' sqlSource.SourceExpression); " is 142.
Long Statement,System.Data.Linq.Provider.Common,MultipleResults,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\MultipleResults.cs,GetResult,The length of the statement  "			return new SingleResult<T>(new OneTimeEnumerable<T>((IEnumerator<T>)objReader)' this.executeResult' _readerProvider.Services.Context); " is 134.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateMember,The length of the statement  "				return this.GenerateMethodCall(new SqlMethodCall(m.ClrType' m.SqlType' pi.GetGetMethod()' m.Expression' null' m.SourceExpression)); " is 131.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateAssignDeferredEntitySet,The length of the statement  "			MethodInfo miSetSource = memberType.GetMethod("SetSource"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[] { argType }' null); " is 165.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateAssignEntitySet,The length of the statement  "			MethodInfo miAssign = memberType.GetMethod("Assign"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[] { argType }' null); " is 159.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateAssignDeferredReference,The length of the statement  "			ConstructorInfo ci = memberType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[] { argType }' null); " is 153.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateGrouping,The length of the statement  "			MethodInfo miCreateGroup = TypeSystem.FindStaticMethod(orbType' "CreateGroup"' new Type[] { typeArgs[0]' typeof(IEnumerable<>).MakeGenericType(typeArgs[1]) }' typeArgs); " is 169.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateLink,The length of the statement  "				mi = typeof(ObjectMaterializer<>).MakeGenericType(this.compiler.DataReaderType).GetMethod("GetNestedLinkSource"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 183.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateLink,The length of the statement  "				mi = typeof(ObjectMaterializer<>).MakeGenericType(this.compiler.DataReaderType).GetMethod("GetLinkSource"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 177.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateClientQuery,The length of the statement  "			Type clientElementType = cq.Query.NodeType == SqlNodeType.Multiset ? TypeSystem.GetElementType(cq.ClrType) : cq.ClrType; " is 120.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateJoinedCollection,The length of the statement  "			MethodInfo miRead = orbType.GetMethod("Read"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' Type.EmptyTypes' null); " is 145.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateJoinedCollection,The length of the statement  "			MethodInfo miAdd = listType.GetMethod("Add"' BindingFlags.Instance | BindingFlags.Public' null' new Type[] { joinElementType }' null); " is 134.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The length of the statement  "					MethodInfo miCreateOrderedEnumerable = TypeSystem.FindStaticMethod(orbType' "CreateOrderedEnumerable"' new Type[] { seqType }' elemType); " is 137.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The length of the statement  "					MethodInfo miAssign = expectedType.GetMethod("Assign"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[] { seqType }' null); " is 161.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The length of the statement  "					MethodInfo miGetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle"' BindingFlags.Static | BindingFlags.Public); " is 120.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The length of the statement  "					MethodInfo miChangeType = typeof(DBConvert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public' null' new Type[] { typeof(object)' typeof(Type) }' null); " is 168.
Long Statement,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateGlobalAccess,The length of the statement  "				FieldInfo fi = varType.GetField("Value"' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 139.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderBase<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderBase.cs,ExecuteSubQuery,The length of the statement  "			IEnumerable results = (IEnumerable)subQuery.Execute(this.Session.Provider' parentArgs' this.Session.UserArguments).ReturnValue; " is 127.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderFactory<TDataReader;TObject>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactory.cs,Create,The length of the statement  "			ObjectReaderSession<TDataReader> session = new ObjectReaderSession<TDataReader>((TDataReader)dataReader' provider' parentArgs' userArgs' subQueries); " is 149.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderFactory<TDataReader;TObject>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactory.cs,GetNextResult,The length of the statement  "			IObjectReader reader = ors.GetNextResult(_materializeFunc' _namedColumns' _globals' _numberOfLocals' disposeDataReader); " is 120.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderFactoryCache,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactoryCache.cs,AddFactory,The length of the statement  "			this.list.AddFirst(new LinkedListNode<CacheInfo>(new CacheInfo(elementType' dataReaderType' mapping' options' projection' factory))); " is 133.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderSession<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderSession.cs,CreateReader,The length of the statement  "			ObjectReader<TDataReader' TObject> objectReader = new ObjectReader<TDataReader' TObject>(this' namedColumns' globals' _userArgs' nLocals' disposeDataReader' fnMaterialize); " is 172.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderSession<TDataReader>,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderSession.cs,GetNextResult,The length of the statement  "			ObjectReader<TDataReader' TObject> objectReader = new ObjectReader<TDataReader' TObject>(this' namedColumns' globals' _userArgs' nLocals' disposeDataReader' fnMaterialize); " is 172.
Long Statement,System.Data.Linq.Provider.Common,SqlComparer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlComparer.cs,AreEqual,The length of the statement  "					return col1 == col2 || (col1.Expression != null && col2.Expression != null && AreEqual(col1.Expression' col2.Expression)); " is 122.
Long Statement,System.Data.Linq.Provider.Common,Reducer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlCrossApplyToCrossJoin.cs,VisitJoin,The length of the statement  "						Annotations.Add(join' new CompatibilityAnnotation(Strings.SourceExpressionAnnotation(join.SourceExpression)' _providerModesWithIncompatibilities)); " is 147.
Long Statement,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,DiscriminatedType,The length of the statement  "			return new SqlDiscriminatedType(typeProvider.From(typeof(Type))' discriminator' targetType' discriminator.SourceExpression); " is 124.
Long Statement,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Table,The length of the statement  "			return new SqlTable(table' rowType' this.typeProvider.GetApplicationType((int)ConverterSpecialTypes.Row)' sourceExpression); " is 124.
Long Statement,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,UnaryConvert,The length of the statement  "			System.Diagnostics.Debug.Assert(!targetSqlType.IsRuntimeOnlyType' "Attempted coversion to a runtime type: from = " + expression.SqlType.ToQueryString() + "; to = " + targetSqlType.ToQueryString() + "; source = " + sourceExpression.ToString()); " is 243.
Long Statement,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,MakeJoin,The length of the statement  "			// if the new item is on the right side of some outer join then fixup the projection to reflect that it can possibly be null " is 124.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitInvocation,The length of the statement  "				return _nodeFactory.MethodCall(invoke.Type' typeof(Delegate).GetMethod("DynamicInvoke")' expr' new SqlExpression[] { sca }' _dominatingExpression); " is 147.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSelect,The length of the statement  "				return new SqlSelect(_nodeFactory.SubSelect(SqlNodeType.Multiset' pselect' selector.Body.Type)' alias' _dominatingExpression); " is 126.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitTypeBinary,The length of the statement  "					result = _nodeFactory.Unary(SqlNodeType.IsNotNull' new SqlUnary(SqlNodeType.Treat' ofType' _typeProvider.From(ofType)' expr' _dominatingExpression)' _dominatingExpression); " is 172.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,ConvertDateToDateTime2,The length of the statement  "			return _nodeFactory.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime2' expr }' expr.SourceExpression); " is 127.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,PropertyOrFieldOf,The length of the statement  "							foreach(PropertyInfo pi in mi.DeclaringType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) " is 128.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,GenerateSkipTake,The length of the statement  "				SqlColumn rowNumber = new SqlColumn("ROW_NUMBER"' _nodeFactory.RowNumber(new List<SqlOrderExpression>()' _dominatingExpression)); " is 129.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,TranslateTableValuedFunction,The length of the statement  "			SqlTableValuedFunctionCall functionCall = _nodeFactory.TableValuedFunctionCall(function.ResultRowTypes[0].InheritanceRoot' mce.Method.ReturnType' function.MappedName' sqlParams' mce); " is 183.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,TranslateTableValuedFunction,The length of the statement  "			SqlExpression projection = _translator.BuildProjection(aref' function.ResultRowTypes[0].InheritanceRoot' _allowDeferred' null' mce); " is 132.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,TranslateStoredProcedureCall,The length of the statement  "				SqlUserRow rowExp = new SqlUserRow(rowType' _typeProvider.GetApplicationType((int)ConverterSpecialTypes.Row)' spc' mce); " is 120.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitUserQuery,The length of the statement  "					SqlUserColumn col = new SqlUserColumn(elementType' _typeProvider.From(elementType)' suq' ""' false' _dominatingExpression); " is 123.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitUserQuery,The length of the statement  "					SqlUserRow rowExp = new SqlUserRow(mType.InheritanceRoot' _typeProvider.GetApplicationType((int)ConverterSpecialTypes.Row)' suq' _dominatingExpression); " is 152.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitGroupBy,The length of the statement  "				SqlExpression keyGroup = new SqlGrouping(elementType' _typeProvider.From(elementType)' keyExpr' ss' _dominatingExpression); " is 123.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitGroupBy,The length of the statement  "				_parameterExpressionToSqlExpression[resultSelector.Parameters[0]] = _nodeFactory.Member(kgAliasRef' elementType.GetProperty("Key")); " is 132.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitGroupBy,The length of the statement  "				SqlExpression resultExpr = new SqlGrouping(elementType' _typeProvider.From(elementType)' keyExpr' ss' _dominatingExpression); " is 125.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,The length of the statement  "			if(!_outerNode && !isCount && (lambda == null || (lambda.Parameters.Count == 1 && lambda.Parameters[0] == lambda.Body)) && " is 122.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,The length of the statement  "						_parameterExpressionToSqlExpression[lambda.Parameters[0]] = (SqlExpression)SqlDuplicator.Copy(info.ElementOnGroupSource); " is 121.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitContains,The length of the statement  "					List<SqlExpression> list = values.OfType<object>().Select(v => _nodeFactory.ValueFromObject(v' elemType' true' _dominatingExpression)).ToList(); " is 144.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,GenerateInExpression,The length of the statement  "					pred = _nodeFactory.Binary(SqlNodeType.Or' pred' _nodeFactory.Binary(SqlNodeType.EQ' (SqlExpression)SqlDuplicator.Copy(expr)' list[i])); " is 136.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The length of the statement  "							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4])); " is 155.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The length of the statement  "							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4])); " is 160.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The length of the statement  "							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])); " is 141.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitFirst,The length of the statement  "			SqlNodeType subType = (_typeProvider.From(select.Selection.ClrType).CanBeColumn) ? SqlNodeType.ScalarSubSelect : SqlNodeType.Element; " is 133.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,GetIdentityExpression,The length of the statement  "					return new SqlVariable(typeof(decimal)' _typeProvider.From(typeof(decimal))' "SCOPE_IDENTITY()"' _dominatingExpression); " is 120.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitUpdate,The length of the statement  "				seq = Expression.Call(typeof(Enumerable)' "Select"' new Type[] { rowType' resultSelector.Body.Type }' seq' resultSelector); " is 123.
Long Statement,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitUpdate,The length of the statement  "					_nodeFactory.Binary(SqlNodeType.GT' this.GetRowCountExpression()' _nodeFactory.ValueFromObject(0' false' _dominatingExpression))' " is 129.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjection,The length of the statement  "                return this.BuildProjectionInternal(item' rowType' (rowType.Table != null) ? rowType.PersistentDataMembers : rowType.DataMembers' allowDeferred' link' source); " is 159.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjection,The length of the statement  "                        SqlNew defaultProjection = this.BuildProjectionInternal(item' type' type.PersistentDataMembers' allowDeferred' link' source); " is 125.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjectionInternal,The length of the statement  "            ConstructorInfo cons = rowType.Type.GetConstructor(BindingFlags.Instance|BindingFlags.Public|BindingFlags.NonPublic' null' System.Type.EmptyTypes' null); " is 153.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildLink,The length of the statement  "                return new SqlLink(new object()' otherType' member.Type' typeProvider.From(member.Type)' item' member' exprs' null' source); " is 124.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildLink,The length of the statement  "                return new SqlLink(new object()' thisType' member.Type' typeProvider.From(member.Type)' item' member' exprs' expansion' source); " is 128.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,WhereClauseFromSourceAndKeys,The length of the statement  "            Expression sequenceExpression = Expression.Call(typeof(Enumerable)' "Where"' new Type[] {p.Type}' source' Expression.Lambda(whereExpression' p)); " is 145.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateEquals,The length of the statement  "                    return this.TranslateEqualsOp(expr.NodeType' sql.DoNotVisitExpression(expr.Left)' sql.DoNotVisitExpression(expr.Right)' false); " is 127.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateEquals,The length of the statement  "                return sql.Binary(SqlNodeType.EQ' sql.ValueFromObject(0'expr.SourceExpression)' sql.ValueFromObject(1'expr.SourceExpression)); " is 126.
Long Statement,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateEquals,The length of the statement  "            SqlNodeType eqKind = (expr.NodeType == SqlNodeType.EQ2V || expr.NodeType == SqlNodeType.NE2V) ? SqlNodeType.EQ2V : SqlNodeType.EQ; " is 130.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderCompiler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderCompiler.cs,Compile,The length of the statement  "				Type fnMatType = typeof(Func<'>).MakeGenericType(typeof(ObjectMaterializer<>).MakeGenericType(this.dataReaderType)' elementType); " is 129.
Long Statement,System.Data.Linq.Provider.Common,ObjectReaderCompiler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderCompiler.cs,CreateSession,The length of the statement  "			return (IObjectReaderSession)Activator.CreateInstance(sessionType' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' " is 142.
Long Statement,System.Data.Linq.Provider.Common,ConnectionManager,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ConnectionManager.cs,ReleaseConnection,The length of the statement  "            if (this.users.Count == 0 && this.autoClose && this.transaction == null && System.Transactions.Transaction.Current == null) { " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,ColumnLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ColumnLifter.cs,PushSourceDown,The length of the statement  "			SqlSelect ns = new SqlSelect(new SqlNop(cols[0].ClrType' cols[0].SqlType' sqlSource.SourceExpression)' sqlSource' sqlSource.SourceExpression); " is 142.
Long Statement,System.Data.Linq.Provider.Visitors,ExpressionDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ExpressionDuplicator.cs,VisitLink,The length of the statement  "			return new SqlLink(link.Id' link.RowType' link.ClrType' link.SqlType' link.Expression' link.Member' exprs' expansion' link.SourceExpression); " is 141.
Long Statement,System.Data.Linq.Provider.Visitors,ExpressionDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ExpressionDuplicator.cs,ExpandTogether,The length of the statement  "					return factory.New(cobs[0].MetaType' cobs[0].Constructor' arguments' cobs[0].ArgMembers' bindings' exprs[0].SourceExpression); " is 126.
Long Statement,System.Data.Linq.Provider.Visitors,ExpressionDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ExpressionDuplicator.cs,ExpandTogether,The length of the statement  "					return new SqlLink(links[0].Id' links[0].RowType' links[0].ClrType' links[0].SqlType' links[0].Expression' links[0].Member' kexprs' expansion' links[0].SourceExpression); " is 170.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The length of the statement  "								return VisitUnaryOperator(new SqlUnary(negator' bo.ClrType' bo.SqlType' sql.DoNotVisitExpression(bo.Right)' bo.SourceExpression)); " is 130.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The length of the statement  "							if (bo.Right.ClrType==typeof(bool)) { // If the other side is nullable bool then this expression is already a reasonable way to handle three-values " is 147.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The length of the statement  "								return VisitUnaryOperator(new SqlUnary(negator' bo.ClrType' bo.SqlType' sql.DoNotVisitExpression(bo.Left)' bo.SourceExpression)); " is 129.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The length of the statement  "							if (bo.Left.ClrType==typeof(bool)) { // If the other side is nullable bool then this expression is already a reasonable way to handle three-values " is 146.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitDiscriminatorOf,The length of the statement  "						SqlExpression @default = sql.Value(discriminator.GetType()' tc.Whens[0].Match.SqlType' defaultType.InheritanceCode' true' tc.SourceExpression); " is 143.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitDiscriminatorOf,The length of the statement  "						values.Add(sql.Value(discriminator.GetType()' when.Match.SqlType' ((SqlValue)when.Match).Value' true' tc.SourceExpression)); " is 124.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitUnaryOperator,The length of the statement  "							new SqlUnary(SqlNodeType.OuterJoinedValue' tc.Discriminator.ClrType' tc.Discriminator.SqlType' tc.Discriminator' tc.SourceExpression)' " is 134.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitUnaryOperator,The length of the statement  "				return sql.Value(uo.ClrType' uo.SqlType' DBConvert.ChangeType(val.Value' uo.ClrType)' val.IsClientSpecified' val.SourceExpression); " is 131.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitUnaryOperator,The length of the statement  "						return sql.Value(typeof(bool)' this.typeProvider.From(typeof(int))' (val.Value == null) == (uo.NodeType == SqlNodeType.IsNull)' val.IsClientSpecified' uo.SourceExpression); " is 172.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,AccessMember,The length of the statement  "									this.currentSelect.From = sql.MakeJoin(SqlJoinType.OuterApply' this.currentSelect.From' alias' null' sub.SourceExpression); " is 123.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,AccessMember,The length of the statement  "							SqlNodeType subType = (rexp is SqlTypeCase || !rexp.SqlType.CanBeColumn) ? SqlNodeType.Element : SqlNodeType.ScalarSubSelect; " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,SimulateCaseOfSequences,The length of the statement  "					elseFilter = sql.AndAccumulate(elseFilter' sql.Binary(SqlNodeType.NE' clientCase.Expression' clientCase.Whens[i].Match)); " is 121.
Long Statement,System.Data.Linq.Provider.Visitors,MultiSetMultiPlexer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MultiSetMultiPlexer.cs,VisitMultiset,The length of the statement  "				SqlSelect countSelect = new SqlSelect(sql.Unary(SqlNodeType.Count' null' sms.SourceExpression)' copyAlias' sms.SourceExpression); " is 129.
Long Statement,System.Data.Linq.Provider.Visitors,OrderByLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\OrderByLifter.cs,VisitAlias,The length of the statement  "						col = new SqlColumn(mm.MemberAccessor.Type' typeProvider.From(mm.MemberAccessor.Type)' name' mm' null' sourceExpression); " is 121.
Long Statement,System.Data.Linq.Provider.Visitors,OrderByLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\OrderByLifter.cs,PushDown,The length of the statement  "			SqlSelect select = new SqlSelect(new SqlNop(column.ClrType' column.SqlType' column.SourceExpression)' this.currentSelect.From' this.currentSelect.SourceExpression); " is 164.
Long Statement,System.Data.Linq.Provider.Visitors,Booleanizer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\Booleanizer.cs,ConvertPredicateToValue,The length of the statement  "				SqlExpression valueNull = sql.Value(valueTrue.ClrType' valueTrue.SqlType' null' false' predicateExpression.SourceExpression); " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,Booleanizer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\Booleanizer.cs,ConvertPredicateToValue,The length of the statement  "									  new SqlWhen(new SqlUnary(SqlNodeType.Not' predicateExpression.ClrType' predicateExpression.SqlType' predicateExpression' predicateExpression.SourceExpression)' valueFalse) " is 171.
Long Statement,System.Data.Linq.Provider.Visitors,CaseSimplifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\CaseSimplifier.cs,TryToWriteAsSimpleBooleanExpression,The length of the statement  "						rewrite = _sql.AndAccumulate(rewrite' _sql.Unary(SqlNodeType.IsNotNull' discriminator' discriminator.SourceExpression)); " is 120.
Long Statement,System.Data.Linq.Provider.Visitors,ScalarSubQueryRewriter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ScalarSubQueryRewriter.cs,VisitScalarSubSelect,The length of the statement  "			this.currentSelect.From = new SqlJoin(SqlJoinType.OuterApply' this.currentSelect.From' alias' null' ss.SourceExpression); " is 121.
Long Statement,System.Data.Linq.Provider.Visitors,SelectionFlattener,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SelectionFlattener.cs,VisitColumn,The length of the statement  "			if(c == null && col.Expression != null && !this.isInput && (!this.isNew || (this.isNew && !col.Expression.IsConstantColumn))) " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,SqlBubbler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlBubbler.cs,ForceLocal,The length of the statement  "				SqlColumn c = new SqlColumn(found.ClrType' found.SqlType' name' this.found.MetaMember' new SqlColumnRef(this.found)' row.SourceExpression); " is 139.
Long Statement,System.Data.Linq.Provider.Visitors,SqlColumnDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlColumnDeflator.cs,VisitSelect,The length of the statement  "							// don't remove anything from a distinct select (except maybe a literal value) since it would change the meaning of the comparison " is 130.
Long Statement,System.Data.Linq.Provider.Visitors,SqlColumnDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlColumnDeflator.cs,VisitSelect,The length of the statement  "							// don't remove an aggregate expression that may be the only expression that forces the grouping (since it would change the cardinality of the results) " is 151.
Long Statement,System.Data.Linq.Provider.Visitors,SqlScopedVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlScopedVisitor.cs,VisitJoin,The length of the statement  "					this.CurrentScope = new SqlScope(null' new SqlScope(join.Right' new SqlScope(join.Left' this.CurrentScope.ContainingScope))); " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitJoinedCollection,The length of the statement  "			return new SqlJoinedCollection(jc.ClrType' jc.SqlType' this.VisitExpression(jc.Expression)' this.VisitExpression(jc.Count)' jc.SourceExpression); " is 145.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitLink,The length of the statement  "			SqlLink newLink = new SqlLink(new object()' link.RowType' link.ClrType' link.SqlType' null' link.Member' exprs' null' link.SourceExpression); " is 141.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitUserQuery,The length of the statement  "				SqlUserColumn dupSuc = new SqlUserColumn(suc.ClrType' suc.SqlType' suc.Query' suc.Name' suc.IsRequired' suc.SourceExpression); " is 126.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitUnaryOperator,The length of the statement  "			return new SqlUnary(uo.NodeType' uo.ClrType' uo.SqlType' (SqlExpression)this.Visit(uo.Operand)' uo.Method' uo.SourceExpression); " is 128.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitIn,The length of the statement  "			SqlIn nin = new SqlIn(sin.ClrType' sin.SqlType' this.VisitExpression(sin.Expression)' sin.Values' sin.SourceExpression); " is 120.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitTableValuedFunctionCall,The length of the statement  "			SqlTableValuedFunctionCall nfc = new SqlTableValuedFunctionCall(fc.RowType' fc.ClrType' fc.SqlType' fc.Name' args' fc.SourceExpression); " is 136.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitMethodCall,The length of the statement  "			return new SqlMethodCall(mc.ClrType' mc.SqlType' mc.Method' this.VisitExpression(mc.Object)' args' mc.SourceExpression); " is 120.
Long Statement,System.Data.Linq.Provider.Visitors,DuplicatingVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\DuplicatingVisitor.cs,VisitDiscriminatedType,The length of the statement  "			return new SqlDiscriminatedType(dt.SqlType' this.VisitExpression(dt.Discriminator)' dt.TargetType' dt.SourceExpression); " is 120.
Long Statement,System.Data.Linq.Provider.Visitors,Localizer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\Localizer.cs,MakeLocal,The length of the statement  "					return (e.NodeType == ExpressionType.Convert) ? Expression.Convert(local' e.Type) : Expression.ConvertChecked(local' e.Type); " is 125.
Long Statement,System.Data.Linq.Provider.Visitors,SubQueryCompiler,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SubQueryCompiler.cs,VisitClientQuery,The length of the statement  "			Type clientElementType = cq.Query.NodeType == SqlNodeType.Multiset ? TypeSystem.GetElementType(cq.ClrType) : cq.ClrType; " is 120.
Long Statement,System.Data.Linq.Provider.Visitors,SubSelectDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SubSelectDuplicator.cs,VisitLink,The length of the statement  "			return new SqlLink(new object()' link.RowType' link.ClrType' link.SqlType' null' link.Member' exprs' null' link.SourceExpression); " is 130.
Long Statement,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CanDbConvert,The length of the statement  "				case TypeCode.Int32: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16; " is 137.
Long Statement,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CanDbConvert,The length of the statement  "				case TypeCode.Int64: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16 || tcFrom == TypeCode.Int32 || tcFrom == TypeCode.UInt32; " is 194.
Long Statement,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CanDbConvert,The length of the statement  "				case TypeCode.UInt32: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16; " is 138.
Long Statement,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CanDbConvert,The length of the statement  "				case TypeCode.UInt64: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16 || tcFrom == TypeCode.Int32 || tcFrom == TypeCode.UInt32; " is 195.
Long Statement,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitBinaryOperator,The length of the statement  "						SqlValue emptyStr = new SqlValue(strValue.ClrType' strValue.SqlType' String.Empty' strValue.IsClientSpecified' strValue.SourceExpression); " is 138.
Long Statement,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitMethodCall,The length of the statement  "							SqlDiscriminatorOf discriminatorOf = new SqlDiscriminatorOf(mc.Object' discriminatorType' this.sql.TypeProvider.From(discriminatorType)' mc.SourceExpression); " is 158.
Long Statement,System.Data.Linq.Provider.Visitors,PreBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MethodCallConverter.cs,IsCompareToMethod,The length of the statement  "			return !call.Method.IsStatic && call.Method.Name == "CompareTo" && call.Arguments.Count == 1 && call.Method.ReturnType == typeof(int); " is 134.
Long Statement,System.Data.Linq.Provider.Visitors,PreBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MethodCallConverter.cs,IsCompareMethod,The length of the statement  "			return call.Method.IsStatic && call.Method.Name == "Compare" && call.Arguments.Count > 1 && call.Method.ReturnType == typeof(int); " is 130.
Long Statement,System.Data.Linq.Mapping,PropertyAccessor,C:\repos\FransBouma_LinqToSQL2\src\Mapping\Accesssors\PropertyAccessor.cs,Create,The length of the statement  "					dset = Delegate.CreateDelegate(typeof(DSet<'>).MakeGenericType(objectType' pi.PropertyType)' pi.GetSetMethod(true)' true); " is 122.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,InitAccessors,The length of the statement  "								MakeDeferredAccessors(this.member.ReflectedType' this.accPrivate' out this.accPrivate' out this.accDefValue' out this.accDefSource); " is 132.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,InitAccessors,The length of the statement  "								MakeDeferredAccessors(this.member.ReflectedType' this.accPrivate' out this.accPrivate' out this.accDefValue' out this.accDefSource); " is 132.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(LinkDefValueAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 129.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(LinkDefSourceAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 131.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorValue = CreateAccessor(typeof(EntityRefValueAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 123.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(EntityRefDefValueAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 134.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(EntityRefDefSourceAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 136.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorValue = CreateAccessor(typeof(EntitySetValueAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 123.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(EntitySetDefValueAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 134.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(EntitySetDefSourceAccessor<'>).MakeGenericType(objectDeclaringType' itemType)' accessor); " is 136.
Long Statement,System.Data.Linq.Mapping,AttributedMetaDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaDataMember.cs,CreateAccessor,The length of the statement  "			return (MetaAccessor)Activator.CreateInstance(accessorType' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' args' null); " is 148.
Long Statement,System.Data.Linq.Mapping,AttributedMetaType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaType.cs,InitMethods,The length of the statement  "				this.hasAnyLoadMethod = (this.onLoadedMethod != null) || (this.InheritanceBase != null && this.InheritanceBase.HasAnyLoadMethod); " is 129.
Long Statement,System.Data.Linq.Mapping,AttributedMetaType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaType.cs,InitMethods,The length of the statement  "				this.hasAnyValidateMethod = (this.onValidateMethod != null) || (this.InheritanceBase != null && this.InheritanceBase.HasAnyValidateMethod); " is 139.
Long Statement,System.Data.Linq.Mapping,AttributedMetaType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaType.cs,InitDataMembers,The length of the statement  "				BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 122.
Long Statement,System.Data.Linq.Mapping,AttributedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaModel.cs,InitStaticTables,The length of the statement  "                            FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 134.
Long Statement,System.Data.Linq.Mapping,AttributedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaModel.cs,InitStaticTables,The length of the statement  "                            PropertyInfo[] props = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 140.
Long Statement,System.Data.Linq.Mapping,AttributedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaModel.cs,InitFunctions,The length of the statement  "                                foreach (MethodInfo mi in type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) { " is 142.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,InitAccessors,The length of the statement  "								MakeDeferredAccessors(this.member.ReflectedType' this.accPrivate' out this.accPrivate' out this.accDefValue' out this.accDefSource); " is 132.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,InitAccessors,The length of the statement  "								MakeDeferredAccessors(this.member.ReflectedType' this.accPrivate' out this.accPrivate' out this.accDefValue' out this.accDefSource); " is 132.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(LinkDefValueAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 123.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(LinkDefSourceAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 125.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(EntityRefDefValueAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 128.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(EntityRefDefSourceAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 130.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredValue = CreateAccessor(typeof(EntitySetDefValueAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 128.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,MakeDeferredAccessors,The length of the statement  "					accessorDeferredSource = CreateAccessor(typeof(EntitySetDefSourceAccessor<'>).MakeGenericType(declaringType' itemType)' accessor); " is 130.
Long Statement,System.Data.Linq.Mapping,MappedDataMember,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedDataMember.cs,CreateAccessor,The length of the statement  "			return (MetaAccessor)Activator.CreateInstance(accessorType' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' args' null); " is 148.
Long Statement,System.Data.Linq.Mapping,MappedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedMetaModel.cs,InitStaticTableTypes,The length of the statement  "                FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 134.
Long Statement,System.Data.Linq.Mapping,MappedMetaModel,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedMetaModel.cs,InitStaticTableTypes,The length of the statement  "                PropertyInfo[] props = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 140.
Long Statement,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,InitMethods,The length of the statement  "				this.hasAnyLoadMethod = (this.onLoadedMethod != null) || (this.InheritanceBase != null && this.InheritanceBase.HasAnyLoadMethod); " is 129.
Long Statement,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,InitMethods,The length of the statement  "				this.hasAnyValidateMethod = (this.onValidateMethod != null) || (this.InheritanceBase != null && this.InheritanceBase.HasAnyValidateMethod); " is 139.
Long Statement,System.Data.Linq.Mapping,MappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedType.cs,InitDataMembers,The length of the statement  "				BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 122.
Long Statement,System.Data.Linq.Mapping,MetaAssociationImpl,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MetaAssociationImpl.cs,MakeKeys,The length of the statement  "				MemberInfo[] rmis = mtype.Type.GetMember(names[i]' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,System.Data.Linq.Mapping,MetaAssociationImpl,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MetaAssociationImpl.cs,ToString,The length of the statement  "			return string.Format(Globalization.CultureInfo.InvariantCulture' "{0} ->{1} {2}"' ThisMember.DeclaringType.Name' IsMany ? "*" : ""' OtherType.Name); " is 148.
Long Statement,System.Data.Linq.Mapping,UnmappedType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\UnmappedType.cs,InitDataMembers,The length of the statement  "						BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 122.
Long Statement,System.Data.Linq.Mapping,MappingSource,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\MappingSource.cs,GetModel,The length of the statement  "                Interlocked.CompareExchange<Dictionary<Type' MetaModel>>(ref this.secondaryModels' new Dictionary<Type' MetaModel>()' null); " is 124.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadDatabaseMapping,The length of the statement  "							throw Error.UnrecognizedElement(String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 192.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadDatabaseMapping,The length of the statement  "					throw Error.UnexpectedElement(XmlMappingConstant.Database' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 219.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ValidateAttributes,The length of the statement  "						throw Error.UnrecognizedAttribute(String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : ":"' reader.LocalName)); " is 194.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadFunctionMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Function' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 219.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadFunctionMapping,The length of the statement  "							throw Error.UnrecognizedElement(String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 192.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadReturnMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Return' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 217.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadParameterMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Parameter' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 220.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadTableMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Table' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 216.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadTableMapping,The length of the statement  "							throw Error.UnrecognizedElement(String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 192.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadTableMapping,The length of the statement  "					throw Error.UnexpectedElement(XmlMappingConstant.Table' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 216.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadElementTypeMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Type' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 215.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadTypeMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Type' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 215.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadTypeMappingImpl,The length of the statement  "							throw Error.UnrecognizedElement(String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 192.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadAssociationMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Association' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 222.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadColumnMapping,The length of the statement  "				throw Error.UnexpectedElement(XmlMappingConstant.Column' String.Format(System.Globalization.CultureInfo.InvariantCulture' "{0}{1}{2}"' reader.Prefix' String.IsNullOrEmpty(reader.Prefix) ? "" : "/"' reader.LocalName)); " is 217.
Long Statement,System.Data.Linq.Mapping,XmlMappingReader,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappingSource\XmlMappingReader.cs,ReadColumnMapping,The length of the statement  "			cm.UpdateCheck = (updateCheck == null) ? UpdateCheck.Always : (UpdateCheck)Enum.Parse(typeof(UpdateCheck)' updateCheck); " is 120.
Complex Conditional,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,CanInferDelete,The conditional expression  "assoc.DeleteOnNull && assoc.IsForeignKey && !assoc.IsNullable && !assoc.IsMany &&  							assoc.ThisMember.StorageAccessor.HasAssignedValue(Current) &&  							assoc.ThisMember.StorageAccessor.GetBoxedValue(Current) == null"  is complex.
Complex Conditional,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,BuildEdgeMaps,The conditional expression  "isNew || pointsToDeleted || pointsToNew || this.HasAssociationChanged(assoc' item)"  is complex.
Complex Conditional,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetKeyFromPredicate,The conditional expression  "memex == null || memex.Expression == null ||  				memex.Expression.NodeType != ExpressionType.Parameter || memex.Expression.Type != type.Type"  is complex.
Complex Conditional,System.Data.Linq,StandardChangeDirector,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeDirector.cs,GetAutoSyncMembers,The conditional expression  "(updateType == UpdateType.Insert && metaMember.AutoSync == AutoSync.OnInsert) ||  					(updateType == UpdateType.Update && metaMember.AutoSync == AutoSync.OnUpdate) ||  					 metaMember.AutoSync == AutoSync.Always"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitJoin,The conditional expression  "rightJoin == null ||  			   (rightJoin.JoinType == SqlJoinType.Cross  				&& @join.JoinType != SqlJoinType.CrossApply  				&& @join.JoinType != SqlJoinType.OuterApply)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlHelpers,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlHelpers.cs,EscapeLikeText,The conditional expression  "!(forceEscaping || text.Contains("%") || text.Contains("_") || text.Contains("[") || text.Contains("^"))"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlHelpers,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlHelpers.cs,EscapeLikeText,The conditional expression  "c == '%' || c == '_' || c == '[' || c == '^' || c == escape"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,PredictTypeForBinary,The conditional expression  "(!leftType.IsLargeType && leftType.Size.HasValue) &&  						   (!rightType.IsLargeType && rightType.Size.HasValue)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The conditional expression  "p0 == 0 && s0 == 0 && p1 == 0 && s1 == 0"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The conditional expression  "sqlTypeB.Size.HasValue && sqlTypeB.Size.Value == ProviderConstants.LargeTypeSizeIndicator  				   || sqlTypeA.Size.HasValue && sqlTypeA.Size.Value == ProviderConstants.LargeTypeSizeIndicator"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewString,The conditional expression  "sox.ClrType == typeof(string) && sox.Args.Count == 2  					&& sox.Args[0].ClrType == typeof(char) && sox.Args[1].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The conditional expression  "sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The conditional expression  "sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The conditional expression  "sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The conditional expression  "(mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks")"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The conditional expression  "(mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks")"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,SqlTypeConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeConverter.cs,VisitUnaryOperator,The conditional expression  "oldClrType == typeof(char) && (oldSqlType.IsChar || oldSqlType.IsString) && newSqlType.IsNumeric"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The conditional expression  "sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The conditional expression  "sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int)"  is complex.
Complex Conditional,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetCoercionMethodSupport,The conditional expression  "mc.Method.IsStatic  				&& mc.SqlType.CanBeColumn  				&& (mc.Method.Name == "op_Implicit" || mc.Method.Name == "op_Explicit")"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,GetLeftOuterWithUnreferencedSingletonOnLeft,The conditional expression  "select != null &&  						select.Where == null &&  						select.Top == null &&  						select.GroupBy.Count == 0 &&  						select.OrderBy.Count == 0"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The conditional expression  "(actualType.IsSubclassOf(expectedType) || expectedType.IsSubclassOf(actualType))  						&& !actualType.IsValueType && !expectedType.IsValueType"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The conditional expression  "elementType.IsInterface ||  					   genExpectedTypeArgs[0].IsInterface ||  					   elementType.IsSubclassOf(genExpectedTypeArgs[0]) ||  					   genExpectedTypeArgs[0].IsSubclassOf(elementType) ||  					   TypeSystem.GetNonNullableType(elementType) == TypeSystem.GetNonNullableType(genExpectedTypeArgs[0])"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The conditional expression  "expectedType.IsArray && expectedType.GetArrayRank() == 1 &&  						!actualType.IsArray && seqType.IsAssignableFrom(actualType) &&  						expectedType.GetElementType().IsAssignableFrom(elemType)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConvertToType,The conditional expression  "expectedType.IsClass &&  						typeof(ICollection<>).MakeGenericType(elemType).IsAssignableFrom(expectedType) &&  						expectedType.GetConstructor(System.Type.EmptyTypes) != null &&  						seqType.IsAssignableFrom(actualType)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,ObjectReaderFactoryCache,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ObjectReaderFactoryCache.cs,GetFactory,The conditional expression  "elementType == info.Value.elementType &&  				   dataReaderType == info.Value.dataReaderType &&  				   mapping == info.Value.mapping &&  				   DataLoadOptions.ShapesAreEquivalent(options' info.Value.options) &&  				   SqlProjectionComparer.AreSimilar(projection' info.Value.projection)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,LockSelect,The conditional expression  "sel.Selection.NodeType != SqlNodeType.AliasRef ||  				sel.Where != null ||  				sel.OrderBy.Count > 0 ||  				sel.GroupBy.Count > 0 ||  				sel.Having != null ||  				sel.Top != null ||  				sel.OrderingType != SqlOrderingType.Default ||  				sel.IsDistinct"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,ChooseConversionMethod,The conditional expression  "nnFromType == nnToType                                  // same non-nullable .NET types  				|| (sfromType.IsString && sfromType.Equals(stoType))    // same SQL string types  				|| (nnFromType.IsEnum || nnToType.IsEnum)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitTake,The conditional expression  "mce != null && IsSequenceOperatorCall(mce) && mce.Method.Name == "Skip" && mce.Arguments.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,The conditional expression  "!_outerNode && !isCount && (lambda == null || (lambda.Parameters.Count == 1 && lambda.Parameters[0] == lambda.Body)) &&  				(mce != null) && IsSequenceOperatorCall(mce' "Select") && select.From is SqlAlias"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitAggregate,The conditional expression  "select.Selection.SqlType.IsRuntimeOnlyType && !IsGrouping(sequence.Type) && !isCount && lambda == null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitMethodCall,The conditional expression  "mc.Method.DeclaringType != typeof(string)  				&& mc.Method.Name == "Contains"  				&& !mc.Method.IsStatic  				&& typeof(IList).IsAssignableFrom(mc.Method.DeclaringType)  				&& mc.Type == typeof(bool)  				&& mc.Arguments.Count == 1  				&& TypeSystem.GetElementType(mc.Method.DeclaringType).IsAssignableFrom(mc.Arguments[0].Type)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The conditional expression  "mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,BuildProjectionInternal,The conditional expression  "link != null && mm != link.Member && mm.IsAssociation                          && mm.MappedName == link.Member.MappedName                          && !mm.Association.IsMany                          && !IsPreloaded(link.Member.Member)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateEquals,The conditional expression  "!mtLeft.IsEntity && !mtRight.IsEntity &&                   (eLeft.NodeType != SqlNodeType.New || eLeft.SqlType.CanBeColumn) &&                   (eRight.NodeType != SqlNodeType.New || eRight.SqlType.CanBeColumn)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,Translator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\Translator.cs,TranslateLinkEquals,The conditional expression  "(link1 != null && link1.Member.IsAssociation && link1.Member.Association.IsForeignKey) ||                  (link2 != null && link2.Member.IsAssociation && link2.Member.Association.IsForeignKey)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Common,ConnectionManager,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\ConnectionManager.cs,ReleaseConnection,The conditional expression  "this.users.Count == 0 && this.autoClose && this.transaction == null && System.Transactions.Transaction.Current == null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitSearchedCase,The conditional expression  "(c.ClrType == typeof(bool) || c.ClrType == typeof(bool?)) &&  				c.Whens.Count == 1 && c.Else != null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitNew,The conditional expression  "mm.IsAssociation && ma.Expression != null && ma.Expression.NodeType != SqlNodeType.Link  					&& this.shape != null && this.shape.IsPreloaded(mm.Member) && mm.LoadMethod == null  					&& this.alreadyIncluded != null && !this.alreadyIncluded.Contains(otherType)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitSelect,The conditional expression  "this.binder.OptimizeLinkExpansions &&  					(@select.GroupBy.Count > 0 || this.aggregateChecker.HasAggregates(@select) || @select.IsDistinct)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,ConvertToFetchedExpression,The conditional expression  "this.currentSelect != null   						&& node != null   						&& node.NodeType == SqlNodeType.Element   						&& link.Member.IsAssociation  						&& this.binder.OptimizeLinkExpansions"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,MultiSetMultiPlexer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MultiSetMultiPlexer.cs,VisitMultiset,The conditional expression  "(this.options & SqlMultiplexerOptionType.EnableBigJoin) != 0 &&  			   !this.hasBigJoin && this.canJoin && this.isTopLevel && this.outerSelect != null  			   && !MultisetChecker.HasMultiset(sms.Select.Selection)  			   && BigJoinChecker.CanBigJoin(sms.Select)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,OrderByLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\OrderByLifter.cs,VisitSelect,The conditional expression  "(this.topSelect || select.Top != null) && select.OrderingType != SqlOrderingType.Never && this.orders != null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,PredicateLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\PredicateLifter.cs,VisitSelect,The conditional expression  "@select.Top != null ||  			   @select.GroupBy.Count > 0 ||  			   this.aggregateChecker.HasAggregates(@select) ||  			   @select.IsDistinct"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,CaseSimplifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\CaseSimplifier.cs,DistributeOperatorIntoCase,The conditional expression  "nt != SqlNodeType.EQ && nt != SqlNodeType.NE && nt != SqlNodeType.EQ2V && nt != SqlNodeType.NE2V"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,LiteralValidator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\LiteralValidator.cs,VisitValue,The conditional expression  "!value.IsClientSpecified  				&& value.ClrType.IsClass  				&& value.ClrType != typeof(string)  				&& value.ClrType != typeof(Type)  				&& value.Value != null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,SelectionFlattener,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SelectionFlattener.cs,VisitColumn,The conditional expression  "c == null && col.Expression != null && !this.isInput && (!this.isNew || (this.isNew && !col.Expression.IsConstantColumn))"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,SelectionLifter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SelectionLifter.cs,VisitSelect,The conditional expression  "@select.Top != null ||  			   @select.GroupBy.Count > 0 ||  			   this.aggregateChecker.HasAggregates(@select) ||  			   @select.IsDistinct"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,SqlAliasDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlAliasDeflator.cs,IsTrivialSelect,The conditional expression  "@select.OrderBy.Count != 0 ||  			   @select.GroupBy.Count != 0 ||  			   @select.Having != null ||  			   @select.Top != null ||  			   @select.IsDistinct ||  			   @select.Where != null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,LocalMapper,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\LocalMapper.cs,Visit,The conditional expression  "!this.isRemote  						&& expression.NodeType != ExpressionType.Lambda  						&& expression.NodeType != ExpressionType.Quote  						&& DependenceChecker.IsIndependent(expression)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,SqlTopSelectDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlTopSelectDeflator.cs,IsTrivialSelect,The conditional expression  "@select.OrderBy.Count != 0 ||  			   @select.GroupBy.Count != 0 ||  			   @select.Having != null ||  			   @select.Top != null ||  			   @select.IsDistinct ||  			   @select.Where != null"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,VisitLike,The conditional expression  "!like.Expression.SqlType.IsUnicodeType && like.Pattern.SqlType.IsUnicodeType &&  			   (like.Pattern.NodeType == SqlNodeType.Value || like.Pattern.NodeType == SqlNodeType.ClientParameter)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CoerceTypeFamily,The conditional expression  "(arg1.SqlType.HasPrecisionAndScale && arg2.SqlType.HasPrecisionAndScale && arg1.SqlType != arg2.SqlType) ||  			   sql.IsHighPrecisionDateTimeType(arg1) || sql.IsHighPrecisionDateTimeType(arg2)"  is complex.
Complex Conditional,System.Data.Linq.Provider.Visitors,ValidateNoInvalidComparison,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ValidateNoInvalidComparison.cs,VisitBinaryOperator,The conditional expression  "bo.NodeType == SqlNodeType.EQ || bo.NodeType == SqlNodeType.NE ||  			   bo.NodeType == SqlNodeType.EQ2V || bo.NodeType == SqlNodeType.NE2V ||  			   bo.NodeType == SqlNodeType.GT || bo.NodeType == SqlNodeType.GE ||  			   bo.NodeType == SqlNodeType.LT || bo.NodeType == SqlNodeType.LE"  is complex.
Complex Conditional,System.Data.Linq.Mapping,AttributedMetaFunction,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaFunction.cs,AttributedMetaFunction,The conditional expression  "attrs.Length <= 1 && mi.ReturnType.IsGenericType &&  					 (mi.ReturnType.GetGenericTypeDefinition() == typeof(IEnumerable<>) ||  					  mi.ReturnType.GetGenericTypeDefinition() == typeof(ISingleResult<>) ||  					  mi.ReturnType.GetGenericTypeDefinition() == typeof(IQueryable<>))"  is complex.
Complex Conditional,System.Data.Linq.Mapping,AttributedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedRootType.cs,AttributedRootType,The conditional expression  "(codeValue.GetType() == typeof(string) && ((string)codeValue).Trim().Length == 0 &&  							d.GetType() == typeof(string) && ((string)d).Trim().Length == 0) ||  							object.Equals(d' codeValue)"  is complex.
Complex Conditional,System.Data.Linq.Mapping,MappedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedRootType.cs,MappedRootType,The conditional expression  "this.inheritanceDefault == null && (this.InheritanceCode != null || this.inheritanceCodes != null && this.inheritanceCodes.Count > 0)"  is complex.
Complex Conditional,System.Data.Linq.Mapping,MappedRootType,C:\repos\FransBouma_LinqToSQL2\src\Mapping\MappedMetaModel\MappedRootType.cs,InitInheritedType,The conditional expression  "(keyValue.GetType() == typeof(string) && ((string)keyValue).Trim().Length == 0 &&  						d.GetType() == typeof(string) && ((string)d).Trim().Length == 0) ||  						object.Equals(d' keyValue)"  is complex.
Complex Conditional,LinqToSqlShared.Mapping,MappingSystem,C:\repos\FransBouma_LinqToSQL2\src\Mapping\DbmlShared\MappingSystem.cs,IsSupportedIdentityType,The conditional expression  "type == typeof(Guid) || type == typeof(DateTime) || type == typeof(DateTimeOffset) ||                  type == typeof(TimeSpan) || type == typeof(Binary)"  is complex.
Virtual Method Call from Constructor,System.Data.Linq,StandardTrackedObject,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\StandardChangeTracker.cs,StandardTrackedObject,The constructor "StandardTrackedObject" calls a virtual method "GetInheritanceType".
Virtual Method Call from Constructor,System.Data.Linq,MemberChangeConflict,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\MemberChangeConflict.cs,MemberChangeConflict,The constructor "MemberChangeConflict" calls a virtual method "GetBoxedValue".
Virtual Method Call from Constructor,System.Data.Linq,MemberChangeConflict,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\MemberChangeConflict.cs,MemberChangeConflict,The constructor "MemberChangeConflict" calls a virtual method "GetBoxedValue".
Virtual Method Call from Constructor,System.Data.Linq,MemberChangeConflict,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\MemberChangeConflict.cs,MemberChangeConflict,The constructor "MemberChangeConflict" calls a virtual method "GetBoxedValue".
Virtual Method Call from Constructor,System.Data.Linq,ObjectChangeConflict,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ObjectChangeConflict.cs,ObjectChangeConflict,The constructor "ObjectChangeConflict" calls a virtual method "CreateDataCopy".
Virtual Method Call from Constructor,System.Data.Linq.Mapping,AttributedMetaAssociation,C:\repos\FransBouma_LinqToSQL2\src\Mapping\AttributedMetaModel\AttributedMetaAssociation.cs,AttributedMetaAssociation,The constructor "AttributedMetaAssociation" calls a virtual method "GetMetaType".
Empty Catch Block,System.Data.Linq,SecurityUtils,C:\repos\FransBouma_LinqToSQL2\src\Miscellaneous\SecurityUtils.cs,HasReflectionPermission,The method has an empty catch block.
Empty Catch Block,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,DatabaseExists,The method has an empty catch block.
Magic Number,System.Data.Linq,Binary,C:\repos\FransBouma_LinqToSQL2\src\Types\Binary.cs,ComputeHash,The following statement contains a magic number: int s = 314' t = 159;
Magic Number,System.Data.Linq,Binary,C:\repos\FransBouma_LinqToSQL2\src\Types\Binary.cs,ComputeHash,The following statement contains a magic number: int s = 314' t = 159;
Magic Number,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,Compare,The following statement contains a magic number: int xAction = x.IsNew ? 0 : x.IsDeleted ? 2 : 1;
Magic Number,System.Data.Linq,ChangeProcessor,C:\repos\FransBouma_LinqToSQL2\src\ChangeManagement\ChangeProcessor.cs,Compare,The following statement contains a magic number: int yAction = y.IsNew ? 0 : y.IsDeleted ? 2 : 1;
Magic Number,System.Data.Linq,ItemList,C:\repos\FransBouma_LinqToSQL2\src\Mapping\ItemList.cs,GrowItems,The following statement contains a magic number: Array.Resize(ref items' count == 0 ? 4 : count * 2);
Magic Number,System.Data.Linq,ItemList,C:\repos\FransBouma_LinqToSQL2\src\Mapping\ItemList.cs,GrowItems,The following statement contains a magic number: Array.Resize(ref items' count == 0 ? 4 : count * 2);
Magic Number,System.Data.Linq,DataContext,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataContext.cs,ExecuteQuery,The following statement contains a magic number: if(_miExecuteQuery == null)  			{  				_miExecuteQuery = typeof(DataContext).GetMethods().Single(m => m.Name == "ExecuteQuery" && m.GetParameters().Length == 2);  			}
Magic Number,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetCachedObject,The following statement contains a magic number: if(mc == null || mc.Arguments.Count < 1 || mc.Arguments.Count > 2)  				return null;
Magic Number,System.Data.Linq,CommonDataServices,C:\repos\FransBouma_LinqToSQL2\src\Querying\DataServices.cs,GetKeysFromPredicate,The following statement contains a magic number: if(bex == null)  			{  				MethodCallExpression mex = expr as MethodCallExpression;  				if(mex != null && mex.Method.Name == "op_Equality" && mex.Arguments.Count == 2)  				{  					bex = Expression.Equal(mex.Arguments[0]' mex.Arguments[1]);  				}  				else  				{  					return false;  				}  			}
Magic Number,System.Data.Linq,IdentityCache<T;K>,C:\repos\FransBouma_LinqToSQL2\src\IdentityMangement\IdentityCacheOfTK.cs,IdentityCache,The following statement contains a magic number: buckets = new int[7];
Magic Number,System.Data.Linq,IdentityCache<T;K>,C:\repos\FransBouma_LinqToSQL2\src\IdentityMangement\IdentityCacheOfTK.cs,IdentityCache,The following statement contains a magic number: slots = new Slot[7];
Magic Number,System.Data.Linq,IdentityCache<T;K>,C:\repos\FransBouma_LinqToSQL2\src\IdentityMangement\IdentityCacheOfTK.cs,Resize,The following statement contains a magic number: int newSize = checked(count * 2 + 1);
Magic Number,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,GetString,The following statement contains a magic number: if(args != null && args.Length > 0)  			{  				for(int i = 0; i < args.Length; i++)  				{  					string text = args[i] as string;  					if(text != null && text.Length > 1024)  					{  						args[i] = text.Substring(0' 1021) + "...";  					}  				}  				return string.Format(CultureInfo.CurrentCulture' @string' args);  			}
Magic Number,System.Data.Linq,SR,C:\repos\FransBouma_LinqToSQL2\src\SR.cs,GetString,The following statement contains a magic number: if(args != null && args.Length > 0)  			{  				for(int i = 0; i < args.Length; i++)  				{  					string text = args[i] as string;  					if(text != null && text.Length > 1024)  					{  						args[i] = text.Substring(0' 1021) + "...";  					}  				}  				return string.Format(CultureInfo.CurrentCulture' @string' args);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2000Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2000Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.NTextType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2000Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2000Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.NTextType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2000Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2000Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.NTextType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2005Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2005Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.XmlType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2005Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2005Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.XmlType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Sql2005Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2005Provider.cs,From,The following statement contains a magic number: switch(tc)  			{  				case TypeCode.Boolean:  					return SqlTypeSystem.Create(SqlDbType.Bit);  				case TypeCode.Byte:  					return SqlTypeSystem.Create(SqlDbType.TinyInt);  				case TypeCode.SByte:  				case TypeCode.Int16:  					return SqlTypeSystem.Create(SqlDbType.SmallInt);  				case TypeCode.Int32:  				case TypeCode.UInt16:  					return SqlTypeSystem.Create(SqlDbType.Int);  				case TypeCode.Int64:  				case TypeCode.UInt32:  					return SqlTypeSystem.Create(SqlDbType.BigInt);  				case TypeCode.UInt64:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 20' 0);  				case TypeCode.Decimal:  					return SqlTypeSystem.Create(SqlDbType.Decimal' 29' size ?? 4);  				case TypeCode.Double:  					return SqlTypeSystem.Create(SqlDbType.Float);  				case TypeCode.Single:  					return SqlTypeSystem.Create(SqlDbType.Real);  				case TypeCode.Char:  					return SqlTypeSystem.Create(SqlDbType.NChar' 1);  				case TypeCode.String:  					return GetBestType(SqlDbType.NVarChar' size);  				case TypeCode.DateTime:  					return SqlTypeSystem.Create(SqlDbType.DateTime);  				case TypeCode.Object:  				{  					if(type == typeof(Guid))  						return SqlTypeSystem.Create(SqlDbType.UniqueIdentifier);  					if(type == typeof(byte[]) || type == typeof(Binary))  						return GetBestType(SqlDbType.VarBinary' size);  					if(type == typeof(char[]))  						return GetBestType(SqlDbType.NVarChar' size);  					if(type == typeof(TimeSpan))  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					if(type == typeof(System.Xml.Linq.XDocument) ||  					   type == typeof(System.Xml.Linq.XElement))  						return ProviderConstants.XmlType;  					// else UDT?  					return new SqlType(type);  				}  				default:  					throw Error.UnexpectedTypeCode(tc);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,GetCreateSchemaForTableCommand,The following statement contains a magic number: if((parts.Count) < 2)  			{  				return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,GetCreateSchemaForTableCommand,The following statement contains a magic number: string schema = parts[parts.Count - 2];
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The following statement contains a magic number: switch(targetType)  			{  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  					maxSize = 4000;  					break;  				case SqlDbType.Char:  				case SqlDbType.VarChar:  				case SqlDbType.Binary:  				case SqlDbType.VarBinary:  					maxSize = 8000;  					break;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The following statement contains a magic number: switch(targetType)  			{  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  					maxSize = 4000;  					break;  				case SqlDbType.Char:  				case SqlDbType.VarChar:  				case SqlDbType.Binary:  				case SqlDbType.VarBinary:  					maxSize = 8000;  					break;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetLargestDeclarableSize,The following statement contains a magic number: switch(declaredType.SqlDbType)  			{  				case SqlDbType.Image:  				case SqlDbType.Binary:  				case SqlDbType.VarChar:  					return 8000;  				case SqlDbType.NVarChar:  					return 4000;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetLargestDeclarableSize,The following statement contains a magic number: switch(declaredType.SqlDbType)  			{  				case SqlDbType.Image:  				case SqlDbType.Binary:  				case SqlDbType.VarChar:  					return 8000;  				case SqlDbType.NVarChar:  					return 4000;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The following statement contains a magic number: switch(functionCall.Name)  			{  				case "LEN":  				case "DATALENGTH":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.VarChar:  						case SqlDbType.VarBinary:  							if(arg0.IsLargeType)  							{  								return SqlTypeSystem.Create(SqlDbType.BigInt);  							}  							else  							{  								return SqlTypeSystem.Create(SqlDbType.Int);  							}  						default:  							return SqlTypeSystem.Create(SqlDbType.Int);  					}  				case "ABS":  				case "SIGN":  				case "ROUND":  				case "CEILING":  				case "FLOOR":  				case "POWER":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.TinyInt:  						case SqlDbType.Int:  						case SqlDbType.SmallInt:  							return SqlTypeSystem.Create(SqlDbType.Int);  						case SqlDbType.Float:  						case SqlDbType.Real:  							return SqlTypeSystem.Create(SqlDbType.Float);  						default:  							return arg0;  					}  				case "PATINDEX":  				case "CHARINDEX":  					if(arg1.IsLargeType)  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					return SqlTypeSystem.Create(SqlDbType.Int);  				case "SUBSTRING":  					if(functionCall.Arguments[2].NodeType == SqlNodeType.Value)  					{  						SqlValue val = (SqlValue)functionCall.Arguments[2];    						if(val.Value is int)  						{  							switch(arg0.SqlDbType)  							{  								case SqlDbType.NVarChar:  								case SqlDbType.NChar:  								case SqlDbType.VarChar:  								case SqlDbType.Char:  									return SqlTypeSystem.Create(arg0.SqlDbType' (int)val.Value);  								default:  									return null;  							}  						}  					}  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.NChar:  							return SqlTypeSystem.Create(SqlDbType.NVarChar);  						case SqlDbType.VarChar:  						case SqlDbType.Char:  							return SqlTypeSystem.Create(SqlDbType.VarChar);  						default:  							return null;  					}  				case "STUFF":  					// if the stuff call is an insertion  and is strictly additive  					// (no deletion of characters) the return type is the same as   					// a concatenation  					if(functionCall.Arguments.Count == 4)  					{  						SqlValue delLength = functionCall.Arguments[2] as SqlValue;  						if(delLength != null && (int)delLength.Value == 0)  						{  							return PredictTypeForBinary(SqlNodeType.Concat'  								functionCall.Arguments[0].SqlType' functionCall.Arguments[3].SqlType);  						}  					}  					return null;  				case "LOWER":  				case "UPPER":  				case "RTRIM":  				case "LTRIM":  				case "INSERT":  				case "REPLACE":  				case "LEFT":  				case "RIGHT":  				case "REVERSE":  					return arg0;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The following statement contains a magic number: switch(functionCall.Name)  			{  				case "LEN":  				case "DATALENGTH":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.VarChar:  						case SqlDbType.VarBinary:  							if(arg0.IsLargeType)  							{  								return SqlTypeSystem.Create(SqlDbType.BigInt);  							}  							else  							{  								return SqlTypeSystem.Create(SqlDbType.Int);  							}  						default:  							return SqlTypeSystem.Create(SqlDbType.Int);  					}  				case "ABS":  				case "SIGN":  				case "ROUND":  				case "CEILING":  				case "FLOOR":  				case "POWER":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.TinyInt:  						case SqlDbType.Int:  						case SqlDbType.SmallInt:  							return SqlTypeSystem.Create(SqlDbType.Int);  						case SqlDbType.Float:  						case SqlDbType.Real:  							return SqlTypeSystem.Create(SqlDbType.Float);  						default:  							return arg0;  					}  				case "PATINDEX":  				case "CHARINDEX":  					if(arg1.IsLargeType)  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					return SqlTypeSystem.Create(SqlDbType.Int);  				case "SUBSTRING":  					if(functionCall.Arguments[2].NodeType == SqlNodeType.Value)  					{  						SqlValue val = (SqlValue)functionCall.Arguments[2];    						if(val.Value is int)  						{  							switch(arg0.SqlDbType)  							{  								case SqlDbType.NVarChar:  								case SqlDbType.NChar:  								case SqlDbType.VarChar:  								case SqlDbType.Char:  									return SqlTypeSystem.Create(arg0.SqlDbType' (int)val.Value);  								default:  									return null;  							}  						}  					}  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.NChar:  							return SqlTypeSystem.Create(SqlDbType.NVarChar);  						case SqlDbType.VarChar:  						case SqlDbType.Char:  							return SqlTypeSystem.Create(SqlDbType.VarChar);  						default:  							return null;  					}  				case "STUFF":  					// if the stuff call is an insertion  and is strictly additive  					// (no deletion of characters) the return type is the same as   					// a concatenation  					if(functionCall.Arguments.Count == 4)  					{  						SqlValue delLength = functionCall.Arguments[2] as SqlValue;  						if(delLength != null && (int)delLength.Value == 0)  						{  							return PredictTypeForBinary(SqlNodeType.Concat'  								functionCall.Arguments[0].SqlType' functionCall.Arguments[3].SqlType);  						}  					}  					return null;  				case "LOWER":  				case "UPPER":  				case "RTRIM":  				case "LTRIM":  				case "INSERT":  				case "REPLACE":  				case "LEFT":  				case "RIGHT":  				case "REVERSE":  					return arg0;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The following statement contains a magic number: switch(functionCall.Name)  			{  				case "LEN":  				case "DATALENGTH":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.VarChar:  						case SqlDbType.VarBinary:  							if(arg0.IsLargeType)  							{  								return SqlTypeSystem.Create(SqlDbType.BigInt);  							}  							else  							{  								return SqlTypeSystem.Create(SqlDbType.Int);  							}  						default:  							return SqlTypeSystem.Create(SqlDbType.Int);  					}  				case "ABS":  				case "SIGN":  				case "ROUND":  				case "CEILING":  				case "FLOOR":  				case "POWER":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.TinyInt:  						case SqlDbType.Int:  						case SqlDbType.SmallInt:  							return SqlTypeSystem.Create(SqlDbType.Int);  						case SqlDbType.Float:  						case SqlDbType.Real:  							return SqlTypeSystem.Create(SqlDbType.Float);  						default:  							return arg0;  					}  				case "PATINDEX":  				case "CHARINDEX":  					if(arg1.IsLargeType)  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					return SqlTypeSystem.Create(SqlDbType.Int);  				case "SUBSTRING":  					if(functionCall.Arguments[2].NodeType == SqlNodeType.Value)  					{  						SqlValue val = (SqlValue)functionCall.Arguments[2];    						if(val.Value is int)  						{  							switch(arg0.SqlDbType)  							{  								case SqlDbType.NVarChar:  								case SqlDbType.NChar:  								case SqlDbType.VarChar:  								case SqlDbType.Char:  									return SqlTypeSystem.Create(arg0.SqlDbType' (int)val.Value);  								default:  									return null;  							}  						}  					}  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.NChar:  							return SqlTypeSystem.Create(SqlDbType.NVarChar);  						case SqlDbType.VarChar:  						case SqlDbType.Char:  							return SqlTypeSystem.Create(SqlDbType.VarChar);  						default:  							return null;  					}  				case "STUFF":  					// if the stuff call is an insertion  and is strictly additive  					// (no deletion of characters) the return type is the same as   					// a concatenation  					if(functionCall.Arguments.Count == 4)  					{  						SqlValue delLength = functionCall.Arguments[2] as SqlValue;  						if(delLength != null && (int)delLength.Value == 0)  						{  							return PredictTypeForBinary(SqlNodeType.Concat'  								functionCall.Arguments[0].SqlType' functionCall.Arguments[3].SqlType);  						}  					}  					return null;  				case "LOWER":  				case "UPPER":  				case "RTRIM":  				case "LTRIM":  				case "INSERT":  				case "REPLACE":  				case "LEFT":  				case "RIGHT":  				case "REVERSE":  					return arg0;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The following statement contains a magic number: switch(functionCall.Name)  			{  				case "LEN":  				case "DATALENGTH":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.VarChar:  						case SqlDbType.VarBinary:  							if(arg0.IsLargeType)  							{  								return SqlTypeSystem.Create(SqlDbType.BigInt);  							}  							else  							{  								return SqlTypeSystem.Create(SqlDbType.Int);  							}  						default:  							return SqlTypeSystem.Create(SqlDbType.Int);  					}  				case "ABS":  				case "SIGN":  				case "ROUND":  				case "CEILING":  				case "FLOOR":  				case "POWER":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.TinyInt:  						case SqlDbType.Int:  						case SqlDbType.SmallInt:  							return SqlTypeSystem.Create(SqlDbType.Int);  						case SqlDbType.Float:  						case SqlDbType.Real:  							return SqlTypeSystem.Create(SqlDbType.Float);  						default:  							return arg0;  					}  				case "PATINDEX":  				case "CHARINDEX":  					if(arg1.IsLargeType)  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					return SqlTypeSystem.Create(SqlDbType.Int);  				case "SUBSTRING":  					if(functionCall.Arguments[2].NodeType == SqlNodeType.Value)  					{  						SqlValue val = (SqlValue)functionCall.Arguments[2];    						if(val.Value is int)  						{  							switch(arg0.SqlDbType)  							{  								case SqlDbType.NVarChar:  								case SqlDbType.NChar:  								case SqlDbType.VarChar:  								case SqlDbType.Char:  									return SqlTypeSystem.Create(arg0.SqlDbType' (int)val.Value);  								default:  									return null;  							}  						}  					}  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.NChar:  							return SqlTypeSystem.Create(SqlDbType.NVarChar);  						case SqlDbType.VarChar:  						case SqlDbType.Char:  							return SqlTypeSystem.Create(SqlDbType.VarChar);  						default:  							return null;  					}  				case "STUFF":  					// if the stuff call is an insertion  and is strictly additive  					// (no deletion of characters) the return type is the same as   					// a concatenation  					if(functionCall.Arguments.Count == 4)  					{  						SqlValue delLength = functionCall.Arguments[2] as SqlValue;  						if(delLength != null && (int)delLength.Value == 0)  						{  							return PredictTypeForBinary(SqlNodeType.Concat'  								functionCall.Arguments[0].SqlType' functionCall.Arguments[3].SqlType);  						}  					}  					return null;  				case "LOWER":  				case "UPPER":  				case "RTRIM":  				case "LTRIM":  				case "INSERT":  				case "REPLACE":  				case "LEFT":  				case "RIGHT":  				case "REVERSE":  					return arg0;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,ReturnTypeOfFunction,The following statement contains a magic number: switch(functionCall.Name)  			{  				case "LEN":  				case "DATALENGTH":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.VarChar:  						case SqlDbType.VarBinary:  							if(arg0.IsLargeType)  							{  								return SqlTypeSystem.Create(SqlDbType.BigInt);  							}  							else  							{  								return SqlTypeSystem.Create(SqlDbType.Int);  							}  						default:  							return SqlTypeSystem.Create(SqlDbType.Int);  					}  				case "ABS":  				case "SIGN":  				case "ROUND":  				case "CEILING":  				case "FLOOR":  				case "POWER":  					switch(arg0.SqlDbType)  					{  						case SqlDbType.TinyInt:  						case SqlDbType.Int:  						case SqlDbType.SmallInt:  							return SqlTypeSystem.Create(SqlDbType.Int);  						case SqlDbType.Float:  						case SqlDbType.Real:  							return SqlTypeSystem.Create(SqlDbType.Float);  						default:  							return arg0;  					}  				case "PATINDEX":  				case "CHARINDEX":  					if(arg1.IsLargeType)  						return SqlTypeSystem.Create(SqlDbType.BigInt);  					return SqlTypeSystem.Create(SqlDbType.Int);  				case "SUBSTRING":  					if(functionCall.Arguments[2].NodeType == SqlNodeType.Value)  					{  						SqlValue val = (SqlValue)functionCall.Arguments[2];    						if(val.Value is int)  						{  							switch(arg0.SqlDbType)  							{  								case SqlDbType.NVarChar:  								case SqlDbType.NChar:  								case SqlDbType.VarChar:  								case SqlDbType.Char:  									return SqlTypeSystem.Create(arg0.SqlDbType' (int)val.Value);  								default:  									return null;  							}  						}  					}  					switch(arg0.SqlDbType)  					{  						case SqlDbType.NVarChar:  						case SqlDbType.NChar:  							return SqlTypeSystem.Create(SqlDbType.NVarChar);  						case SqlDbType.VarChar:  						case SqlDbType.Char:  							return SqlTypeSystem.Create(SqlDbType.VarChar);  						default:  							return null;  					}  				case "STUFF":  					// if the stuff call is an insertion  and is strictly additive  					// (no deletion of characters) the return type is the same as   					// a concatenation  					if(functionCall.Arguments.Count == 4)  					{  						SqlValue delLength = functionCall.Arguments[2] as SqlValue;  						if(delLength != null && (int)delLength.Value == 0)  						{  							return PredictTypeForBinary(SqlNodeType.Concat'  								functionCall.Arguments[0].SqlType' functionCall.Arguments[3].SqlType);  						}  					}  					return null;  				case "LOWER":  				case "UPPER":  				case "RTRIM":  				case "LTRIM":  				case "INSERT":  				case "REPLACE":  				case "LEFT":  				case "RIGHT":  				case "REVERSE":  					return arg0;  				default:  					return null;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The following statement contains a magic number: if(sqlTypeA.HasPrecisionAndScale && sqlTypeB.HasPrecisionAndScale && bestType.SqlDbType == SqlDbType.Decimal)  			{  				int p0 = sqlTypeA.Precision;  				int s0 = sqlTypeA.Scale;  				int p1 = sqlTypeB.Precision;  				int s1 = sqlTypeB.Scale;  				// precision and scale may be zero if this is an unsized type.  				if(p0 == 0 && s0 == 0 && p1 == 0 && s1 == 0)  				{  					return SqlTypeSystem.Create(bestType.SqlDbType);  				}  				else if(p0 == 0 && s0 == 0)  				{  					return SqlTypeSystem.Create(bestType.SqlDbType' p1' s1);  				}  				else if(p1 == 0 && s1 == 0)  				{  					return SqlTypeSystem.Create(bestType.SqlDbType' p0' s0);  				}  				// determine best scale/precision  				int bestLeft = Math.Max(p0 - s0' p1 - s1);  				int bestRight = Math.Max(s0' s1);  				int precision = Math.Min(bestLeft + bestRight' 38);  				return SqlTypeSystem.Create(bestType.SqlDbType' precision' /*scale*/bestRight);  			}  			else  			{  				// determine the best size  				int? bestSize = null;    				if(sqlTypeA.Size.HasValue && sqlTypeB.Size.HasValue)  				{  					bestSize = (sqlTypeB.Size > sqlTypeA.Size) ? sqlTypeB.Size : sqlTypeA.Size;  				}    				if(sqlTypeB.Size.HasValue && sqlTypeB.Size.Value == ProviderConstants.LargeTypeSizeIndicator  				   || sqlTypeA.Size.HasValue && sqlTypeA.Size.Value == ProviderConstants.LargeTypeSizeIndicator)  				{  					// the large type size trumps all  					bestSize = ProviderConstants.LargeTypeSizeIndicator;  				}    				bestType = new SqlType(bestType.SqlDbType' bestSize);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,From,The following statement contains a magic number: if(clrType == typeof(string))  			{  				string str = (string)o;  				return From(clrType' str.Length);  			}  			else if(clrType == typeof(bool))  			{  				return From(typeof(int));  			}  			else if(clrType.IsArray)  			{  				Array arr = (Array)o;  				return From(clrType' arr.Length);  			}  			else if(clrType == typeof(decimal))  			{  				decimal d = (decimal)o;  				// The CLR stores the scale of a decimal value in bits  				// 16 to 23 (i.e.' mask 0x00FF0000) of the fourth int.   				int scale = (Decimal.GetBits(d)[3] & 0x00FF0000) >> 16;  				return From(clrType' scale);  			}  			else  			{  				return From(clrType);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,From,The following statement contains a magic number: if(clrType == typeof(string))  			{  				string str = (string)o;  				return From(clrType' str.Length);  			}  			else if(clrType == typeof(bool))  			{  				return From(typeof(int));  			}  			else if(clrType.IsArray)  			{  				Array arr = (Array)o;  				return From(clrType' arr.Length);  			}  			else if(clrType == typeof(decimal))  			{  				decimal d = (decimal)o;  				// The CLR stores the scale of a decimal value in bits  				// 16 to 23 (i.e.' mask 0x00FF0000) of the fourth int.   				int scale = (Decimal.GetBits(d)[3] & 0x00FF0000) >> 16;  				return From(clrType' scale);  			}  			else  			{  				return From(clrType);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewString,The following statement contains a magic number: if(sox.ClrType == typeof(string) && sox.Args.Count == 2  					&& sox.Args[0].ClrType == typeof(char) && sox.Args[1].ClrType == typeof(int))  				{  					return sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { sox.Args[0]' sox.Args[1] }' sox.SourceExpression);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTime,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime) && sox.Args.Count >= 3 &&  					sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int))  				{  					SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  					SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  					SqlExpression year = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char4' sox.Args[0] }' source);  					SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  					SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);  					SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  					if(sox.Args.Count == 3)  					{  						SqlExpression date = sql.Concat(month' sql.ValueFromObject("/"' false' source)' day' sql.ValueFromObject("/"' false' source)' year);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' date' sql.ValueFromObject(101' false' source) }' source);  					}  					if(sox.Args.Count >= 6 &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{  						// DateTime(year' month' day' hour' minute' second )   						// --> CONVERT(DATETIME' CONVERT(nchar(2)'@month) + '-' + CONVERT(nchar(2)'@day) + '-' + CONVERT(nchar(4)'@year) +  						//                 ' ' + CONVERT(nchar(2)'@hour) + ':' + CONVERT(nchar(2)'@minute) + ':' + CONVERT(nchar(2)'@second)  '120)  						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);  						SqlExpression dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  						if(sox.Args.Count == 6)  						{  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  						{  							// DateTime(year' month' day' hour' minute' second' millisecond )   							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms;  							if(this.providerMode == SqlServerProviderMode.SqlCE)  							{  								//SqlCE doesn't have "RIGHT"' so need to use "SUBSTRING"  								SqlExpression len = sql.FunctionCall(typeof(int)' "LEN"' new SqlExpression[1] { msRaw }' source);  								SqlExpression startIndex = sql.Binary(SqlNodeType.Sub' len' sql.ValueFromObject(2' false' source));  								ms = sql.FunctionCall(typeof(string)' "SUBSTRING"' new SqlExpression[3] { msRaw' startIndex' sql.ValueFromObject(3' false' source) }' source);  							}  							else  							{  								ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							}  							dateAndTime = sql.Concat(dateAndTime' sql.ValueFromObject('.'' false' source)' ms);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[3] { datetime' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewDateTimeOffset,The following statement contains a magic number: if(sox.ClrType == typeof(DateTimeOffset))  				{  					// DateTimeOffset(DateTime dateTime)  					// --> CONVERT(DATETIMEOFFSET' @dateTime)  					if(sox.Args.Count == 1 && sox.Args[0].ClrType == typeof(DateTime))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2] { sox.Args[0]' sql.ValueFromObject(0' false' source) }'  												source);  					}  					// DateTimeOffset(DateTime dateTime' TimeSpan timeSpan)  					// --> DATEADD(DATETIMEOFFSET' @dateTimePart)  					if(sox.Args.Count == 2 && sox.Args[0].ClrType == typeof(DateTime) && sox.Args[1].ClrType == typeof(TimeSpan))  					{  						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       sox.Args[0]'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[1])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  					// DateTimeOffset(year' month' day' hour' minute' second' [millisecond'] timeSpan)   					//  					if(sox.Args.Count >= 7 &&  						sox.Args[0].ClrType == typeof(int) && sox.Args[1].ClrType == typeof(int) && sox.Args[2].ClrType == typeof(int) &&  						sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  					{    						SqlExpression char2 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(2' false' source) }' source);  						SqlExpression char4 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(4' false' source) }' source);  						SqlExpression char5 = sql.FunctionCall(typeof(void)' "NCHAR"' new SqlExpression[1] { sql.ValueFromObject(5' false' source) }' source);    						// add leading zeros to year by RIGHT(CONVERT(NCHAR(5)'10000+@ms)'4)   						SqlExpression yyRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char5'                                         sql.Add(sql.ValueFromObject(10000' false' source)'sox.Args[0])}' source);  						SqlExpression year = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { yyRaw' sql.ValueFromObject(4' false' source) }' source);    						SqlExpression month = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[1] }' source);  						SqlExpression day = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[2] }' source);    						SqlExpression hour = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[3] }' source);  						SqlExpression minute = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[4] }' source);  						SqlExpression second = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] { char2' sox.Args[5] }' source);  						SqlExpression date = sql.Concat(year' sql.ValueFromObject("-"' false' source)' month' sql.ValueFromObject("-"' false' source)' day);  						SqlExpression time = sql.Concat(hour' sql.ValueFromObject(":"' false' source)' minute' sql.ValueFromObject(":"' false' source)' second);    						SqlExpression datetimeoffset = new SqlVariable(typeof(void)' null' "DATETIMEOFFSET"' source);  						SqlExpression result' dateAndTime;  						int timeSpanIndex;    						if(sox.Args.Count == 7 && sox.Args[6].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 6;  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(120' false' source) }' source);  						}  						else if(sox.Args.Count == 8 && sox.Args[6].ClrType == typeof(int) && sox.Args[7].ClrType == typeof(TimeSpan))  						{  							timeSpanIndex = 7;  							// add leading zeros to milliseconds by RIGHT(CONVERT(NCHAR(4)'1000+@ms)'3)   							SqlExpression msRaw = sql.FunctionCall(typeof(string)' "CONVERT"' new SqlExpression[2] {char4'                                         sql.Add(sql.ValueFromObject(1000' false' source)'sox.Args[6])}' source);  							SqlExpression ms = sql.FunctionCall(typeof(string)' "RIGHT"' new SqlExpression[2] { msRaw' sql.ValueFromObject(3' false' source) }' source);  							dateAndTime = sql.Concat(date' sql.ValueFromObject(' '' false' source)' time' sql.ValueFromObject('.'' false' source)' ms);  							result = sql.FunctionCall(typeof(DateTimeOffset)' "CONVERT"' new SqlExpression[3] { datetimeoffset' dateAndTime' sql.ValueFromObject(121' false' source) }' source);  						}  						else  						{  							throw Error.UnsupportedDateTimeOffsetConstructorForm();  						}    						return sql.FunctionCall(typeof(DateTimeOffset)' "TODATETIMEOFFSET"'  												new SqlExpression[2]                                                   {                                                       result'                                                       sql.ConvertToInt(sql.ConvertToBigint(sql.Divide(sql.ConvertTimeToDouble(sox.Args[timeSpanIndex])' TimeSpan.TicksPerMinute)))                                                  }'  												source);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateNewTimeSpan,The following statement contains a magic number: if(sox.Args.Count == 1)  				{  					return sql.ConvertTo(typeof(TimeSpan)' sox.Args[0]);  				}  				else if(sox.Args.Count == 3)  				{  					// TimeSpan(hours' minutes' seconds)  					SqlExpression hours = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					return sql.ConvertTo(typeof(TimeSpan)' sql.Add(TicksFromHours' TicksFromMinutes' TicksFromSeconds));  				}  				else  				{  					SqlExpression days = sql.ConvertToBigint(sox.Args[0]);  					SqlExpression hours = sql.ConvertToBigint(sox.Args[1]);  					SqlExpression minutes = sql.ConvertToBigint(sox.Args[2]);  					SqlExpression seconds = sql.ConvertToBigint(sox.Args[3]);  					SqlExpression TicksFromDays = sql.Multiply(days' TimeSpan.TicksPerDay);  					SqlExpression TicksFromHours = sql.Multiply(hours' TimeSpan.TicksPerHour);  					SqlExpression TicksFromMinutes = sql.Multiply(minutes' TimeSpan.TicksPerMinute);  					SqlExpression TicksFromSeconds = sql.Multiply(seconds' TimeSpan.TicksPerSecond);  					SqlExpression totalTicks = sql.Add(TicksFromDays' TicksFromHours' TicksFromMinutes' TicksFromSeconds);  					if(sox.Args.Count == 4)  					{  						// TimeSpan(days' hours' minutes' seconds)  						return sql.ConvertTo(typeof(TimeSpan)' totalTicks);  					}  					else if(sox.Args.Count == 5)  					{  						// TimeSpan(days' hours' minutes' seconds' milliseconds)  						SqlExpression milliseconds = sql.ConvertToBigint(sox.Args[4]);  						SqlExpression ticksFromMs = sql.Multiply(milliseconds' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(totalTicks' ticksFromMs));  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMethodCall,The following statement contains a magic number: if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "op_Explicit" || mc.Method.Name == "op_Implicit")  					{  						if(mc.SqlType.CanBeColumn && mc.Arguments[0].SqlType.CanBeColumn)  						{  							returnValue = sql.ConvertTo(mc.ClrType' mc.Arguments[0]);  						}  					}  					else if(mc.Method.Name == "Compare" && mc.Arguments.Count == 2 && mc.Method.ReturnType == typeof(int))  					{  						returnValue = this.CreateComparison(mc.Arguments[0]' mc.Arguments[1]' mc.SourceExpression);  					}  					else if(declType == typeof(System.Math))  					{  						returnValue = TranslateMathMethod(mc);  					}  					else if(declType == typeof(System.String))  					{  						returnValue = TranslateStringStaticMethod(mc);  					}  					else if(declType == typeof(System.Convert))  					{  						returnValue = TranslateConvertStaticMethod(mc);  					}  					else if(declType == typeof(SqlMethods))  					{  						returnValue = TranslateSqlMethodsMethod(mc);  					}  					else if(declType == typeof(decimal))  					{  						returnValue = TranslateDecimalMethod(mc);  					}  					else if(IsVbConversionMethod(mc))  					{  						return TranslateVbConversionMethod(mc);  					}  					else if(IsVbCompareString(mc))  					{  						return TranslateVbCompareString(mc);  					}  					else if(IsVbLike(mc))  					{  						return TranslateVbLikeString(mc);  					}    					//Recognized pattern has set return value so return  					if(returnValue != null)  					{  						// Assert here to verify that actual translation stays in [....] with  						// method support logic  						Debug.Assert(GetMethodSupport(mc) == MethodSupport.Method);  						return returnValue;  					}  				}  				else  				{ // not static     					if(mc.Method.Name == "Equals" && mc.Arguments.Count == 1)  					{  						return sql.Binary(SqlNodeType.EQ' mc.Object' mc.Arguments[0]);  					}  					else if(mc.Method.Name == "GetValueOrDefault" && mc.Method.DeclaringType.IsGenericType  							   && mc.Method.DeclaringType.GetGenericTypeDefinition() == typeof(Nullable<>))  					{  						return TranslateGetValueOrDefaultMethod(mc);  					}  					else if(mc.Method.Name == "ToString" && mc.Arguments.Count == 0)  					{  						SqlExpression expr = mc.Object;  						if(!expr.SqlType.IsRuntimeOnlyType)  						{  							return sql.ConvertTo(typeof(string)' expr);  						}  						throw Error.ToStringOnlySupportedForPrimitiveTypes();  					}  					else if(declType == typeof(string))  					{  						return TranslateStringMethod(mc);  					}  					else if(declType == typeof(TimeSpan))  					{  						returnValue = TranslateTimeSpanInstanceMethod(mc);  					}  					else if(declType == typeof(DateTime))  					{  						returnValue = TranslateDateTimeInstanceMethod(mc);  					}  					else if(declType == typeof(DateTimeOffset))  					{  						returnValue = TranslateDateTimeOffsetInstanceMethod(mc);  					}  					if(returnValue != null)  					{  						// Assert here to verify that actual translation stays in [....] with  						// method support logic  						Debug.Assert(GetMethodSupport(mc) == MethodSupport.Method);  						return returnValue;  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateSqlMethodsMethod,The following statement contains a magic number: if(name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							SqlExpression start = mc.Arguments[0];  							SqlExpression end = mc.Arguments[1];  							SqlExpression unit = new SqlVariable(typeof(void)' null' datePart' source);  							return sql.FunctionCall(typeof(int)' "DATEDIFF"'  													new SqlExpression[] { unit' start' end }' source);  						}  					}  				}  				else if(name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' null' source);  					}  					else if(mc.Arguments.Count == 3)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' sql.ConvertTo(typeof(string)' mc.Arguments[2])' source);  					}  				}  				else if(name == "RawLength")  				{  					SqlExpression length = sql.FunctionCallDataLength(mc.Arguments[0]);  					return length;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateSqlMethodsMethod,The following statement contains a magic number: if(name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							SqlExpression start = mc.Arguments[0];  							SqlExpression end = mc.Arguments[1];  							SqlExpression unit = new SqlVariable(typeof(void)' null' datePart' source);  							return sql.FunctionCall(typeof(int)' "DATEDIFF"'  													new SqlExpression[] { unit' start' end }' source);  						}  					}  				}  				else if(name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' null' source);  					}  					else if(mc.Arguments.Count == 3)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' sql.ConvertTo(typeof(string)' mc.Arguments[2])' source);  					}  				}  				else if(name == "RawLength")  				{  					SqlExpression length = sql.FunctionCallDataLength(mc.Arguments[0]);  					return length;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateSqlMethodsMethod,The following statement contains a magic number: if(name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							SqlExpression start = mc.Arguments[0];  							SqlExpression end = mc.Arguments[1];  							SqlExpression unit = new SqlVariable(typeof(void)' null' datePart' source);  							return sql.FunctionCall(typeof(int)' "DATEDIFF"'  													new SqlExpression[] { unit' start' end }' source);  						}  					}  				}  				else if(name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' null' source);  					}  					else if(mc.Arguments.Count == 3)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' sql.ConvertTo(typeof(string)' mc.Arguments[2])' source);  					}  				}  				else if(name == "RawLength")  				{  					SqlExpression length = sql.FunctionCallDataLength(mc.Arguments[0]);  					return length;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateSqlMethodsMethod,The following statement contains a magic number: if(name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							SqlExpression start = mc.Arguments[0];  							SqlExpression end = mc.Arguments[1];  							SqlExpression unit = new SqlVariable(typeof(void)' null' datePart' source);  							return sql.FunctionCall(typeof(int)' "DATEDIFF"'  													new SqlExpression[] { unit' start' end }' source);  						}  					}  				}  				else if(name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' null' source);  					}  					else if(mc.Arguments.Count == 3)  					{  						return sql.Like(mc.Arguments[0]' mc.Arguments[1]' sql.ConvertTo(typeof(string)' mc.Arguments[2])' source);  					}  				}  				else if(name == "RawLength")  				{  					SqlExpression length = sql.FunctionCallDataLength(mc.Arguments[0]);  					return length;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					//   					SqlExpression sqlTicks = mc.Arguments[0];  					if(sql.IsTimeType(mc.Arguments[0]))  					{  						SqlExpression ns = this.sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  						SqlExpression ss = this.sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  						SqlExpression mm = this.sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  						SqlExpression hh = this.sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);  						sqlTicks = sql.Add(  									 sql.Divide(ns' 100)'  									 sql.Multiply(  										 sql.Add(  											 sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  											 sql.Multiply(sql.ConvertToBigint(mm)' 60000)'  											 sql.Multiply(sql.ConvertToBigint(ss)' 1000)  										 )'  										 10000)  									 );  					}  					return this.CreateDateTimeFromDateAndTicks(mc.Object' sqlTicks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeOffsetInstanceMethod,The following statement contains a magic number: if(mc.Method.Name == "CompareTo")  				{  					returnValue = CreateComparison(mc.Object' mc.Arguments[0]' source);  				}  				else if((mc.Method.Name == "Add" && mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  					   || (mc.Method.Name == "AddTicks"))  				{  					SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' mc.Arguments[0]);  					SqlExpression ss = sql.FunctionCallDatePart("SECOND"' mc.Arguments[0]);  					SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' mc.Arguments[0]);  					SqlExpression hh = sql.FunctionCallDatePart("HOUR"' mc.Arguments[0]);    					SqlExpression ticks = sql.Add(  					   sql.Divide(ns' 100)'  					   sql.Multiply(  								   sql.Add(  									   sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  									   sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  									   sql.Multiply(sql.ConvertToBigint(ss)' 1000)  									 )'  								   10000   // 1 millisecond = 10000 ticks  							   )  					   );  					returnValue = this.CreateDateTimeOffsetFromDateAndTicks(mc.Object' ticks' source);  				}  				else if(mc.Method.Name == "AddMonths")  				{  					// date + m --> DATEADD(month' @m' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("MONTH"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddYears")  				{  					// date + y --> DATEADD(year' @y' @date)  					returnValue = sql.FunctionCallDateTimeOffsetAdd("YEAR"' mc.Arguments[0]' mc.Object);  				}  				else if(mc.Method.Name == "AddMilliseconds")  				{  					// date + ms --> DATEADD(ms' @ms' @date)  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' mc.Arguments[0]' source);  				}  				// The following .Net methods take a double parameter' but the SQL function DATEADD only uses the integral part.  				// To make up for this' we compute the number of milliseconds and use DATEADD(ms'...) instead of DATEADD(day'...) etc.  				else if(mc.Method.Name == "AddSeconds")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 1000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddMinutes")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 60000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddHours")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 3600000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}  				else if(mc.Method.Name == "AddDays")  				{  					SqlExpression ms = sql.Multiply(mc.Arguments[0]' 86400000);  					returnValue = this.CreateDateTimeOffsetFromDateAndMs(mc.Object' ms' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following statement contains a magic number: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDecimalMethod,The following statement contains a magic number: if(mc.Method.IsStatic)  				{  					if(mc.Arguments.Count == 2)  					{  						switch(mc.Method.Name)  						{  							case "Multiply":  								return sql.Binary(SqlNodeType.Mul' mc.Arguments[0]' mc.Arguments[1]);  							case "Divide":  								return sql.Binary(SqlNodeType.Div' mc.Arguments[0]' mc.Arguments[1]);  							case "Subtract":  								return sql.Binary(SqlNodeType.Sub' mc.Arguments[0]' mc.Arguments[1]);  							case "Add":  								return sql.Binary(SqlNodeType.Add' mc.Arguments[0]' mc.Arguments[1]);  							case "Remainder":  								return sql.Binary(SqlNodeType.Mod' mc.Arguments[0]' mc.Arguments[1]);  							case "Round":  								// ROUND (x' y)  								return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' mc.Arguments' mc.SourceExpression);  						}  					}  					else if(mc.Arguments.Count == 1)  					{  						switch(mc.Method.Name)  						{  							case "Negate":  								return sql.Unary(SqlNodeType.Negate' mc.Arguments[0]' source);  							case "Floor":  							case "Truncate":  								// Truncate(x) --> ROUND (x' 0' 1)  								return sql.FunctionCall(mc.Method.ReturnType' "ROUND"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           sql.ValueFromObject(0' false' mc.SourceExpression)'                                           sql.ValueFromObject(1' false' mc.SourceExpression)                                       }'  									mc.SourceExpression);  							case "Round":  								// ROUND (x' 0)  								return sql.FunctionCall(mc.Method.ReturnType' "ROUND"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           sql.ValueFromObject(0' false' mc.SourceExpression)                                       }'  									mc.SourceExpression);  							default:  								if(mc.Method.Name.StartsWith("To"' StringComparison.Ordinal))  								{  									return this.TranslateConvertStaticMethod(mc);  								}  								break;  						}  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringStaticMethod,The following statement contains a magic number: if(mc.Method.Name == "Concat")  				{  					SqlClientArray arr = mc.Arguments[0] as SqlClientArray;  					List<SqlExpression> exprs = null;  					if(arr != null)  					{  						exprs = arr.Expressions;  					}  					else  					{  						exprs = mc.Arguments;  					}  					if(exprs.Count == 0)  					{  						returnValue = sql.ValueFromObject(""' false' source);  					}  					else  					{  						SqlExpression sum;  						if(exprs[0].SqlType.IsString || exprs[0].SqlType.IsChar)  						{  							sum = exprs[0];  						}  						else  						{  							sum = sql.ConvertTo(typeof(string)' exprs[0]);  						}  						for(int i = 1; i < exprs.Count; i++)  						{  							if(exprs[i].SqlType.IsString || exprs[i].SqlType.IsChar)  							{  								sum = sql.Concat(sum' exprs[i]);  							}  							else  							{  								sum = sql.Concat(sum' sql.ConvertTo(typeof(string)' exprs[i]));  							}  						}  						returnValue = sum;  					}  				}  				else if((mc.Method.Name == "Equals") && (mc.Arguments.Count == 2))  				{  					returnValue = sql.Binary(SqlNodeType.EQ2V' mc.Arguments[0]' mc.Arguments[1]);  				}  				else if((mc.Method.Name == "Compare") && (mc.Arguments.Count == 2))  				{  					returnValue = CreateComparison(mc.Arguments[0]' mc.Arguments[1]' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringStaticMethod,The following statement contains a magic number: if(mc.Method.Name == "Concat")  				{  					SqlClientArray arr = mc.Arguments[0] as SqlClientArray;  					List<SqlExpression> exprs = null;  					if(arr != null)  					{  						exprs = arr.Expressions;  					}  					else  					{  						exprs = mc.Arguments;  					}  					if(exprs.Count == 0)  					{  						returnValue = sql.ValueFromObject(""' false' source);  					}  					else  					{  						SqlExpression sum;  						if(exprs[0].SqlType.IsString || exprs[0].SqlType.IsChar)  						{  							sum = exprs[0];  						}  						else  						{  							sum = sql.ConvertTo(typeof(string)' exprs[0]);  						}  						for(int i = 1; i < exprs.Count; i++)  						{  							if(exprs[i].SqlType.IsString || exprs[i].SqlType.IsChar)  							{  								sum = sql.Concat(sum' exprs[i]);  							}  							else  							{  								sum = sql.Concat(sum' sql.ConvertTo(typeof(string)' exprs[i]));  							}  						}  						returnValue = sum;  					}  				}  				else if((mc.Method.Name == "Equals") && (mc.Arguments.Count == 2))  				{  					returnValue = sql.Binary(SqlNodeType.EQ2V' mc.Arguments[0]' mc.Arguments[1]);  				}  				else if((mc.Method.Name == "Compare") && (mc.Arguments.Count == 2))  				{  					returnValue = CreateComparison(mc.Arguments[0]' mc.Arguments[1]' source);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following statement contains a magic number: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,VisitMember,The following statement contains a magic number: if(baseClrTypeOfExpr == typeof(string) && member.Name == "Length")  				{  					// This gives a different result than .Net would if the string ends in spaces.  					// We decided not to fix this up (e.g. LEN(@s+'#') - 1) since it would incur a performance hit and   					// people may actually expect that it translates to the SQL LEN function.  					return sql.FunctionCallStringLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(Binary) && member.Name == "Length")  				{  					return sql.FunctionCallDataLength(exp);  				}  				else if(baseClrTypeOfExpr == typeof(DateTime) || baseClrTypeOfExpr == typeof(DateTimeOffset))  				{  					string datePart = GetDatePart(member.Name);  					if(datePart != null)  					{  						return sql.FunctionCallDatePart(datePart' exp);  					}  					else if(member.Name == "Date")  					{  						if(this.providerMode == SqlServerProviderMode.Sql2008)  						{  							SqlExpression date = new SqlVariable(typeof(void)' null' "DATE"' source);  							return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { date' exp }' source);  						}  						// date --> dateadd(hh' -(datepart(hh' @date))'   						//          dateadd(mi' -(datepart(mi' @date))'   						//          dateadd(ss' -(datepart(ss' @date))'   						//          dateadd(ms' -(datepart(ms' @date))'   						//          @date))))    						SqlExpression ms = sql.FunctionCallDatePart("MILLISECOND"' exp);  						SqlExpression ss = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression hh = sql.FunctionCallDatePart("HOUR"' exp);    						SqlExpression result = exp;    						result = sql.FunctionCallDateAdd("MILLISECOND"' sql.Unary(SqlNodeType.Negate' ms)' result);  						result = sql.FunctionCallDateAdd("SECOND"' sql.Unary(SqlNodeType.Negate' ss)' result);  						result = sql.FunctionCallDateAdd("MINUTE"' sql.Unary(SqlNodeType.Negate' mi)' result);  						result = sql.FunctionCallDateAdd("HOUR"' sql.Unary(SqlNodeType.Negate' hh)' result);    						return result;  					}  					else if(member.Name == "DateTime")  					{  						Debug.Assert(baseClrTypeOfExpr == typeof(DateTimeOffset)' "'DateTime' property supported only for instances of DateTimeOffset.");  						SqlExpression datetime = new SqlVariable(typeof(void)' null' "DATETIME"' source);  						return sql.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime' exp }' source);  					}  					else if(member.Name == "TimeOfDay")  					{  						SqlExpression hours = sql.FunctionCallDatePart("HOUR"' exp);  						SqlExpression minutes = sql.FunctionCallDatePart("MINUTE"' exp);  						SqlExpression seconds = sql.FunctionCallDatePart("SECOND"' exp);  						SqlExpression milliseconds = sql.FunctionCallDatePart("MILLISECOND"' exp);    						SqlExpression ticksFromHour = sql.Multiply(sql.ConvertToBigint(hours)' TimeSpan.TicksPerHour);  						SqlExpression ticksFromMinutes = sql.Multiply(sql.ConvertToBigint(minutes)' TimeSpan.TicksPerMinute);  						SqlExpression ticksFromSeconds = sql.Multiply(sql.ConvertToBigint(seconds)' TimeSpan.TicksPerSecond);  						SqlExpression ticksFromMs = sql.Multiply(sql.ConvertToBigint(milliseconds)' TimeSpan.TicksPerMillisecond);  						return sql.ConvertTo(typeof(TimeSpan)' sql.Add(ticksFromHour' ticksFromMinutes' ticksFromSeconds' ticksFromMs));  					}  					else if(member.Name == "DayOfWeek")  					{  						//(DATEPART(dw'@date) + @@Datefirst + 6) % 7 to make it independent from SQL settings  						SqlExpression sqlDay = sql.FunctionCallDatePart("dw"' exp);    						//   						// .DayOfWeek returns a System.DayOfWeek' so ConvertTo that enum.  						return sql.ConvertTo(typeof(DayOfWeek)'  								sql.Mod(  								  sql.Add(sqlDay'  									 sql.Add(new SqlVariable(typeof(int)' sql.Default(typeof(int))' "@@DATEFIRST"' source)' 6)  								  )  								' 7));  					}  				}  				else if(baseClrTypeOfExpr == typeof(System.TimeSpan))  				{  					switch(member.Name)  					{  						case "Ticks":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											sql.ConvertToBigint(  												sql.Add(  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("HOUR"' exp))' 3600000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("MINUTE"' exp))' 60000000000)'  													this.sql.Multiply(sql.ConvertToBigint(sql.FunctionCallDatePart("SECOND"' exp))' 1000000000)'  													sql.FunctionCallDatePart("NANOSECOND"' exp))  												)'  											100  									);  							}  							return sql.ConvertToBigint(exp);  						case "TotalMilliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600000)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60000)'  											this.sql.Multiply(sql.FunctionCallDatePart("SECOND"' exp)' 1000)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMillisecond);  						case "TotalSeconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 3600)'  											this.sql.Multiply(sql.FunctionCallDatePart("MINUTE"' exp)' 60)'  											this.sql.FunctionCallDatePart("SECOND"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 1000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerSecond);  						case "TotalMinutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.Multiply(sql.FunctionCallDatePart("HOUR"' exp)' 60)'  											this.sql.FunctionCallDatePart("MINUTE"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 60000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerMinute);  						case "TotalHours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Add(  											this.sql.FunctionCallDatePart("HOUR"' exp)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  											this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  											this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000)  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerHour);  						case "TotalDays":  							if(sql.IsTimeType(exp))  							{  								return this.sql.Divide(  											this.sql.Add(  												this.sql.FunctionCallDatePart("HOUR"' exp)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("MINUTE"' exp))' 60)'  												this.sql.Divide(sql.ConvertToDouble(sql.FunctionCallDatePart("SECOND"' exp))' 3600)'  												this.sql.Divide(sql.ConvertToDouble(sql.ConvertToBigint(sql.FunctionCallDatePart("NANOSECOND"' exp)))' 3600000000000))'  											24  										);  							}  							return sql.Divide(sql.ConvertToDouble(exp)' TimeSpan.TicksPerDay);  						case "Milliseconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MILLISECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMillisecond))' 1000));  						case "Seconds":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("SECOND"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerSecond))' 60));  						case "Minutes":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("MINUTE"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerMinute))' 60));  						case "Hours":  							if(sql.IsTimeType(exp))  							{  								return this.sql.FunctionCallDatePart("HOUR"' exp);  							}  							return sql.ConvertToInt(sql.Mod(sql.ConvertToBigint(sql.Divide(exp' TimeSpan.TicksPerHour))' 24));  						case "Days":  							if(sql.IsTimeType(exp))  							{  								return this.sql.ValueFromObject(0' false' exp.SourceExpression);  							}  							return sql.ConvertToInt(sql.Divide(exp' TimeSpan.TicksPerDay));  						default:  							throw Error.MemberCannotBeTranslated(member.DeclaringType' member.Name);  					}  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeFromDateAndTicks,The following statement contains a magic number: return sql.FunctionCallDateAdd("ms"' sql.Mod(sql.Divide(sqlTicks' TimeSpan.TicksPerMillisecond)' 86400000)' daysAdded' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeFromDateAndMs,The following statement contains a magic number: SqlExpression daysAdded = sql.FunctionCallDateAdd("day"' sql.Divide(msBigint' 86400000)' sqlDate' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeFromDateAndMs,The following statement contains a magic number: return sql.FunctionCallDateAdd("ms"' sql.Mod(msBigint' 86400000)' daysAdded' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndTicks,The following statement contains a magic number: return sql.FunctionCallDateTimeOffsetAdd("ms"' sql.Mod(sql.Divide(sqlTicks' TimeSpan.TicksPerMillisecond)' 86400000)' daysAdded' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndMs,The following statement contains a magic number: SqlExpression daysAdded = sql.FunctionCallDateTimeOffsetAdd("day"' sql.Divide(msBigint' 86400000)' sqlDate' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,CreateDateTimeOffsetFromDateAndMs,The following statement contains a magic number: return sql.FunctionCallDateTimeOffsetAdd("ms"' sql.Mod(msBigint' 86400000)' daysAdded' source' asNullable);
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateVbCompareString,The following statement contains a magic number: if(mc.Arguments.Count >= 2)  				{  					return CreateComparison(mc.Arguments[0]' mc.Arguments[1]' mc.SourceExpression);  				}
Magic Number,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateVbLikeString,The following statement contains a magic number: Debug.Assert(mc.Arguments.Count == 3);
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlTypeConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeConverter.cs,ConvertDoubleToString,The following statement contains a magic number: SqlExpression nvarchar = sql.FunctionCall(  				typeof(void)' "NVARCHAR"'  				new SqlExpression[] { sql.ValueFromObject(30' false' expr.SourceExpression) }'  				expr.SourceExpression  				);
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlTypeConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTypeConverter.cs,ConvertDoubleToString,The following statement contains a magic number: return sql.FunctionCall(  				resultClrType' "CONVERT"'  				new SqlExpression[] { nvarchar' expr' sql.ValueFromObject(2' false' expr.SourceExpression) }'  				expr.SourceExpression  				);
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetHashCode,The following statement contains a magic number: return hash ^ this.sqlDbType.GetHashCode() ^ (this.Size ?? 0) ^ (this.Precision) ^ (this.Scale << 8);
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,GetTypeCoercionPrecedence,The following statement contains a magic number: switch(type)  			{  				case SqlDbType.Binary: return 0;  				case SqlDbType.VarBinary: return 1;  				case SqlDbType.VarChar: return 2;  				case SqlDbType.Char: return 3;  				case SqlDbType.NChar: return 4;  				case SqlDbType.NVarChar: return 5;  				case SqlDbType.UniqueIdentifier: return 6;  				case SqlDbType.Timestamp: return 7;  				case SqlDbType.Image: return 8;  				case SqlDbType.Text: return 9;  				case SqlDbType.NText: return 10;  				case SqlDbType.Bit: return 11;  				case SqlDbType.TinyInt: return 12;  				case SqlDbType.SmallInt: return 13;  				case SqlDbType.Int: return 14;  				case SqlDbType.BigInt: return 15;  				case SqlDbType.SmallMoney: return 16;  				case SqlDbType.Money: return 17;  				case SqlDbType.Decimal: return 18;  				case SqlDbType.Real: return 19;  				case SqlDbType.Float: return 20;  				case SqlDbType.Date: return 21;  				case SqlDbType.Time: return 22;  				case SqlDbType.SmallDateTime: return 23;  				case SqlDbType.DateTime: return 24;  				case SqlDbType.DateTime2: return 25;  				case SqlDbType.DateTimeOffset: return 26;  				case SqlDbType.Xml: return 27;  				case SqlDbType.Variant: return 28;  				case SqlDbType.Udt: return 29;  				default:  					throw Error.UnexpectedTypeCode(type);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedStringNew,The following statement contains a magic number: return snew.Args.Count == 2 && snew.Args[0].ClrType == typeof(char) && snew.Args[1].ClrType == typeof(int);
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeNew,The following statement contains a magic number: if(sox.ClrType == typeof(DateTime)  				&& sox.Args.Count >= 3  				&& sox.Args[0].ClrType == typeof(int)  				&& sox.Args[1].ClrType == typeof(int)  				&& sox.Args[2].ClrType == typeof(int))  			{  				if(sox.Args.Count == 3)  				{  					return true;  				}  				if(sox.Args.Count >= 6 &&  					sox.Args[3].ClrType == typeof(int) && sox.Args[4].ClrType == typeof(int) && sox.Args[5].ClrType == typeof(int))  				{  					if(sox.Args.Count == 6)  					{  						return true;  					}  					if((sox.Args.Count == 7) && (sox.Args[6].ClrType == typeof(int)))  					{  						return true;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedTimeSpanNew,The following statement contains a magic number: if(sox.Args.Count == 1)  			{  				return true;  			}  			else if(sox.Args.Count == 3)  			{  				return true;  			}  			else  			{  				if(sox.Args.Count == 4)  				{  					return true;  				}  				else if(sox.Args.Count == 5)  				{  					return true;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedTimeSpanNew,The following statement contains a magic number: if(sox.Args.Count == 1)  			{  				return true;  			}  			else if(sox.Args.Count == 3)  			{  				return true;  			}  			else  			{  				if(sox.Args.Count == 4)  				{  					return true;  				}  				else if(sox.Args.Count == 5)  				{  					return true;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedTimeSpanNew,The following statement contains a magic number: if(sox.Args.Count == 1)  			{  				return true;  			}  			else if(sox.Args.Count == 3)  			{  				return true;  			}  			else  			{  				if(sox.Args.Count == 4)  				{  					return true;  				}  				else if(sox.Args.Count == 5)  				{  					return true;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetSqlMethodsMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(SqlMethods))  			{  				if(mc.Method.Name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							else  							{  								return MethodSupport.MethodGroup;  							}  						}  					}  				}  				else if(mc.Method.Name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return MethodSupport.Method;  					}  					else if(mc.Arguments.Count == 3)  					{  						return MethodSupport.Method;  					}  					return MethodSupport.MethodGroup;  				}  				else if(mc.Method.Name == "RawLength")  				{  					return MethodSupport.Method;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetSqlMethodsMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(SqlMethods))  			{  				if(mc.Method.Name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							else  							{  								return MethodSupport.MethodGroup;  							}  						}  					}  				}  				else if(mc.Method.Name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return MethodSupport.Method;  					}  					else if(mc.Arguments.Count == 3)  					{  						return MethodSupport.Method;  					}  					return MethodSupport.MethodGroup;  				}  				else if(mc.Method.Name == "RawLength")  				{  					return MethodSupport.Method;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetSqlMethodsMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(SqlMethods))  			{  				if(mc.Method.Name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							else  							{  								return MethodSupport.MethodGroup;  							}  						}  					}  				}  				else if(mc.Method.Name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return MethodSupport.Method;  					}  					else if(mc.Arguments.Count == 3)  					{  						return MethodSupport.Method;  					}  					return MethodSupport.MethodGroup;  				}  				else if(mc.Method.Name == "RawLength")  				{  					return MethodSupport.Method;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetSqlMethodsMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(SqlMethods))  			{  				if(mc.Method.Name.StartsWith("DateDiff"' StringComparison.Ordinal) && mc.Arguments.Count == 2)  				{  					foreach(string datePart in dateParts)  					{  						if(mc.Method.Name == "DateDiff" + datePart)  						{  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							else  							{  								return MethodSupport.MethodGroup;  							}  						}  					}  				}  				else if(mc.Method.Name == "Like")  				{  					if(mc.Arguments.Count == 2)  					{  						return MethodSupport.Method;  					}  					else if(mc.Arguments.Count == 3)  					{  						return MethodSupport.Method;  					}  					return MethodSupport.MethodGroup;  				}  				else if(mc.Method.Name == "RawLength")  				{  					return MethodSupport.Method;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetDecimalMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic)  			{  				if(mc.Arguments.Count == 2)  				{  					switch(mc.Method.Name)  					{  						case "Multiply":  						case "Divide":  						case "Subtract":  						case "Add":  						case "Remainder":  						case "Round":  							return MethodSupport.Method;  					}  				}  				else if(mc.Arguments.Count == 1)  				{  					switch(mc.Method.Name)  					{  						case "Negate":  						case "Floor":  						case "Truncate":  						case "Round":  							return MethodSupport.Method;  						default:  							if(mc.Method.Name.StartsWith("To"' StringComparison.Ordinal))  							{  								return MethodSupport.Method;  							}  							break;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetStringMethodSupport,The following statement contains a magic number: if(mc.Method.DeclaringType == typeof(string))  			{  				if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "Concat")  					{  						return MethodSupport.Method;  					}  				}  				else  				{  					switch(mc.Method.Name)  					{  						case "Contains":  						case "StartsWith":  						case "EndsWith":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "IndexOf":  						case "LastIndexOf":  							if(mc.Arguments.Count == 1  								|| mc.Arguments.Count == 2  								|| mc.Arguments.Count == 3)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Insert":  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "PadLeft":  						case "PadRight":  						case "Remove":  						case "Substring":  							if(mc.Arguments.Count == 1  							   || mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Replace":  							return MethodSupport.Method;  						case "Trim":  						case "ToLower":  						case "ToUpper":  							if(mc.Arguments.Count == 0)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "get_Chars":  						case "CompareTo":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetStringMethodSupport,The following statement contains a magic number: if(mc.Method.DeclaringType == typeof(string))  			{  				if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "Concat")  					{  						return MethodSupport.Method;  					}  				}  				else  				{  					switch(mc.Method.Name)  					{  						case "Contains":  						case "StartsWith":  						case "EndsWith":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "IndexOf":  						case "LastIndexOf":  							if(mc.Arguments.Count == 1  								|| mc.Arguments.Count == 2  								|| mc.Arguments.Count == 3)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Insert":  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "PadLeft":  						case "PadRight":  						case "Remove":  						case "Substring":  							if(mc.Arguments.Count == 1  							   || mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Replace":  							return MethodSupport.Method;  						case "Trim":  						case "ToLower":  						case "ToUpper":  							if(mc.Arguments.Count == 0)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "get_Chars":  						case "CompareTo":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetStringMethodSupport,The following statement contains a magic number: if(mc.Method.DeclaringType == typeof(string))  			{  				if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "Concat")  					{  						return MethodSupport.Method;  					}  				}  				else  				{  					switch(mc.Method.Name)  					{  						case "Contains":  						case "StartsWith":  						case "EndsWith":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "IndexOf":  						case "LastIndexOf":  							if(mc.Arguments.Count == 1  								|| mc.Arguments.Count == 2  								|| mc.Arguments.Count == 3)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Insert":  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "PadLeft":  						case "PadRight":  						case "Remove":  						case "Substring":  							if(mc.Arguments.Count == 1  							   || mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Replace":  							return MethodSupport.Method;  						case "Trim":  						case "ToLower":  						case "ToUpper":  							if(mc.Arguments.Count == 0)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "get_Chars":  						case "CompareTo":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetStringMethodSupport,The following statement contains a magic number: if(mc.Method.DeclaringType == typeof(string))  			{  				if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "Concat")  					{  						return MethodSupport.Method;  					}  				}  				else  				{  					switch(mc.Method.Name)  					{  						case "Contains":  						case "StartsWith":  						case "EndsWith":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "IndexOf":  						case "LastIndexOf":  							if(mc.Arguments.Count == 1  								|| mc.Arguments.Count == 2  								|| mc.Arguments.Count == 3)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Insert":  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "PadLeft":  						case "PadRight":  						case "Remove":  						case "Substring":  							if(mc.Arguments.Count == 1  							   || mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Replace":  							return MethodSupport.Method;  						case "Trim":  						case "ToLower":  						case "ToUpper":  							if(mc.Arguments.Count == 0)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "get_Chars":  						case "CompareTo":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  					}  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMathMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math))  			{  				switch(mc.Method.Name)  				{  					case "Abs":  					case "Acos":  					case "Asin":  					case "Atan":  					case "Ceiling":  					case "Cos":  					case "Cosh":  					case "Exp":  					case "Floor":  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Log":  						if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						};  						return MethodSupport.MethodGroup;  					case "Max":  					case "Min":  					case "Pow":  					case "Atan2":  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Round":  						if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)  							&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Sign":  					case "Sin":  					case "Sinh":  					case "Sqrt":  					case "Tan":  					case "Tanh":  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMathMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math))  			{  				switch(mc.Method.Name)  				{  					case "Abs":  					case "Acos":  					case "Asin":  					case "Atan":  					case "Ceiling":  					case "Cos":  					case "Cosh":  					case "Exp":  					case "Floor":  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Log":  						if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						};  						return MethodSupport.MethodGroup;  					case "Max":  					case "Min":  					case "Pow":  					case "Atan2":  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Round":  						if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)  							&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Sign":  					case "Sin":  					case "Sinh":  					case "Sqrt":  					case "Tan":  					case "Tanh":  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMathMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math))  			{  				switch(mc.Method.Name)  				{  					case "Abs":  					case "Acos":  					case "Asin":  					case "Atan":  					case "Ceiling":  					case "Cos":  					case "Cosh":  					case "Exp":  					case "Floor":  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Log":  						if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						};  						return MethodSupport.MethodGroup;  					case "Max":  					case "Min":  					case "Pow":  					case "Atan2":  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Round":  						if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)  							&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Sign":  					case "Sin":  					case "Sinh":  					case "Sqrt":  					case "Tan":  					case "Tanh":  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMathMethodSupport,The following statement contains a magic number: if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math))  			{  				switch(mc.Method.Name)  				{  					case "Abs":  					case "Acos":  					case "Asin":  					case "Atan":  					case "Ceiling":  					case "Cos":  					case "Cosh":  					case "Exp":  					case "Floor":  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Log":  						if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						};  						return MethodSupport.MethodGroup;  					case "Max":  					case "Min":  					case "Pow":  					case "Atan2":  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Round":  						if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)  							&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Sign":  					case "Sin":  					case "Sinh":  					case "Sqrt":  					case "Tan":  					case "Tanh":  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  				}  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffMonth,The following statement contains a magic number: return 12 * (endDate.Year - startDate.Year) + endDate.Month - startDate.Month;
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffHour,The following statement contains a magic number: checked  			{  				return DateDiffDay(startDate' endDate) * 24 + endDate.Hour - startDate.Hour;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffMinute,The following statement contains a magic number: checked  			{  				return DateDiffHour(startDate' endDate) * 60 + endDate.Minute - startDate.Minute;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffSecond,The following statement contains a magic number: checked  			{  				return DateDiffMinute(startDate' endDate) * 60 + endDate.Second - startDate.Second;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffMillisecond,The following statement contains a magic number: checked  			{  				return DateDiffSecond(startDate' endDate) * 1000 + endDate.Millisecond - startDate.Millisecond;  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffMicrosecond,The following statement contains a magic number: checked  			{  				return (int)((endDate.Ticks - startDate.Ticks) / 10);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlMethods,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlMethods.cs,DateDiffNanosecond,The following statement contains a magic number: checked  			{  				return (int)((endDate.Ticks - startDate.Ticks) * 100);  			}
Magic Number,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,Initialize,The following statement contains a magic number: if(con.ConnectionString.IndexOf("MultipleActiveResultSets"' StringComparison.OrdinalIgnoreCase) >= 0)  			{  				DbConnectionStringBuilder builder = new DbConnectionStringBuilder();  				builder.ConnectionString = con.ConnectionString;  				if(string.Compare((string)builder["MultipleActiveResultSets"]' "true"' StringComparison.OrdinalIgnoreCase) == 0)  				{  					maxUsersPerConnection = 10;  				}  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,Generate,The following statement contains a magic number: try  			{  				stackDepth++;  				Diagnostics.Debug.Assert(stackDepth < 500);  #endif  				switch(node.NodeType)  				{  					case SqlNodeType.New:  						return this.GenerateNew((SqlNew)node);  					case SqlNodeType.ColumnRef:  						return this.GenerateColumnReference((SqlColumnRef)node);  					case SqlNodeType.ClientQuery:  						return this.GenerateClientQuery((SqlClientQuery)node' locInstance);  					case SqlNodeType.JoinedCollection:  						return this.GenerateJoinedCollection((SqlJoinedCollection)node);  					case SqlNodeType.Link:  						return this.GenerateLink((SqlLink)node' locInstance);  					case SqlNodeType.Value:  						return this.GenerateValue((SqlValue)node);  					case SqlNodeType.ClientParameter:  						return this.GenerateClientParameter((SqlClientParameter)node);  					case SqlNodeType.ValueOf:  						return this.GenerateValueOf((SqlUnary)node);  					case SqlNodeType.OptionalValue:  						return this.GenerateOptionalValue((SqlOptionalValue)node);  					case SqlNodeType.OuterJoinedValue:  						return this.Generate(((SqlUnary)node).Operand);  					case SqlNodeType.Lift:  						return this.GenerateLift((SqlLift)node);  					case SqlNodeType.Grouping:  						return this.GenerateGrouping((SqlGrouping)node);  					case SqlNodeType.ClientArray:  						return this.GenerateClientArray((SqlClientArray)node);  					case SqlNodeType.UserColumn:  						return this.GenerateUserColumn((SqlUserColumn)node);  					case SqlNodeType.ClientCase:  						return this.GenerateClientCase((SqlClientCase)node' false' locInstance);  					case SqlNodeType.SearchedCase:  						return this.GenerateSearchedCase((SqlSearchedCase)node);  					case SqlNodeType.TypeCase:  						return this.GenerateTypeCase((SqlTypeCase)node);  					case SqlNodeType.DiscriminatedType:  						return this.GenerateDiscriminatedType((SqlDiscriminatedType)node);  					case SqlNodeType.Member:  						return this.GenerateMember((SqlMember)node);  					case SqlNodeType.MethodCall:  						return this.GenerateMethodCall((SqlMethodCall)node);  					default:  						throw Error.CouldNotTranslateExpressionForReading(node.SourceExpression);  				}  #if DEBUG  			}  			finally  			{  				stackDepth--;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateConstInt,The following statement contains a magic number: switch(value)  			{  				case 0:  					gen.Emit(OpCodes.Ldc_I4_0);  					break;  				case 1:  					gen.Emit(OpCodes.Ldc_I4_1);  					break;  				case 2:  					gen.Emit(OpCodes.Ldc_I4_2);  					break;  				case 3:  					gen.Emit(OpCodes.Ldc_I4_3);  					break;  				case 4:  					gen.Emit(OpCodes.Ldc_I4_4);  					break;  				case 5:  					gen.Emit(OpCodes.Ldc_I4_5);  					break;  				case 6:  					gen.Emit(OpCodes.Ldc_I4_6);  					break;  				case 7:  					gen.Emit(OpCodes.Ldc_I4_7);  					break;  				case 8:  					gen.Emit(OpCodes.Ldc_I4_8);  					break;  				default:  					if(value == -1)  					{  						gen.Emit(OpCodes.Ldc_I4_M1);  					}  					else if(value >= -127 && value < 128)  					{  						gen.Emit(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						gen.Emit(OpCodes.Ldc_I4' value);  					}  					break;  			}
Magic Number,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Concat,The following statement contains a magic number: for(int i = expressions.Length - 2; i >= 0; i--)  			{  				result = Binary(SqlNodeType.Concat' expressions[i]' result);  			}
Magic Number,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Add,The following statement contains a magic number: for(int i = expressions.Length - 2; i >= 0; i--)  			{  				sum = Binary(SqlNodeType.Add' expressions[i]' sum);  			}
Magic Number,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,Multiply,The following statement contains a magic number: for(int i = expressions.Length - 2; i >= 0; i--)  			{  				result = Binary(SqlNodeType.Mul' expressions[i]' result);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,ConvertDateToDateTime2,The following statement contains a magic number: return _nodeFactory.FunctionCall(typeof(DateTime)' "CONVERT"' new SqlExpression[2] { datetime2' expr }' expr.SourceExpression);
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitTake,The following statement contains a magic number: if(mce != null && IsSequenceOperatorCall(mce) && mce.Method.Name == "Skip" && mce.Arguments.Count == 2)  			{  				SqlExpression skipExp = this.VisitExpression(mce.Arguments[1]);    				// verify that count >= 0  				if(skipExp.NodeType == SqlNodeType.Value)  				{  					SqlValue constSkipCount = (SqlValue)skipExp;  					if(typeof(int).IsAssignableFrom(constSkipCount.Value.GetType()) && ((int)constSkipCount.Value) < 0)  					{  						throw Error.ArgumentOutOfRange("skipCount");  					}  				}    				SqlSelect select = this.VisitSequence(mce.Arguments[0]);  				return this.GenerateSkipTake(select' skipExp' takeExp);  			}  			else  			{  				SqlSelect select = this.VisitSequence(sequence);  				return this.GenerateSkipTake(select' null' takeExp);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitMethodCall,The following statement contains a magic number: if(mc.Method.IsStatic)  			{  				if(this.IsSequenceOperatorCall(mc))  				{  					return this.VisitSequenceOperatorCall(mc);  				}  				else if(IsDataManipulationCall(mc))  				{  					return this.VisitDataManipulationCall(mc);  				}  				// why is this handled here and not in SqlMethodCallConverter?  				else if(declType == typeof(DBConvert) || declType == typeof(Convert))  				{  					if(mc.Method.Name == "ChangeType")  					{  						SqlNode sn = null;  						if(mc.Arguments.Count == 2)  						{  							object value = GetValue(mc.Arguments[1]' "ChangeType");  							if(value != null && typeof(Type).IsAssignableFrom(value.GetType()))  							{  								sn = this.VisitChangeType(mc.Arguments[0]' (Type)value);  							}  						}  						if(sn == null)  						{  							throw Error.MethodFormHasNoSupportConversionToSql(mc.Method.Name' mc.Method);  						}  						return sn;  					}  				}  			}  			else if(typeof(DataContext).IsAssignableFrom(mc.Method.DeclaringType))  			{  				switch(mc.Method.Name)  				{  					case "GetTable":  						{  							// calls to GetTable<T> can be translated directly as table references  							if(mc.Method.IsGenericMethod)  							{  								Type[] typeArgs = mc.Method.GetGenericArguments();  								if(typeArgs.Length == 1 && mc.Method.GetParameters().Length == 0)  								{  									CheckContext(this.VisitExpression(mc.Object));  									ITable table = _services.Context.GetTable(typeArgs[0]);  									if(table != null)  									{  										return this.Visit(Expression.Constant(table));  									}  								}  							}  							break;  						}  					case "ExecuteCommand":  					case "ExecuteQuery":  						return this.VisitUserQuery((string)GetValue(mc.Arguments[0]' mc.Method.Name)' GetArray(mc.Arguments[1])' mc.Type);  				}    				if(this.IsMappedFunctionCall(mc))  				{  					return this.VisitMappedFunctionCall(mc);  				}  			}  			else if(  				mc.Method.DeclaringType != typeof(string)  				&& mc.Method.Name == "Contains"  				&& !mc.Method.IsStatic  				&& typeof(IList).IsAssignableFrom(mc.Method.DeclaringType)  				&& mc.Type == typeof(bool)  				&& mc.Arguments.Count == 1  				&& TypeSystem.GetElementType(mc.Method.DeclaringType).IsAssignableFrom(mc.Arguments[0].Type)  				)  			{  				return this.VisitContains(mc.Object' mc.Arguments[0]);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following statement contains a magic number: if(IsSequenceOperatorCall(mc))  			{  				switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}  				// If the operator is supported' but the particular overload is not'  				// give an appropriate error message  				if(isSupportedSequenceOperator)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}  			else  			{  				throw Error.InvalidSequenceOperatorCall(declType);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following statement contains a magic number: if(IsDataManipulationCall(mc))  			{  				bool isSupportedDML = false;  				switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}  				if(isSupportedDML)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following statement contains a magic number: if(IsDataManipulationCall(mc))  			{  				bool isSupportedDML = false;  				switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}  				if(isSupportedDML)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following statement contains a magic number: if(IsDataManipulationCall(mc))  			{  				bool isSupportedDML = false;  				switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}  				if(isSupportedDML)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following statement contains a magic number: if(IsDataManipulationCall(mc))  			{  				bool isSupportedDML = false;  				switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}  				if(isSupportedDML)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}
Magic Number,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following statement contains a magic number: if(IsDataManipulationCall(mc))  			{  				bool isSupportedDML = false;  				switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}  				if(isSupportedDML)  				{  					throw Error.QueryOperatorOverloadNotSupported(mc.Method.Name);  				}  				throw Error.QueryOperatorNotSupported(mc.Method.Name);  			}
Magic Number,System.Data.Linq.Provider.Common,RetypeCheckClause,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitMethodCall,The following statement contains a magic number: if(mc.Arguments.Count == 2 && mc.Method.Name == "op_Equality")  				{  					var r = mc.Arguments[1];  					if(r.NodeType == SqlNodeType.Value)  					{  						var v = (SqlValue)r;  						v.SetSqlType(mc.Arguments[0].SqlType);  					}  				}
Magic Number,System.Data.Linq.Provider.Common,SqlIdentifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlIdentifier.cs,IsQuoted,The following statement contains a magic number: if(s.Length < 2)  			{  				return false;  			}
Magic Number,System.Data.Linq.Provider.Visitors,ExpressionDuplicator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ExpressionDuplicator.cs,ExpandUnion,The following statement contains a magic number: List<SqlExpression> exprs = new List<SqlExpression>(2);
Magic Number,System.Data.Linq.Provider.Visitors,SqlMethodTransformer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlMethodTransformer.cs,VisitFunctionCall,The following statement contains a magic number: if(result is SqlFunctionCall)  			{  				SqlFunctionCall resultFunctionCall = (SqlFunctionCall)result;    				if(resultFunctionCall.Name == sql.LengthFunctionName)  				{  					SqlExpression expr = resultFunctionCall.Arguments[0];    					if(expr.SqlType.IsLargeType && !expr.SqlType.SupportsLength)  					{  						result = sql.FunctionCallDataLength(expr);    						if(expr.SqlType.IsUnicodeType)  						{  							result = sql.ConvertToInt(sql.Divide(result' sql.ValueFromObject(2' expr.SourceExpression)));  						}  					}  				}    				// If the return type of the sql function is not compatible with  				// the expected CLR type of the function' inject a conversion. This  				// step must be performed AFTER SqlRetyper has run.  				Type clrType = resultFunctionCall.SqlType.GetClosestRuntimeType();  				bool skipConversion = SkipConversionForDateAdd(resultFunctionCall.Name'  																					resultFunctionCall.ClrType'  																					clrType);  				if((resultFunctionCall.ClrType != clrType) && !skipConversion)  				{  					result = sql.ConvertTo(resultFunctionCall.ClrType' resultFunctionCall);  				}  			}
Magic Number,System.Data.Linq.Provider.Visitors,SqlMethodTransformer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlMethodTransformer.cs,VisitUnaryOperator,The following statement contains a magic number: if(result is SqlUnary)  			{  				SqlUnary unary = (SqlUnary)result;    				switch(unary.NodeType)  				{  					case SqlNodeType.ClrLength:  						SqlExpression expr = unary.Operand;    						result = sql.FunctionCallDataLength(expr);    						if(expr.SqlType.IsUnicodeType)  						{  							result = sql.Divide(result' sql.ValueFromObject(2' expr.SourceExpression));  						}    						result = sql.ConvertToInt(result);  						break;  					default:  						break;  				}  			}
Magic Number,System.Data.Linq.Provider.Visitors,SqlVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlVisitor.cs,Visit,The following statement contains a magic number: try {                  nDepth++;                  CheckRecursionDepth(500' nDepth);                    switch (node.NodeType) {                      case SqlNodeType.Not:                      case SqlNodeType.Not2V:                      case SqlNodeType.Negate:                      case SqlNodeType.BitNot:                      case SqlNodeType.IsNull:                      case SqlNodeType.IsNotNull:                      case SqlNodeType.Count:                      case SqlNodeType.LongCount:                      case SqlNodeType.Max:                      case SqlNodeType.Min:                      case SqlNodeType.Sum:                      case SqlNodeType.Avg:                      case SqlNodeType.Stddev:                      case SqlNodeType.Convert:                      case SqlNodeType.ValueOf:                      case SqlNodeType.OuterJoinedValue:                      case SqlNodeType.ClrLength:                          result = this.VisitUnaryOperator((SqlUnary)node);                          break;                      case SqlNodeType.Lift:                          result = this.VisitLift((SqlLift)node);                          break;                      case SqlNodeType.Add:                      case SqlNodeType.Sub:                      case SqlNodeType.Mul:                      case SqlNodeType.Div:                      case SqlNodeType.Mod:                      case SqlNodeType.BitAnd:                      case SqlNodeType.BitOr:                      case SqlNodeType.BitXor:                      case SqlNodeType.And:                      case SqlNodeType.Or:                      case SqlNodeType.GE:                      case SqlNodeType.GT:                      case SqlNodeType.LE:                      case SqlNodeType.LT:                      case SqlNodeType.EQ:                      case SqlNodeType.NE:                      case SqlNodeType.EQ2V:                      case SqlNodeType.NE2V:                      case SqlNodeType.Concat:                      case SqlNodeType.Coalesce:                          result = this.VisitBinaryOperator((SqlBinary)node);                          break;                      case SqlNodeType.Between:                          result = this.VisitBetween((SqlBetween)node);                          break;                      case SqlNodeType.In:                          result = this.VisitIn((SqlIn)node);                          break;                      case SqlNodeType.Like:                          result = this.VisitLike((SqlLike)node);                          break;                      case SqlNodeType.Treat:                          result = this.VisitTreat((SqlUnary)node);                          break;                      case SqlNodeType.Alias:                          result = this.VisitAlias((SqlAlias)node);                          break;                      case SqlNodeType.AliasRef:                          result = this.VisitAliasRef((SqlAliasRef)node);                          break;                      case SqlNodeType.Member:                          result = this.VisitMember((SqlMember)node);                          break;                      case SqlNodeType.Row:                          result = this.VisitRow((SqlRow)node);                          break;                      case SqlNodeType.Column:                          result = this.VisitColumn((SqlColumn)node);                          break;                      case SqlNodeType.ColumnRef:                          result = this.VisitColumnRef((SqlColumnRef)node);                          break;                      case SqlNodeType.Table:                          result = this.VisitTable((SqlTable)node);                          break;                      case SqlNodeType.UserQuery:                          result = this.VisitUserQuery((SqlUserQuery)node);                          break;                      case SqlNodeType.StoredProcedureCall:                          result = this.VisitStoredProcedureCall((SqlStoredProcedureCall)node);                          break;                      case SqlNodeType.UserRow:                          result = this.VisitUserRow((SqlUserRow)node);                          break;                      case SqlNodeType.UserColumn:                          result = this.VisitUserColumn((SqlUserColumn)node);                          break;                      case SqlNodeType.Multiset:                      case SqlNodeType.ScalarSubSelect:                      case SqlNodeType.Element:                      case SqlNodeType.Exists:                          result = this.VisitSubSelect((SqlSubSelect)node);                          break;                      case SqlNodeType.Join:                          result = this.VisitJoin((SqlJoin)node);                          break;                      case SqlNodeType.Select:                          result = this.VisitSelect((SqlSelect)node);                          break;                      case SqlNodeType.Parameter:                          result = this.VisitParameter((SqlParameter)node);                          break;                      case SqlNodeType.New:                          result = this.VisitNew((SqlNew)node);                          break;                      case SqlNodeType.Link:                          result = this.VisitLink((SqlLink)node);                          break;                      case SqlNodeType.ClientQuery:                          result = this.VisitClientQuery((SqlClientQuery)node);                          break;                      case SqlNodeType.JoinedCollection:                          result = this.VisitJoinedCollection((SqlJoinedCollection)node);                          break;                      case SqlNodeType.Value:                          result = this.VisitValue((SqlValue)node);                          break;                      case SqlNodeType.ClientArray:                          result = this.VisitClientArray((SqlClientArray)node);                          break;                      case SqlNodeType.Insert:                          result = this.VisitInsert((SqlInsert)node);                          break;                      case SqlNodeType.Update:                          result = this.VisitUpdate((SqlUpdate)node);                          break;                      case SqlNodeType.Delete:                          result = this.VisitDelete((SqlDelete)node);                          break;                      case SqlNodeType.MemberAssign:                          result = this.VisitMemberAssign((SqlMemberAssign)node);                          break;                      case SqlNodeType.Assign:                          result = this.VisitAssign((SqlAssign)node);                          break;                      case SqlNodeType.Block:                          result = this.VisitBlock((SqlBlock)node);                          break;                      case SqlNodeType.SearchedCase:                          result = this.VisitSearchedCase((SqlSearchedCase)node);                          break;                      case SqlNodeType.ClientCase:                          result = this.VisitClientCase((SqlClientCase)node);                          break;                      case SqlNodeType.SimpleCase:                          result = this.VisitSimpleCase((SqlSimpleCase)node);                          break;                      case SqlNodeType.TypeCase:                          result = this.VisitTypeCase((SqlTypeCase)node);                          break;                      case SqlNodeType.Union:                          result = this.VisitUnion((SqlUnion)node);                          break;                      case SqlNodeType.ExprSet:                          result = this.VisitExprSet((SqlExprSet)node);                          break;                      case SqlNodeType.Variable:                          result = this.VisitVariable((SqlVariable)node);                          break;                      case SqlNodeType.DoNotVisit:                          result = this.VisitDoNotVisit((SqlDoNotVisitExpression)node);                          break;                      case SqlNodeType.OptionalValue:                          result = this.VisitOptionalValue((SqlOptionalValue)node);                          break;                      case SqlNodeType.FunctionCall:                          result = this.VisitFunctionCall((SqlFunctionCall)node);                          break;                      case SqlNodeType.TableValuedFunctionCall:                          result = this.VisitTableValuedFunctionCall((SqlTableValuedFunctionCall)node);                          break;                      case SqlNodeType.MethodCall:                          result = this.VisitMethodCall((SqlMethodCall)node);                          break;                      case SqlNodeType.Nop:                          result = this.VisitNop((SqlNop)node);                          break;                      case SqlNodeType.SharedExpression:                          result = this.VisitSharedExpression((SqlSharedExpression)node);                          break;                      case SqlNodeType.SharedExpressionRef:                          result = this.VisitSharedExpressionRef((SqlSharedExpressionRef)node);                          break;                      case SqlNodeType.SimpleExpression:                          result = this.VisitSimpleExpression((SqlSimpleExpression)node);                          break;                      case SqlNodeType.Grouping:                          result = this.VisitGrouping((SqlGrouping)node);                          break;                      case SqlNodeType.DiscriminatedType:                          result = this.VisitDiscriminatedType((SqlDiscriminatedType)node);                          break;                      case SqlNodeType.DiscriminatorOf:                          result = this.VisitDiscriminatorOf((SqlDiscriminatorOf)node);                          break;                      case SqlNodeType.ClientParameter:                          result = this.VisitClientParameter((SqlClientParameter)node);                          break;                      case SqlNodeType.RowNumber:                          result = this.VisitRowNumber((SqlRowNumber)node);                          break;                      case SqlNodeType.IncludeScope:                          result = this.VisitIncludeScope((SqlIncludeScope)node);                          break;                      default:                          throw Error.UnexpectedNode(node);                  }              } finally {                  this.nDepth--;              }
Magic Number,System.Data.Linq.Provider.Visitors,SqlVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlVisitor.cs,RefersToColumn,The following statement contains a magic number: try {                  refersDepth++;                  System.Diagnostics.Debug.Assert(refersDepth < 20);  #endif                  if (exp != null) {                      switch (exp.NodeType) {                          case SqlNodeType.Column:                              return exp == col || this.RefersToColumn(((SqlColumn)exp).Expression' col);                          case SqlNodeType.ColumnRef:                              SqlColumnRef cref = (SqlColumnRef)exp;                              return cref.Column == col || this.RefersToColumn(cref.Column.Expression' col);                          case SqlNodeType.ExprSet:                              SqlExprSet set = (SqlExprSet)exp;                              for (int i = 0' n = set.Expressions.Count; i < n; i++) {                                  if (this.RefersToColumn(set.Expressions[i]' col)) {                                      return true;                                  }                              }                              break;                          case SqlNodeType.OuterJoinedValue:                              return this.RefersToColumn(((SqlUnary)exp).Operand' col);                      }                  }                    return false;  #if DEBUG              }              finally {                  refersDepth--;              }
Magic Number,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitMethodCall,The following statement contains a magic number: if(mc.Method.IsStatic)  				{  					if(mc.Method.Name == "Equals" && mc.Arguments.Count == 2)  					{  						return sql.Binary(SqlNodeType.EQ2V' mc.Arguments[0]' mc.Arguments[1]' mc.Method);  					}  					if(mc.Method.DeclaringType == typeof(string) && mc.Method.Name == "Concat")  					{  						SqlClientArray arr = mc.Arguments[0] as SqlClientArray;  						List<SqlExpression> exprs = null;  						if(arr != null)  						{  							exprs = arr.Expressions;  						}  						else  						{  							exprs = mc.Arguments;  						}  						if(exprs.Count == 0)  						{  							return sql.ValueFromObject(""' false' mc.SourceExpression);  						}  						SqlExpression sum;  						if(exprs[0].SqlType.IsString || exprs[0].SqlType.IsChar)  						{  							sum = exprs[0];  						}  						else  						{  							sum = sql.ConvertTo(typeof(string)' exprs[0]);  						}  						for(int i = 1; i < exprs.Count; i++)  						{  							if(exprs[i].SqlType.IsString || exprs[i].SqlType.IsChar)  							{  								sum = sql.Concat(sum' exprs[i]);  							}  							else  							{  								sum = sql.Concat(sum' sql.ConvertTo(typeof(string)' exprs[i]));  							}  						}  						return sum;  					}  					if(IsVbIIF(mc))  					{  						return TranslateVbIIF(mc);  					}  					switch(mc.Method.Name)  					{  						case "op_Equality":  							return sql.Binary(SqlNodeType.EQ' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Inequality":  							return sql.Binary(SqlNodeType.NE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_LessThan":  							return sql.Binary(SqlNodeType.LT' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_LessThanOrEqual":  							return sql.Binary(SqlNodeType.LE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_GreaterThan":  							return sql.Binary(SqlNodeType.GT' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_GreaterThanOrEqual":  							return sql.Binary(SqlNodeType.GE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Multiply":  							return sql.Binary(SqlNodeType.Mul' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Division":  							return sql.Binary(SqlNodeType.Div' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Subtraction":  							return sql.Binary(SqlNodeType.Sub' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Addition":  							return sql.Binary(SqlNodeType.Add' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Modulus":  							return sql.Binary(SqlNodeType.Mod' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_BitwiseAnd":  							return sql.Binary(SqlNodeType.BitAnd' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_BitwiseOr":  							return sql.Binary(SqlNodeType.BitOr' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_ExclusiveOr":  							return sql.Binary(SqlNodeType.BitXor' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_UnaryNegation":  							return sql.Unary(SqlNodeType.Negate' mc.Arguments[0]' mc.Method' mc.SourceExpression);  						case "op_OnesComplement":  							return sql.Unary(SqlNodeType.BitNot' mc.Arguments[0]' mc.Method' mc.SourceExpression);  						case "op_False":  							return sql.Unary(SqlNodeType.Not' mc.Arguments[0]' mc.Method' mc.SourceExpression);  					}  				}  				else  				{  					if(mc.Method.Name == "Equals" && mc.Arguments.Count == 1)  					{  						return sql.Binary(SqlNodeType.EQ' mc.Object' mc.Arguments[0]);  					}  					if(mc.Method.Name == "GetType" && mc.Arguments.Count == 0)  					{  						MetaType mt = TypeSource.GetSourceMetaType(mc.Object' this.model);  						if(mt.HasInheritance)  						{  							Type discriminatorType = mt.Discriminator.Type;  							SqlDiscriminatorOf discriminatorOf = new SqlDiscriminatorOf(mc.Object' discriminatorType' this.sql.TypeProvider.From(discriminatorType)' mc.SourceExpression);  							return this.VisitExpression(sql.DiscriminatedType(discriminatorOf' mt));  						}  						return this.VisitExpression(sql.StaticType(mt' mc.SourceExpression));  					}  				}
Magic Number,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,TranslateVbIIF,The following statement contains a magic number: if(mc.Arguments[1].ClrType == mc.Arguments[2].ClrType)  				{  					List<SqlWhen> whens = new List<SqlWhen>(1);  					whens.Add(new SqlWhen(mc.Arguments[0]' mc.Arguments[1]));  					SqlExpression @else = mc.Arguments[2];  					while(@else.NodeType == SqlNodeType.SearchedCase)  					{  						SqlSearchedCase sc = (SqlSearchedCase)@else;  						whens.AddRange(sc.Whens);  						@else = sc.Else;  					}  					return sql.SearchedCase(whens.ToArray()' @else' mc.SourceExpression);  				}
Magic Number,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,TranslateVbIIF,The following statement contains a magic number: if(mc.Arguments[1].ClrType == mc.Arguments[2].ClrType)  				{  					List<SqlWhen> whens = new List<SqlWhen>(1);  					whens.Add(new SqlWhen(mc.Arguments[0]' mc.Arguments[1]));  					SqlExpression @else = mc.Arguments[2];  					while(@else.NodeType == SqlNodeType.SearchedCase)  					{  						SqlSearchedCase sc = (SqlSearchedCase)@else;  						whens.AddRange(sc.Whens);  						@else = sc.Else;  					}  					return sql.SearchedCase(whens.ToArray()' @else' mc.SourceExpression);  				}
Magic Number,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,TranslateVbIIF,The following statement contains a magic number: throw Error.IifReturnTypesMustBeEqual(mc.Arguments[1].ClrType.Name' mc.Arguments[2].ClrType.Name);
Magic Number,System.Data.Linq.Provider.Visitors,PreBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MethodCallConverter.cs,IsSupportedMethod,The following statement contains a magic number: if(mc.Method.IsStatic)  			{  				switch(mc.Method.Name)  				{  					case "op_Equality":  					case "op_Inequality":  					case "op_LessThan":  					case "op_LessThanOrEqual":  					case "op_GreaterThan":  					case "op_GreaterThanOrEqual":  					case "op_Multiply":  					case "op_Division":  					case "op_Subtraction":  					case "op_Addition":  					case "op_Modulus":  					case "op_BitwiseAnd":  					case "op_BitwiseOr":  					case "op_ExclusiveOr":  					case "op_UnaryNegation":  					case "op_OnesComplement":  					case "op_False":  						return true;  					case "Equals":  						return mc.Arguments.Count == 2;  					case "Concat":  						return mc.Method.DeclaringType == typeof(string);  				}  			}  			else  			{  				return mc.Method.Name == "Equals" && mc.Arguments.Count == 1 ||  					   mc.Method.Name == "GetType" && mc.Arguments.Count == 0;  			}
Missing Default,System.Data.Linq,SubqueryRules,C:\repos\FransBouma_LinqToSQL2\src\Querying\SubqueryRules.cs,IsSupportedTopLevelMethod,The following switch statement is missing a default case: switch (mi.Name) {                  case "Where":                  case "OrderBy":                  case "OrderByDescending":                  case "ThenBy":                  case "ThenByDescending":                  case "Take":                      return true;              }
Missing Default,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,VisitJoin,The following switch statement is missing a default case: switch(@join.JoinType)  			{  				case SqlJoinType.CrossApply:  					_commandStringBuilder.Append("CROSS APPLY ");  					break;  				case SqlJoinType.Cross:  					_commandStringBuilder.Append("CROSS JOIN ");  					break;  				case SqlJoinType.Inner:  					_commandStringBuilder.Append("INNER JOIN ");  					break;  				case SqlJoinType.LeftOuter:  					_commandStringBuilder.Append("LEFT OUTER JOIN ");  					break;  				case SqlJoinType.OuterApply:  					_commandStringBuilder.Append("OUTER APPLY ");  					break;  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,CommandTextProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\CommandTextProducer.cs,FormatValue,The following switch statement is missing a default case: switch(tc)  				{  					case TypeCode.Char:  					case TypeCode.String:  					case TypeCode.DateTime:  						_commandStringBuilder.Append("'");  						_commandStringBuilder.Append(this.EscapeSingleQuotes(value.ToString()));  						_commandStringBuilder.Append("'");  						return;  					case TypeCode.Boolean:  						_commandStringBuilder.Append(this.GetBoolValue((bool)value));  						return;  					case TypeCode.Byte:  					case TypeCode.Decimal:  					case TypeCode.Double:  					case TypeCode.Int16:  					case TypeCode.Int32:  					case TypeCode.Int64:  					case TypeCode.SByte:  					case TypeCode.Single:  					case TypeCode.UInt16:  					case TypeCode.UInt32:  					case TypeCode.UInt64:  						_commandStringBuilder.Append(value);  						return;  					case TypeCode.Object:  					{  						if(value is Guid)  						{  							_commandStringBuilder.Append("'");  							_commandStringBuilder.Append(value);  							_commandStringBuilder.Append("'");  							return;  						}  						Type valueType = value as Type;  						if(valueType != null)  						{  							if(_isDebugMode)  							{  								_commandStringBuilder.Append("typeof(");  								_commandStringBuilder.Append(valueType.Name);  								_commandStringBuilder.Append(")");  							}  							else  							{  								this.FormatValue("");  							}  							return;  						}  						break;  					}  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Sql2000Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2000Provider.cs,GetBestLargeType,The following switch statement is missing a default case: switch(sqlType.SqlDbType)  			{  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  					return SqlTypeSystem.Create(SqlDbType.NText);  				case SqlDbType.Char:  				case SqlDbType.VarChar:  					return SqlTypeSystem.Create(SqlDbType.Text);  				case SqlDbType.Binary:  				case SqlDbType.VarBinary:  					return SqlTypeSystem.Create(SqlDbType.Image);  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Sql2005Provider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\Sql2005Provider.cs,GetBestLargeType,The following switch statement is missing a default case: switch(sqlType.SqlDbType)  			{  				case SqlDbType.NText:  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  					return SqlTypeSystem.Create(SqlDbType.NVarChar' ProviderConstants.LargeTypeSizeIndicator);  				case SqlDbType.Text:  				case SqlDbType.Char:  				case SqlDbType.VarChar:  					return SqlTypeSystem.Create(SqlDbType.VarChar' ProviderConstants.LargeTypeSizeIndicator);  				case SqlDbType.Image:  				case SqlDbType.Binary:  				case SqlDbType.VarBinary:  					return SqlTypeSystem.Create(SqlDbType.VarBinary' ProviderConstants.LargeTypeSizeIndicator);  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,GetDbType,The following switch statement is missing a default case: switch(Type.GetTypeCode(type))  					{  						case TypeCode.Byte:  							sb.Append("TinyInt");  							break;  						case TypeCode.SByte:  						case TypeCode.Int16:  							sb.Append("SmallInt");  							break;  						case TypeCode.Int32:  						case TypeCode.UInt16:  							sb.Append("Int");  							break;  						case TypeCode.Int64:  						case TypeCode.UInt32:  							sb.Append("BigInt");  							break;  						case TypeCode.UInt64:  						case TypeCode.Decimal:  							sb.Append("Decimal(20)");  							break;  						case TypeCode.Object:  							if(type == typeof(Guid))  							{  								sb.Append("UniqueIdentifier");  							}  							else  							{  								throw Error.CouldNotDetermineDbGeneratedSqlType(type);  							}  							break;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlBuilder,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlBuilder.cs,GetDbType,The following switch statement is missing a default case: switch(Type.GetTypeCode(type))  					{  						case TypeCode.Boolean:  							sb.Append("Bit");  							break;  						case TypeCode.Byte:  							sb.Append("TinyInt");  							break;  						case TypeCode.SByte:  						case TypeCode.Int16:  							sb.Append("SmallInt");  							break;  						case TypeCode.Int32:  						case TypeCode.UInt16:  							sb.Append("Int");  							break;  						case TypeCode.Int64:  						case TypeCode.UInt32:  							sb.Append("BigInt");  							break;  						case TypeCode.UInt64:  							sb.Append("Decimal(20)");  							break;  						case TypeCode.Decimal:  							sb.Append("Decimal(29' 4)");  							break;  						case TypeCode.Double:  							sb.Append("Float");  							break;  						case TypeCode.Single:  							sb.Append("Real");  							break;  						case TypeCode.Char:  							sb.Append("NChar(1)");  							break;  						case TypeCode.String:  							sb.Append("NVarChar(4000)");  							break;  						case TypeCode.DateTime:  							sb.Append("DateTime");  							break;  						case TypeCode.Object:  							if(type == typeof(Guid))  							{  								sb.Append("UniqueIdentifier");  							}  							else if(type == typeof(byte[]))  							{  								sb.Append("VarBinary(8000)");  							}  							else if(type == typeof(char[]))  							{  								sb.Append("NVarChar(4000)");  							}  							else if(type == typeof(DateTimeOffset))  							{  								sb.Append("DateTimeOffset");  							}  							else if(type == typeof(TimeSpan))  							{  								sb.Append("Time");  							}  							else  							{  								throw Error.CouldNotDetermineSqlType(type);  							}  							break;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlParameterInfoProducer,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlParameterInfoProducer.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch(bo.NodeType)  			{  				case SqlNodeType.EQ:  				case SqlNodeType.EQ2V:  				case SqlNodeType.NE:  				case SqlNodeType.NE2V:  				{  					SqlDbType leftSqlDbType = ((SqlType)(bo.Left.SqlType)).SqlDbType;  					SqlDbType rightSqlDbType = ((SqlType)(bo.Right.SqlType)).SqlDbType;  					if(leftSqlDbType == rightSqlDbType)  						break;    					bool isLeftColRef = bo.Left is SqlColumnRef;  					bool isRightColRef = bo.Right is SqlColumnRef;  					if(isLeftColRef == isRightColRef)  						break;    					if(isLeftColRef && leftSqlDbType == SqlDbType.Time && bo.Right.ClrType == typeof(DateTime))  						this.timeProviderType = bo.Left.SqlType;  					else if(isRightColRef && rightSqlDbType == SqlDbType.Time && bo.Left.ClrType == typeof(DateTime))  						this.timeProviderType = bo.Left.SqlType;  					break;  				}  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlServerProviderBase,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlServerProviderBase.cs,GetBestType,The following switch statement is missing a default case: switch(targetType)  			{  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  					maxSize = 4000;  					break;  				case SqlDbType.Char:  				case SqlDbType.VarChar:  				case SqlDbType.Binary:  				case SqlDbType.VarBinary:  					maxSize = 8000;  					break;  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDateTimeBinary,The following switch statement is missing a default case: switch(bo.NodeType)  				{  					case SqlNodeType.Sub:  						if(rightType == typeof(DateTime))  						{  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);    							// DATEDIFF(MILLISECONDS'...) does not work for more then 24 days' since result has to fit int.   							// So compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(  														  typeof(DateTime)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"'  														new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression result = sql.Multiply(sql.Add(sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)' intMSec)' 10000); // 1 millisecond = 10000 ticks  							return sql.ConvertTo(resultType' result);  						}  						if(rightType == typeof(DateTimeOffset))  						{  							Debug.Assert(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset));  							// if either of the arguments is nullable' set result type to nullable.  							Type resultType = bo.ClrType;  							SqlExpression end = bo.Left;  							SqlExpression start = bo.Right;  							SqlExpression day = new SqlVariable(typeof(void)' null' "DAY"' bo.SourceExpression);  							SqlExpression ms = new SqlVariable(typeof(void)' null' "MILLISECOND"' bo.SourceExpression);  							SqlExpression us = new SqlVariable(typeof(void)' null' "MICROSECOND"' bo.SourceExpression);  							SqlExpression ns = new SqlVariable(typeof(void)' null' "NANOSECOND"' bo.SourceExpression);    							// compute the number of days first' and then find out the number of milliseconds needed in addition to that.  							SqlExpression intDays = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { day' start' end }' bo.SourceExpression);  							SqlExpression startPlusDays = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { day' intDays' start }' bo.SourceExpression);  							SqlExpression intMSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ms' startPlusDays' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ms' intMSec' startPlusDays }' bo.SourceExpression);  							SqlExpression intUSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { us' startPlusDaysPlusMsec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { us' intUSec' startPlusDaysPlusMsec }' bo.SourceExpression);  							SqlExpression intNSec = sql.FunctionCall(typeof(int)' "DATEDIFF"' new SqlExpression[] { ns' startPlusDaysPlusMsecPlusUSec' end }' bo.SourceExpression);  							SqlExpression startPlusDaysPlusMsecPlusUSecPlusNSec = sql.FunctionCall(typeof(DateTimeOffset)' "DATEADD"' new SqlExpression[] { ns' intNSec' startPlusDaysPlusMsecPlusUSec }' bo.SourceExpression);    							SqlExpression result = sql.Add(  														sql.Divide(intNSec' 100)'  														sql.Multiply(intUSec' 10)'  														sql.Multiply(  															sql.Add(  																sql.Multiply(sql.ConvertToBigint(intDays)' 86400000)'  																intMSec  															)'  															10000)  												   );    							return sql.ConvertTo(resultType' result);  						}  						else if(rightType == typeof(TimeSpan))  						{  							SqlExpression right = bo.Right;  							if(sql.IsTimeType(bo.Right))  							{  								SqlExpression ns = sql.FunctionCallDatePart("NANOSECOND"' right);  								SqlExpression ss = sql.FunctionCallDatePart("SECOND"' right);  								SqlExpression mi = sql.FunctionCallDatePart("MINUTE"' right);  								SqlExpression hh = sql.FunctionCallDatePart("HOUR"' right);    								right = sql.Add(  											sql.Divide(ns' 100)'  											sql.Multiply(  														sql.Add(  															sql.Multiply(sql.ConvertToBigint(hh)' 3600000)'  															sql.Multiply(sql.ConvertToBigint(mi)' 60000)'  															sql.Multiply(sql.ConvertToBigint(ss)' 1000)  														  )'  														10000   // 1 millisecond = 10000 ticks  													)  											);  							}    							return TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset) ?  												CreateDateTimeOffsetFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												) :  												CreateDateTimeFromDateAndTicks(  													bo.Left'  													sql.Unary(SqlNodeType.Negate' right' bo.SourceExpression)'  													bo.SourceExpression' resultNullable  												);  						}  						break;  					case SqlNodeType.Add:  						if(rightType == typeof(TimeSpan))  						{  							if(sql.IsTimeType(bo.Right))  							{  								return sql.AddTimeSpan(bo.Left' bo.Right' resultNullable);  							}  							else if(TypeSystem.GetNonNullableType(bo.Left.ClrType) == typeof(DateTimeOffset))  							{  								return CreateDateTimeOffsetFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  							}    							return CreateDateTimeFromDateAndTicks(bo.Left' bo.Right' bo.SourceExpression' resultNullable);  						}  						break;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateDecimalMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  						{  							case "Multiply":  								return sql.Binary(SqlNodeType.Mul' mc.Arguments[0]' mc.Arguments[1]);  							case "Divide":  								return sql.Binary(SqlNodeType.Div' mc.Arguments[0]' mc.Arguments[1]);  							case "Subtract":  								return sql.Binary(SqlNodeType.Sub' mc.Arguments[0]' mc.Arguments[1]);  							case "Add":  								return sql.Binary(SqlNodeType.Add' mc.Arguments[0]' mc.Arguments[1]);  							case "Remainder":  								return sql.Binary(SqlNodeType.Mod' mc.Arguments[0]' mc.Arguments[1]);  							case "Round":  								// ROUND (x' y)  								return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' mc.Arguments' mc.SourceExpression);  						}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateStringMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Contains":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringContainsPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringContainsPatternForced = SqlHelpers.GetStringContainsPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringContainsPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.Contains");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "StartsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringStartsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringStartsWithPatternForced = SqlHelpers.GetStringStartsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringStartsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  											 cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.StartsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "EndsWith":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression pattern = mc.Arguments[0];  							SqlExpression escape = null;  							bool needsEscape = true;    							if(pattern.NodeType == SqlNodeType.Value)  							{  								string unescapedText = (string)((SqlValue)pattern).Value;  								string patternText = SqlHelpers.GetStringEndsWithPattern(unescapedText' '~'' out needsEscape);  								pattern = sql.ValueFromObject(patternText' true' pattern.SourceExpression);  							}  							else if(pattern.NodeType == SqlNodeType.ClientParameter)  							{  								SqlClientParameter cp = (SqlClientParameter)pattern;  								Func<string' char' string> getStringEndsWithPatternForced = SqlHelpers.GetStringEndsWithPatternForced;  								pattern = new SqlClientParameter(  									cp.ClrType' cp.SqlType'  									Expression.Lambda(  										Expression.Invoke(Expression.Constant(getStringEndsWithPatternForced)' cp.Accessor.Body' Expression.Constant('~'))'  										cp.Accessor.Parameters[0]  										)'  									cp.SourceExpression  									);  							}  							else  							{  								throw Error.NonConstantExpressionsNotSupportedFor("String.EndsWith");  							}    							if(needsEscape)  							{  								escape = sql.ValueFromObject("~"' false' source);  							}    							return sql.Like(mc.Object' pattern' escape' source);  						}  						break;  					case "IndexOf":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen when = new SqlWhen(lenZeroExpr' sql.ValueFromObject(0' source));  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);    						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  										new SqlExpression[] {                                           mc.Arguments[0]'                                           mc.Object'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.IndexOfWithStringComparisonArgNotSupported();  							}    							// s1.IndexOf(s2' start' count) -> CHARINDEX(@s2' SUBSTRING(@s1' 1' @start + @count)' @start + 1)  							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(mc.Object)));  							SqlWhen when = new SqlWhen(lenZeroExpr' mc.Arguments[1]);  							SqlExpression substring = sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.ValueFromObject(1' false' source)'                                      sql.Add(mc.Arguments[1]' mc.Arguments[2])                                      }'  									source);  							SqlExpression @else = sql.Subtract(sql.FunctionCall(typeof(int)' "CHARINDEX"'  									new SqlExpression[] {                                           mc.Arguments[0]'                                           substring'                                          sql.Add(mc.Arguments[1]' 1)                                          }'  									source)' 1);  							return sql.SearchedCase(new SqlWhen[] { when }' @else' source);  						}  						break;  					case "LastIndexOf":  						if(mc.Arguments.Count == 1)  						{  							// s.LastIndexOf(part) -->  							// CASE WHEN CHARINDEX(@part' @s) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@s) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@s))  							// END  							SqlExpression exprPart = mc.Arguments[0];  							if(exprPart is SqlValue && ((SqlValue)exprPart).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression exprS = mc.Object;  							SqlExpression reverseS = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprS }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { exprPart }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { exprPart' exprS }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseS }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(exprS);  							SqlExpression len2 = sql.FunctionCallChrLength(exprPart);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty' return zero  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' sql.Subtract(sql.FunctionCallChrLength(exprS)' 1));    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.LastIndexOf(part'i) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN CHARINDEX(@part' @first) = 0  THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[1].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						else if(mc.Arguments.Count == 3)  						{  							// s.LastIndexOf(part' i' count) -->  							// set @first = LEFT(@s' @i+1)  							// CASE WHEN (CHARINDEX(@part' @first) = 0)  OR (1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))) < (@i - @count) THEN  -1  							//      ELSE 1 + CLRLENGTH(@first) - CLRLENGTH(@part) - CHARINDEX(REVERSE(@part)'REVERSE(@first))  							// END  							if(mc.Arguments[2].ClrType == typeof(StringComparison))  							{  								throw Error.LastIndexOfWithStringComparisonArgNotSupported();  							}  							SqlExpression s = mc.Object;  							SqlExpression part = mc.Arguments[0];  							if(part is SqlValue && ((SqlValue)part).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlExpression i = mc.Arguments[1];  							SqlExpression count = mc.Arguments[2];  							SqlExpression first = sql.FunctionCall(typeof(string)' "LEFT"' new SqlExpression[] { s' sql.Add(i' 1) }' source);  							SqlExpression reverseFirst = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { first }' source);  							SqlExpression reversePart = sql.FunctionCall(typeof(string)' "REVERSE"' new SqlExpression[] { part }' source);  							SqlExpression charIndex = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { part' first }' source);  							SqlExpression charIndexOfReverse = sql.FunctionCall(typeof(int)' "CHARINDEX"' new SqlExpression[] { reversePart' reverseFirst }' source);  							SqlExpression len1 = sql.FunctionCallChrLength(first);  							SqlExpression len2 = sql.FunctionCallChrLength(part);  							SqlExpression elseCase = sql.Add(sql.ValueFromObject(1' false' source)' sql.Subtract(len1' sql.Add(len2' charIndexOfReverse)));  							SqlExpression notContained = sql.Binary(SqlNodeType.EQ' charIndex' sql.ValueFromObject(0' false' source));  							notContained = sql.OrAccumulate(notContained' sql.Binary(SqlNodeType.LE' elseCase' sql.Subtract(i' count)));    							SqlWhen whenNotContained = new SqlWhen(notContained' sql.ValueFromObject(-1' false' source));    							// if the search string is empty and the start index is in bounds'  							// return the start index  							SqlExpression lenZeroExpr = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Arguments[0])' sql.ValueFromObject(0' source));  							lenZeroExpr = sql.AndAccumulate(lenZeroExpr' sql.Binary(SqlNodeType.LE' sql.Add(mc.Arguments[1]' 1)' sql.FunctionCallChrLength(s)));  							SqlWhen whenLenZero = new SqlWhen(lenZeroExpr' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { whenLenZero' whenNotContained }'  								elseCase' source);  						}  						break;  					case "Insert":  						// Create STUFF(str' insertPos + 1' 0' strToInsert)  						if(mc.Arguments.Count == 2)  						{  							if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							SqlFunctionCall stuffCall = sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.ValueFromObject(0' false' source)'                                      mc.Arguments[1]                                                                      }'  								source);  							// We construct SQL to handle the special case of when the length of the string  							// to modify is equal to the insert position.  This occurs if the string is empty and  							// the insert pos is 0' or when the string is not empty' and the insert pos indicates  							// the end of the string.  							// CASE WHEN (CLRLENGTH(str) = insertPos) THEN str + strToInsert ELSE STUFF(...)                         							SqlExpression insertingAtEnd = sql.Binary(SqlNodeType.EQ' sql.FunctionCallChrLength(mc.Object)' mc.Arguments[0]);  							SqlExpression stringConcat = sql.Concat(mc.Object' mc.Arguments[1]);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(insertingAtEnd' stringConcat) }' stuffCall' source);  						}  						break;  					case "PadLeft":  						if(mc.Arguments.Count == 1)  						{  							// s.PadLeft(i) -->  							// CASE WHEN CLRLENGTH(@s)>= @i THEN @s  							//      ELSE SPACE(@i-CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' len2' exprI);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadLeft(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE REPLICATE(@c' @i - CLRLENGTH(@s)) + @s   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(padding' exprS);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;  					case "PadRight":  						if(mc.Arguments.Count == 1)  						{  							// s.PadRight(i) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + SPACE(@i - CLRLENGTH(@s))   							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "SPACE"' new SqlExpression[] { numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// s.PadRight(i'c) -->  							// CASE WHEN CLRLENGTH(@s) >= @i THEN @s  							//      ELSE @s + REPLICATE(@c' @i - CLRLENGTH(@s))  							// END  							SqlExpression exprS = mc.Object;  							SqlExpression exprI = mc.Arguments[0];  							SqlExpression exprC = mc.Arguments[1];  							SqlExpression dontChange = sql.Binary(SqlNodeType.GE' sql.FunctionCallChrLength(exprS)' exprI);  							SqlExpression len2 = sql.FunctionCallChrLength(exprS);  							SqlExpression numSpaces = sql.Subtract(exprI' len2);  							SqlExpression padding = sql.FunctionCall(typeof(string)' "REPLICATE"' new SqlExpression[] { exprC' numSpaces }' source);  							SqlExpression elseCase = sql.Concat(exprS' padding);    							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(dontChange' exprS) }' elseCase' source);  						}  						break;    					case "Remove":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "STUFF"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]'                                      sql.ValueFromObject(""' false' source)                                  }'  								source);  						}  						break;  					case "Replace":  						if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  						{  							throw Error.ArgumentNull("old");  						}  						if(mc.Arguments[1] is SqlValue && ((SqlValue)mc.Arguments[1]).Value == null)  						{  							throw Error.ArgumentNull("new");  						}  						return sql.FunctionCall(  							typeof(string)' "REPLACE"'  							new SqlExpression[] {                                  mc.Object'                                  mc.Arguments[0]'                                  mc.Arguments[1]                              }'  							source);  					case "Substring":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      sql.FunctionCallChrLength(mc.Object)                                      }'  								source);  						}  						else if(mc.Arguments.Count == 2)  						{  							return sql.FunctionCall(  								typeof(string)' "SUBSTRING"'  								new SqlExpression[] {                                      mc.Object'                                      sql.Add(mc.Arguments[0]' 1)'                                      mc.Arguments[1]                                      }'  								source);  						}  						break;  					case "Trim":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(  								typeof(string)' "LTRIM"'  								new SqlExpression[] {                                      sql.FunctionCall(typeof(string)' "RTRIM"' new SqlExpression[] { mc.Object }' source)                                      }'  								source);  						}  						break;  					case "ToLower":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "LOWER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "ToUpper":  						if(mc.Arguments.Count == 0)  						{  							return sql.FunctionCall(typeof(string)' "UPPER"' new SqlExpression[] { mc.Object }' source);  						}  						break;  					case "get_Chars":  						// s[i] --> SUBSTRING(@s' @i+1' 1)  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(char)' "SUBSTRING"' new SqlExpression[]                                  {mc.Object'                                    sql.Add( mc.Arguments[0]' 1)'                                   sql.ValueFromObject(1' false' source)                                  }' source);  						}  						break;  					case "CompareTo":  						if(mc.Arguments.Count == 1)  						{  							if(mc.Arguments[0] is SqlValue && ((SqlValue)mc.Arguments[0]).Value == null)  							{  								throw Error.ArgumentNull("value");  							}  							return CreateComparison(mc.Object' mc.Arguments[0]' source);  						}  						break;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateMathMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Abs":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(mc.Arguments[0].ClrType' "ABS"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Acos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ACOS"' mc.Arguments' source);  						}  						break;  					case "Asin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ASIN"' mc.Arguments' source);  						}  						break;  					case "Atan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "ATAN"' mc.Arguments' source);  						}  						break;  					case "Atan2":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(typeof(double)' "ATN2"' mc.Arguments' source);  						}  						break;  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return sql.Multiply(sql.ConvertToBigint(mc.Arguments[0])' sql.ConvertToBigint(mc.Arguments[1]));  						}  						break;  					case "Ceiling":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "CEILING"' mc.Arguments' source);  						}  						break;  					case "Cos":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "COS"' mc.Arguments' source);  						}  						break;  					case "Cosh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Add(expX' expMinusX)' 2);  						}  						break;  					// DivRem has out parameter  					case "Exp":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "EXP"' mc.Arguments' source);  						}  						break;  					case "Floor":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(mc.Arguments[0].ClrType' "FLOOR"' mc.Arguments' source);  						}  						break;  					// Math.IEEERemainder - difficult to implement correctly since SQL rounds differently  					case "Log":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG"' mc.Arguments' source);  						}  						else if(mc.Arguments.Count == 2)  						{  							// Math.Log(x'y) --> LOG(@x) / LOG(@y)  							SqlExpression log1 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[0] }' source);  							SqlExpression log2 = sql.FunctionCall(typeof(double)' "LOG"' new SqlExpression[] { mc.Arguments[1] }' source);  							return sql.Divide(log1' log2);  						}  						break;  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "LOG10"' mc.Arguments' source);  						}  						break;  					case "Max":  						if(mc.Arguments.Count == 2)  						{  							// Max(a'b) --> CASE WHEN @a<@b THEN @b ELSE @a  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return new SqlSearchedCase(mc.Method.ReturnType' new SqlWhen[] { new SqlWhen(aLower' b) }' a' source);  						}  						break;  					case "Min":  						if(mc.Arguments.Count == 2)  						{  							// Min(a'b) --> CASE WHEN @a<@b THEN @a ELSE @b  							SqlExpression a = mc.Arguments[0];  							SqlExpression b = mc.Arguments[1];  							SqlExpression aLower = sql.Binary(SqlNodeType.LT' a' b);  							return sql.SearchedCase(new SqlWhen[] { new SqlWhen(aLower' a) }' b' source);  						}  						break;  					case "Pow":  						if(mc.Arguments.Count == 2)  						{  							return this.CreateFunctionCallStatic2(mc.ClrType' "POWER"' mc.Arguments' source);  						}  						break;  					case "Round":  						int nParams = mc.Arguments.Count;  						if((mc.Arguments[nParams - 1].ClrType != typeof(MidpointRounding)))  						{  							throw Error.MathRoundNotSupported();  						}  						else  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression i = null;  							if(nParams == 2)  							{  								i = sql.ValueFromObject(0' false' source);  							}  							else  							{  								i = mc.Arguments[1];  							}  							SqlExpression roundingMethod = mc.Arguments[nParams - 1];  							if(roundingMethod.NodeType != SqlNodeType.Value)  							{  								throw Error.NonConstantExpressionsNotSupportedForRounding();  							}  							if((MidpointRounding)this.Eval(roundingMethod) == MidpointRounding.AwayFromZero)  							{  								// round(x) --> round(@x'0)  								return sql.FunctionCall(x.ClrType' "round"' new SqlExpression[] { x' i }' source);  							}  							else  							{  								// CASE WHEN 2*@x = ROUND(2*@x' @i) AND @x <> ROUND(@x' @i)  								//      THEN 2 * ROUND(@x/2' @i)  								//      ELSE ROUND(@x' @i)  								// END  								Type type = x.ClrType;  								SqlExpression roundX = sql.FunctionCall(type' "round"' new SqlExpression[] { x' i }' source);  								SqlExpression twiceX = sql.Multiply(x' 2);  								SqlExpression round2X = sql.FunctionCall(type' "round"' new SqlExpression[] { twiceX' i }' source);  								SqlExpression condition = sql.AndAccumulate(sql.Binary(SqlNodeType.EQ' twiceX' round2X)' sql.Binary(SqlNodeType.NE' x' roundX));  								SqlExpression specialCase = sql.Multiply(sql.FunctionCall(type' "round"' new SqlExpression[] { sql.Divide(x' 2)' i }' source)' 2);  								return sql.SearchedCase(new SqlWhen[] { new SqlWhen(condition' specialCase) }' roundX' source);  							}  						}  					case "Sign":  						if(mc.Arguments.Count == 1)  						{  							return sql.FunctionCall(typeof(int)' "SIGN"' new SqlExpression[] { mc.Arguments[0] }' source);  						}  						break;  					case "Sin":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SIN"' mc.Arguments' source);  						}  						break;  					case "Sinh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression exp = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinus = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(exp' expMinus)' 2);  						}  						break;  					case "Sqrt":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "SQRT"' mc.Arguments' source);  						}  						break;  					case "Tan":  						if(mc.Arguments.Count == 1)  						{  							return this.CreateFunctionCallStatic1(typeof(double)' "TAN"' mc.Arguments' source);  						}  						break;  					case "Tanh":  						if(mc.Arguments.Count == 1)  						{  							SqlExpression x = mc.Arguments[0];  							SqlExpression expX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { x }' source);  							SqlExpression minusX = sql.Unary(SqlNodeType.Negate' x' source);  							SqlExpression expMinusX = sql.FunctionCall(typeof(double)' "EXP"' new SqlExpression[] { minusX }' source);  							return sql.Divide(sql.Subtract(expX' expMinusX)' sql.Add(expX' expMinusX));  						}  						break;  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							// Truncate(x) --> ROUND (x' 0' 1)  							SqlExpression x = mc.Arguments[0];  							return sql.FunctionCall(mc.Method.ReturnType' "ROUND"' new SqlExpression[] { x' sql.ValueFromObject(0' false' source)' sql.ValueFromObject(1' false' source) }' source);  						}  						break;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,Visitor,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlTopReducer.cs,TranslateVbConversionMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  					{  						case "ToBoolean":  							targetType = typeof(bool);  							break;  						case "ToSByte":  							targetType = typeof(sbyte);  							break;  						case "ToByte":  							targetType = typeof(byte);  							break;  						case "ToChar":  							targetType = typeof(char);  							break;  						case "ToCharArrayRankOne":  							targetType = typeof(char[]);  							break;  						case "ToDate":  							targetType = typeof(DateTime);  							break;  						case "ToDecimal":  							targetType = typeof(decimal);  							break;  						case "ToDouble":  							targetType = typeof(double);  							break;  						case "ToInteger":  							targetType = typeof(Int32);  							break;  						case "ToUInteger":  							targetType = typeof(UInt32);  							break;  						case "ToLong":  							targetType = typeof(Int64);  							break;  						case "ToULong":  							targetType = typeof(UInt64);  							break;  						case "ToShort":  							targetType = typeof(Int16);  							break;  						case "ToUShort":  							targetType = typeof(UInt16);  							break;  						case "ToSingle":  							targetType = typeof(float);  							break;  						case "ToString":  							targetType = typeof(string);  							break;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,AreValuesEqual,The following switch statement is missing a default case: switch(this.sqlDbType)  			{  				case SqlDbType.Char:  				case SqlDbType.NChar:  				case SqlDbType.NVarChar:  				case SqlDbType.VarChar:  				case SqlDbType.Text:  					string s1 = o1 as string;  					if(s1 != null)  					{  						string s2 = o2 as string;  						if(s2 != null)  						{  							return s1.TrimEnd(' ').Equals(s2.TrimEnd(' ')' StringComparison.Ordinal);  						}  					}  					break;  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlType,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlType.cs,ToQueryString,The following switch statement is missing a default case: switch(sqlDbType)  			{  				case SqlDbType.BigInt:  				case SqlDbType.Bit:  				case SqlDbType.Date:  				case SqlDbType.Time:  				case SqlDbType.DateTime:  				case SqlDbType.DateTime2:  				case SqlDbType.DateTimeOffset:  				case SqlDbType.Int:  				case SqlDbType.Money:  				case SqlDbType.SmallDateTime:  				case SqlDbType.SmallInt:  				case SqlDbType.SmallMoney:  				case SqlDbType.Timestamp:  				case SqlDbType.TinyInt:  				case SqlDbType.UniqueIdentifier:  				case SqlDbType.Xml:  				case SqlDbType.Image:  				case SqlDbType.NText:  				case SqlDbType.Text:  				case SqlDbType.Udt:  					sb.Append(sqlDbType.ToString());  					break;  				case SqlDbType.Variant:  					sb.Append("sql_variant");  					break;  				case SqlDbType.Binary:  				case SqlDbType.Char:  				case SqlDbType.NChar:  					sb.Append(sqlDbType);  					if((formatFlags & QueryFormatOptions.SuppressSize) == 0)  					{  						sb.Append("(");  						sb.Append(size);  						sb.Append(")");  					}  					break;  				case SqlDbType.NVarChar:  				case SqlDbType.VarBinary:  				case SqlDbType.VarChar:  					sb.Append(sqlDbType);  					if((size.HasValue && size != 0) && (formatFlags & QueryFormatOptions.SuppressSize) == 0)  					{  						sb.Append("(");  						if(size == ProviderConstants.LargeTypeSizeIndicator)  						{  							sb.Append("MAX");  						}  						else  						{  							sb.Append(size);  						}  						sb.Append(")");  					}  					break;  				case SqlDbType.Decimal:  				case SqlDbType.Float:  				case SqlDbType.Real:  					sb.Append(sqlDbType);  					if(precision != 0)  					{  						sb.Append("(");  						sb.Append(precision);  						if(scale != 0)  						{  							sb.Append("'");  							sb.Append(scale);  						}  						sb.Append(")");  					}  					break;  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetObjectMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Equals":  						return MethodSupport.Method;  					case "ToString":  						if(mc.Object.SqlType.CanBeColumn)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.None;  					case "GetType":  						if(mc.Arguments.Count == 0)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.None;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetDateTimeMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "CompareTo":  					case "AddTicks":  					case "AddMonths":  					case "AddYears":  					case "AddMilliseconds":  					case "AddSeconds":  					case "AddMinutes":  					case "AddHours":  					case "AddDays":  						return MethodSupport.Method;  					case "Add":  						if(mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  						{  							return MethodSupport.Method;  						}  						else  						{  							return MethodSupport.MethodGroup;  						}  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetDateTimeOffsetMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "CompareTo":  					case "AddTicks":  					case "AddMonths":  					case "AddYears":  					case "AddMilliseconds":  					case "AddSeconds":  					case "AddMinutes":  					case "AddHours":  					case "AddDays":  						return MethodSupport.Method;  					case "Add":  						if(mc.Arguments.Count == 1 && mc.Arguments[0].ClrType == typeof(TimeSpan))  						{  							return MethodSupport.Method;  						}  						else  						{  							return MethodSupport.MethodGroup;  						}  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetTimeSpanMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Add":  					case "Subtract":  					case "CompareTo":  					case "Duration":  					case "Negate":  						return MethodSupport.Method;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetConvertMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "ToBoolean":  					case "ToDecimal":  					case "ToByte":  					case "ToChar":  					case "ToDouble":  					case "ToInt16":  					case "ToInt32":  					case "ToInt64":  					case "ToSingle":  					case "ToString":  						return MethodSupport.Method;  					case "ToDateTime":  						if(mc.Arguments[0].ClrType == typeof(string) || mc.Arguments[0].ClrType == typeof(DateTime))  						{  							return MethodSupport.Method;  						}  						else  						{  							return MethodSupport.MethodGroup;  						}  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetDecimalMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  					{  						case "Multiply":  						case "Divide":  						case "Subtract":  						case "Add":  						case "Remainder":  						case "Round":  							return MethodSupport.Method;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetStringMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  					{  						case "Contains":  						case "StartsWith":  						case "EndsWith":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "IndexOf":  						case "LastIndexOf":  							if(mc.Arguments.Count == 1  								|| mc.Arguments.Count == 2  								|| mc.Arguments.Count == 3)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Insert":  							if(mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "PadLeft":  						case "PadRight":  						case "Remove":  						case "Substring":  							if(mc.Arguments.Count == 1  							   || mc.Arguments.Count == 2)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "Replace":  							return MethodSupport.Method;  						case "Trim":  						case "ToLower":  						case "ToUpper":  							if(mc.Arguments.Count == 0)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  						case "get_Chars":  						case "CompareTo":  							if(mc.Arguments.Count == 1)  							{  								return MethodSupport.Method;  							}  							return MethodSupport.MethodGroup;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,GetMathMethodSupport,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Abs":  					case "Acos":  					case "Asin":  					case "Atan":  					case "Ceiling":  					case "Cos":  					case "Cosh":  					case "Exp":  					case "Floor":  					case "Log10":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Log":  						if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						};  						return MethodSupport.MethodGroup;  					case "Max":  					case "Min":  					case "Pow":  					case "Atan2":  					case "BigMul":  						if(mc.Arguments.Count == 2)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Round":  						if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)  							&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  					case "Sign":  					case "Sin":  					case "Sinh":  					case "Sqrt":  					case "Tan":  					case "Tanh":  					case "Truncate":  						if(mc.Arguments.Count == 1)  						{  							return MethodSupport.Method;  						}  						return MethodSupport.MethodGroup;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsVbConversionMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "ToBoolean":  					case "ToSByte":  					case "ToByte":  					case "ToChar":  					case "ToCharArrayRankOne":  					case "ToDate":  					case "ToDecimal":  					case "ToDouble":  					case "ToInteger":  					case "ToUInteger":  					case "ToLong":  					case "ToULong":  					case "ToShort":  					case "ToUShort":  					case "ToSingle":  					case "ToString":  						return true;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeMember,The following switch statement is missing a default case: switch(m.Member.Name)  				{  					case "Date":  					case "TimeOfDay":  					case "DayOfWeek":  						return true;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedDateTimeOffsetMember,The following switch statement is missing a default case: switch(m.Member.Name)  				{  					case "Date":  					case "DateTime":  					case "TimeOfDay":  					case "DayOfWeek":  						return true;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,PostBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\PostBindDotNetConverter.cs,IsSupportedTimeSpanMember,The following switch statement is missing a default case: switch(m.Member.Name)  				{  					case "Ticks":  					case "TotalMilliseconds":  					case "TotalSeconds":  					case "TotalMinutes":  					case "TotalHours":  					case "TotalDays":  					case "Milliseconds":  					case "Seconds":  					case "Minutes":  					case "Hours":  					case "Days":  						return true;  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetCachedResult,The following switch statement is missing a default case: switch(this.GetResultShape(query))  				{  					case ResultShape.Singleton:  						return new ExecuteResult(null' null' null' obj);  					case ResultShape.Sequence:  						return new ExecuteResult(null' null' null'  							Activator.CreateInstance(  								typeof(SequenceOfOne<>).MakeGenericType(TypeSystem.GetElementType(this.GetResultType(query)))'  								BindingFlags.Instance | BindingFlags.NonPublic' null' new object[] { obj }' null  								));  				}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,AssignParameters,The following switch statement is missing a default case: switch(pi.Type)  						{  							case SqlParameterType.UserArgument:  								try  								{  									value = pi.Accessor.DynamicInvoke(new object[] { userArguments });  								}  								catch(System.Reflection.TargetInvocationException e)  								{  									throw e.InnerException;  								}  								break;  							case SqlParameterType.PreviousResult:  								value = lastResult;  								break;  						}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetResultShape,The following switch statement is missing a default case: switch(mce.Method.Name)  					{  						// methods known to produce singletons  						case "First":  						case "FirstOrDefault":  						case "Single":  						case "SingleOrDefault":  							isSingleton = true;  							break;  					}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,BuildQuery,The following switch statement is missing a default case: switch(this.Mode)  			{  				case SqlServerProviderMode.Sql2000:  					converter.ConverterStrategy =  						ConverterStrategy.CanUseScopeIdentity |  						ConverterStrategy.CanUseJoinOn |  						ConverterStrategy.CanUseRowStatus;  					break;  				case SqlServerProviderMode.Sql2005:  				case SqlServerProviderMode.Sql2008:  					converter.ConverterStrategy =  						ConverterStrategy.CanUseScopeIdentity |  						ConverterStrategy.SkipWithRowNumber |  						ConverterStrategy.CanUseRowStatus |  						ConverterStrategy.CanUseJoinOn |  						ConverterStrategy.CanUseOuterApply |  						ConverterStrategy.CanOutputFromInsert;  					break;  				case SqlServerProviderMode.SqlCE:  					converter.ConverterStrategy = ConverterStrategy.CanUseOuterApply;  					// Can't set ConverterStrategy.CanUseJoinOn because scalar subqueries in the ON clause  					// can't be converted into anything.  					break;  			}
Missing Default,System.Data.Linq.DbEngines.SqlServer,SqlProvider,C:\repos\FransBouma_LinqToSQL2\src\DbEngines\SqlServer\SqlProvider.cs,GetFinalSelect,The following switch statement is missing a default case: switch(node.NodeType)  			{  				case SqlNodeType.Select:  					return (SqlSelect)node;  				case SqlNodeType.Block:  					{  						SqlBlock b = (SqlBlock)node;  						return GetFinalSelect(b.Statements[b.Statements.Count - 1]);  					}  			}
Missing Default,System.Data.Linq.Provider.Common,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\CompatibilityCheck.cs,Visit,The following switch statement is missing a default case: switch (node.NodeType) {                      case SqlNodeType.ScalarSubSelect:                      case SqlNodeType.Multiset:                      case SqlNodeType.Element:                      case SqlNodeType.SearchedCase:                      case SqlNodeType.ClientCase:                      case SqlNodeType.SimpleCase:                      case SqlNodeType.Member:                      case SqlNodeType.DiscriminatedType:                      case SqlNodeType.New:                      case SqlNodeType.FunctionCall:                      case SqlNodeType.MethodCall:                      case SqlNodeType.Convert: // Object identity does not survive convert. It does survive Cast.                          // Dig no further.                          return node;                      case SqlNodeType.TypeCase:                          sourceType = ((SqlTypeCase)node).RowType.Type;                          return node;                      case SqlNodeType.Link:                          sourceType = ((SqlLink)node).RowType.Type;                          return node;                      case SqlNodeType.Table:                          sourceType = ((SqlTable)node).RowType.Type;                          return node;                      case SqlNodeType.Value:                          SqlValue val = (SqlValue)node;                          if (val.Value != null) {                              // In some cases the ClrType of a Value node may                              // differ from the actual runtime type of the value.                              // Therefore' we ensure here that the correct type is set.                              sourceType = val.Value.GetType();                          }                          return node;                  }
Missing Default,System.Data.Linq.Provider.Common,DynamicTypeGenerator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\DynamicTypeGenerator.cs,GenerateArrayAccess,The following switch statement is missing a default case: switch(tc)  					{  						//case TypeCode.SByte:  						//     gen.Emit(OpCodes.Ldelem_I1);  						//     break;  						//case TypeCode.Int16:  						//     gen.Emit(OpCodes.Ldelem_I2);  						//     break;  						case TypeCode.Int32:  							gen.Emit(OpCodes.Ldelem_I4);  							break;  						//case TypeCode.Int64:  						//     gen.Emit(OpCodes.Ldelem_I8);  						//     break;  						//case TypeCode.Single:  						//     gen.Emit(OpCodes.Ldelem_R4);  						//     break;  						//case TypeCode.Double:  						//     gen.Emit(OpCodes.Ldelem_R8);  						//     break;  						//default:  						//     if (type.IsValueType) {  						//        gen.Emit(OpCodes.Ldelem' type);  						//     }  						//     else {  						//        gen.Emit(OpCodes.Ldelem_Ref);  						//     }  						//     break;  					}
Missing Default,System.Data.Linq.Provider.Common,SqlNamer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\SqlNamer.cs,DiscoverName,The following switch statement is missing a default case: switch(e.NodeType)  				{  					case SqlNodeType.Column:  						return DiscoverName(((SqlColumn)e).Expression);  					case SqlNodeType.ColumnRef:  						SqlColumnRef cref = (SqlColumnRef)e;  						if(cref.Column.Name != null) return cref.Column.Name;  						return DiscoverName(cref.Column);  					case SqlNodeType.ExprSet:  						SqlExprSet eset = (SqlExprSet)e;  						return DiscoverName(eset.Expressions[0]);  				}
Missing Default,System.Data.Linq.Provider.Common,NodeFactory,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\NodeFactory.cs,SubSelect,The following switch statement is missing a default case: switch(nt)  			{  				case SqlNodeType.ScalarSubSelect:  				case SqlNodeType.Element:  					clrType = @select.Selection.ClrType;  					sqlType = @select.Selection.SqlType;  					break;  				case SqlNodeType.Multiset:  					if(clrType == null)  					{  						clrType = typeof(List<>).MakeGenericType(@select.Selection.ClrType);  					}  					sqlType = typeProvider.GetApplicationType((int)ConverterSpecialTypes.Table);  					break;  				case SqlNodeType.Exists:  					clrType = typeof(bool);  					sqlType = typeProvider.From(typeof(bool));  					break;  			}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,CanSkipOnSelection,The following switch statement is missing a default case: switch(selection.NodeType)  			{  				case SqlNodeType.AliasRef:  					{  						SqlNode node = ((SqlAliasRef)selection).Alias.Node;  						SqlSelect select = node as SqlSelect;  						if(select != null)  						{  							return CanSkipOnSelection(select.Selection);  						}  						SqlUnion union = node as SqlUnion;  						if(union != null)  						{  							bool left = default(bool);  							bool right = default(bool);    							SqlSelect selectLeft = union.Left as SqlSelect;  							if(selectLeft != null)  							{  								left = CanSkipOnSelection(selectLeft.Selection);  							}    							SqlSelect selectRight = union.Right as SqlSelect;  							if(selectRight != null)  							{  								right = CanSkipOnSelection(selectRight.Selection);  							}    							return left && right;  						}  						SqlExpression expr = (SqlExpression)node;  						return CanSkipOnSelection(expr);  					}  				case SqlNodeType.New:  					SqlNew sn = (SqlNew)selection;  					// check each member of the projection for sequences  					foreach(SqlMemberAssign ma in sn.Members)  					{  						if(!CanSkipOnSelection(ma.Expression))  							return false;  					}  					if(sn.ArgMembers != null)  					{  						for(int i = 0' n = sn.ArgMembers.Count; i < n; ++i)  						{  							if(!CanSkipOnSelection(sn.Args[i]))  							{  								return false;  							}  						}  					}  					break;  			}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitUnary,The following switch statement is missing a default case: switch(u.NodeType)  			{  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  					result = _nodeFactory.Unary(SqlNodeType.Negate' exp' _dominatingExpression);  					break;  				case ExpressionType.Not:  					if(u.Operand.Type == typeof(bool) || u.Operand.Type == typeof(bool?))  					{  						result = _nodeFactory.Unary(SqlNodeType.Not' exp' _dominatingExpression);  					}  					else  					{  						result = _nodeFactory.Unary(SqlNodeType.BitNot' exp' _dominatingExpression);  					}  					break;  				case ExpressionType.TypeAs:  					result = _nodeFactory.Unary(SqlNodeType.Treat' exp' _dominatingExpression);  					break;  			}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitMethodCall,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "GetTable":  						{  							// calls to GetTable<T> can be translated directly as table references  							if(mc.Method.IsGenericMethod)  							{  								Type[] typeArgs = mc.Method.GetGenericArguments();  								if(typeArgs.Length == 1 && mc.Method.GetParameters().Length == 0)  								{  									CheckContext(this.VisitExpression(mc.Object));  									ITable table = _services.Context.GetTable(typeArgs[0]);  									if(table != null)  									{  										return this.Visit(Expression.Constant(table));  									}  								}  							}  							break;  						}  					case "ExecuteCommand":  					case "ExecuteQuery":  						return this.VisitUserQuery((string)GetValue(mc.Arguments[0]' mc.Method.Name)' GetArray(mc.Arguments[1])' mc.Type);  				}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitSequenceOperatorCall,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Select":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelect(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "SelectMany":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitSelectMany(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						break;  					case "Join":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "GroupJoin":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 5 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[4]) && this.GetLambda(mc.Arguments[4]).Parameters.Count == 2)  						{  							return this.VisitGroupJoin(mc.Arguments[0]' mc.Arguments[1]' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3])' this.GetLambda(mc.Arguments[4]));  						}  						break;  					case "DefaultIfEmpty":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDefaultIfEmpty(mc.Arguments[0]);  						}  						break;  					case "OfType":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type ofType = mc.Method.GetGenericArguments()[0];  							return this.VisitOfType(mc.Arguments[0]' ofType);  						}  						break;  					case "Cast":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							Type type = mc.Method.GetGenericArguments()[0];  							return this.VisitSequenceCast(mc.Arguments[0]' type);  						}  						break;  					case "Where":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitWhere(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						break;  					case "First":  					case "FirstOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "Single":  					case "SingleOrDefault":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' null' false);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitFirst(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Distinct":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitDistinct(mc.Arguments[0]);  						}  						break;  					case "Concat":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitConcat(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Union":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitUnion(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Intersect":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitIntersect(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Except":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitExcept(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Any":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' null' true);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' true);  						}  						break;  					case "All":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitQuantifier(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' false);  						}  						break;  					case "Count":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Count' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Count' mc.Type);  						}  						break;  					case "LongCount":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.LongCount' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.LongCount' mc.Type);  						}  						break;  					case "Sum":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Sum' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Sum' mc.Type);  						}  						break;  					case "Min":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Min' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Min' mc.Type);  						}  						break;  					case "Max":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Max' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Max' mc.Type);  						}  						break;  					case "Average":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' null' SqlNodeType.Avg' mc.Type);  						}  						else if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitAggregate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlNodeType.Avg' mc.Type);  						}  						break;  					case "GroupBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' null);  						}  						else if(mc.Arguments.Count == 3 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 4 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[2]) && this.GetLambda(mc.Arguments[2]).Parameters.Count == 1 &&  							this.IsLambda(mc.Arguments[3]) && this.GetLambda(mc.Arguments[3]).Parameters.Count == 2)  						{  							return this.VisitGroupBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2])' this.GetLambda(mc.Arguments[3]));  						}  						break;  					case "OrderBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "OrderByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitOrderBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "ThenBy":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Ascending);  						}  						break;  					case "ThenByDescending":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2 &&  							this.IsLambda(mc.Arguments[1]) && this.GetLambda(mc.Arguments[1]).Parameters.Count == 1)  						{  							return this.VisitThenBy(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' SqlOrderType.Descending);  						}  						break;  					case "Take":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitTake(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Skip":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitSkip(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "Contains":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitContains(mc.Arguments[0]' mc.Arguments[1]);  						}  						break;  					case "ToList":  					case "AsEnumerable":  					case "ToArray":  						isSupportedSequenceOperator = true;  						if(mc.Arguments.Count == 1)  						{  							return this.Visit(mc.Arguments[0]);  						}  						break;  				}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,VisitDataManipulationCall,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "Insert":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitInsert(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitInsert(mc.Arguments[0]' null);  						}  						break;  					case "Update":  						isSupportedDML = true;  						if(mc.Arguments.Count == 3)  						{  							return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' this.GetLambda(mc.Arguments[2]));  						}  						else if(mc.Arguments.Count == 2)  						{  							if(mc.Method.GetGenericArguments().Length == 1)  							{  								return this.VisitUpdate(mc.Arguments[0]' this.GetLambda(mc.Arguments[1])' null);  							}  							else  							{  								return this.VisitUpdate(mc.Arguments[0]' null' this.GetLambda(mc.Arguments[1]));  							}  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitUpdate(mc.Arguments[0]' null' null);  						}  						break;  					case "Delete":  						isSupportedDML = true;  						if(mc.Arguments.Count == 2)  						{  							return this.VisitDelete(mc.Arguments[0]' this.GetLambda(mc.Arguments[1]));  						}  						else if(mc.Arguments.Count == 1)  						{  							return this.VisitDelete(mc.Arguments[0]' null);  						}  						break;  				}
Missing Default,System.Data.Linq.Provider.Common,QueryConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Common\QueryConverter.cs,IsLegalIdentityType,The following switch statement is missing a default case: switch(Type.GetTypeCode(type))  			{  				case TypeCode.SByte:  				case TypeCode.Int16:  				case TypeCode.Int32:  				case TypeCode.Int64:  				case TypeCode.Decimal:  					return true;  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch (bo.NodeType) {  				case SqlNodeType.EQ:  				case SqlNodeType.EQ2V:  					if (this.IsConstNull(bo.Left) && !TypeSystem.IsNullableType(bo.ClrType)) {  						return this.VisitUnaryOperator(this.sql.Unary(SqlNodeType.IsNull' bo.Right' bo.SourceExpression));  					}  					else if (this.IsConstNull(bo.Right) && !TypeSystem.IsNullableType(bo.ClrType)) {  						return this.VisitUnaryOperator(this.sql.Unary(SqlNodeType.IsNull' bo.Left' bo.SourceExpression));  					}  					break;  				case SqlNodeType.NE:  				case SqlNodeType.NE2V:  					if (this.IsConstNull(bo.Left) && !TypeSystem.IsNullableType(bo.ClrType)) {  						return this.VisitUnaryOperator(this.sql.Unary(SqlNodeType.IsNotNull' bo.Right' bo.SourceExpression));  					}  					else if (this.IsConstNull(bo.Right) && !TypeSystem.IsNullableType(bo.ClrType)) {  						return this.VisitUnaryOperator(this.sql.Unary(SqlNodeType.IsNotNull' bo.Left' bo.SourceExpression));  					}  					break;  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch (bo.NodeType) {  				case SqlNodeType.EQ:  				case SqlNodeType.EQ2V:     				case SqlNodeType.NE:  				case SqlNodeType.NE2V: {  					SqlValue vLeft = bo.Left as SqlValue;  					SqlValue vRight = bo.Right as SqlValue;  					bool leftIsBool = vLeft!=null && vLeft.Value is bool;  					bool rightIsBool = vRight!=null && vRight.Value is bool;  					if (leftIsBool || rightIsBool) {  						bool equal = bo.NodeType != SqlNodeType.NE && bo.NodeType != SqlNodeType.NE2V;  						bool isTwoValue = bo.NodeType == SqlNodeType.EQ2V || bo.NodeType == SqlNodeType.NE2V;  						SqlNodeType negator = isTwoValue ? SqlNodeType.Not2V : SqlNodeType.Not;  						if (leftIsBool && !rightIsBool) {  							bool value = (bool)vLeft.Value;  							if (value^equal) {  								return VisitUnaryOperator(new SqlUnary(negator' bo.ClrType' bo.SqlType' sql.DoNotVisitExpression(bo.Right)' bo.SourceExpression));  							}  							if (bo.Right.ClrType==typeof(bool)) { // If the other side is nullable bool then this expression is already a reasonable way to handle three-values  								return bo.Right;  							}  						}  						else if (!leftIsBool && rightIsBool) {  							bool value = (bool)vRight.Value;  							if (value^equal) {                                 								return VisitUnaryOperator(new SqlUnary(negator' bo.ClrType' bo.SqlType' sql.DoNotVisitExpression(bo.Left)' bo.SourceExpression));  							}  							if (bo.Left.ClrType==typeof(bool)) { // If the other side is nullable bool then this expression is already a reasonable way to handle three-values  								return bo.Left;  							}                                  						} else if (leftIsBool && rightIsBool) {  							// Here' both left and right are bools.  							bool leftValue = (bool)vLeft.Value;  							bool rightValue = (bool)vRight.Value;                                    							if (equal) {  								return sql.ValueFromObject(leftValue==rightValue' false' bo.SourceExpression);  							} else {  								return sql.ValueFromObject(leftValue!=rightValue' false' bo.SourceExpression);  							}  						}  					}  					break;  				}  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch (bo.NodeType) {  				case SqlNodeType.And: {  					SqlValue vLeft = bo.Left as SqlValue;  					SqlValue vRight = bo.Right as SqlValue;  					if (vLeft != null && vRight == null) {  						if (vLeft.Value != null && (bool)vLeft.Value) {  							return bo.Right;  						}  						return sql.ValueFromObject(false' false' bo.SourceExpression);  					}  					else if (vLeft == null && vRight != null) {  						if (vRight.Value != null && (bool)vRight.Value) {  							return bo.Left;  						}  						return sql.ValueFromObject(false' false' bo.SourceExpression);  					}  					else if (vLeft != null && vRight != null) {  						return sql.ValueFromObject((bool)(vLeft.Value ?? false) && (bool)(vRight.Value ?? false)' false' bo.SourceExpression);  					}  					break;  				}    				case SqlNodeType.Or: {  					SqlValue vLeft = bo.Left as SqlValue;  					SqlValue vRight = bo.Right as SqlValue;  					if (vLeft != null && vRight == null) {  						if (vLeft.Value != null && !(bool)vLeft.Value) {  							return bo.Right;  						}  						return sql.ValueFromObject(true' false' bo.SourceExpression);  					}  					else if (vLeft == null && vRight != null) {  						if (vRight.Value != null && !(bool)vRight.Value) {  							return bo.Left;  						}  						return sql.ValueFromObject(true' false' bo.SourceExpression);  					}  					else if (vLeft != null && vRight != null) {  						return sql.ValueFromObject((bool)(vLeft.Value ?? false) || (bool)(vRight.Value ?? false)' false' bo.SourceExpression);  					}  					break;  				}    				case SqlNodeType.EQ:  				case SqlNodeType.NE:  				case SqlNodeType.EQ2V:  				case SqlNodeType.NE2V: {  					SqlExpression translated = this.translator.TranslateLinkEquals(bo);  					if (translated != bo) {  						return this.VisitExpression(translated);  					}  					break;  				}  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch (bo.NodeType) {  				case SqlNodeType.EQ:  				case SqlNodeType.NE:  				case SqlNodeType.EQ2V:  				case SqlNodeType.NE2V:  					SqlExpression translated = this.translator.TranslateEquals(bo);  					if (translated != bo) {  						return this.VisitExpression(translated);  					}    					// Special handling for typeof(Type) nodes. Reduce to a static check if possible;  					// strip SqlDiscriminatedType if possible;  					if (typeof(Type).IsAssignableFrom(bo.Left.ClrType)) {  						SqlExpression left = TypeSource.GetTypeSource(bo.Left);  						SqlExpression right = TypeSource.GetTypeSource(bo.Right);    						MetaType[] leftPossibleTypes = GetPossibleTypes(left);  						MetaType[] rightPossibleTypes = GetPossibleTypes(right);    						bool someMatch = false;  						for (int i = 0; i < leftPossibleTypes.Length; ++i) {  							for (int j = 0; j < rightPossibleTypes.Length; ++j) {  								if (leftPossibleTypes[i] == rightPossibleTypes[j]) {  									someMatch = true;  									break;  								}  							}  						}    						// Is a match possible?  						if (!someMatch) {  							// No match is possible  							return this.VisitExpression(sql.ValueFromObject(bo.NodeType == SqlNodeType.NE' false' bo.SourceExpression));  						}    						// Is the match known statically?  						if (leftPossibleTypes.Length == 1 && rightPossibleTypes.Length == 1) {  							// Yes' the match is statically known.  							return this.VisitExpression(sql.ValueFromObject(  																		    (bo.NodeType == SqlNodeType.EQ) == (leftPossibleTypes[0] == rightPossibleTypes[0])'  								false'  								bo.SourceExpression));  						}    						// If both sides are discriminated types' then create a comparison of discriminators instead;  						SqlDiscriminatedType leftDt = bo.Left as SqlDiscriminatedType;  						SqlDiscriminatedType rightDt = bo.Right as SqlDiscriminatedType;  						if (leftDt != null && rightDt != null) {  							return this.VisitExpression(sql.Binary(bo.NodeType' leftDt.Discriminator' rightDt.Discriminator));  						}  					}    					// can only compare sql scalars  					if (TypeSystem.IsSequenceType(bo.Left.ClrType)) {  						throw Error.ComparisonNotSupportedForType(bo.Left.ClrType);  					}  					if (TypeSystem.IsSequenceType(bo.Right.ClrType)) {  						throw Error.ComparisonNotSupportedForType(bo.Right.ClrType);  					}  					break;  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,VisitUnaryOperator,The following switch statement is missing a default case: switch (exp.NodeType) {  					case SqlNodeType.Element:  						exp = sql.SubSelect(SqlNodeType.Exists' ((SqlSubSelect)exp).Select);  						if (uo.NodeType == SqlNodeType.IsNull) {  							exp = sql.Unary(SqlNodeType.Not' exp' exp.SourceExpression);  						}  						return exp;  					case SqlNodeType.ClientQuery: {  						SqlClientQuery cq = (SqlClientQuery)exp;  						if (cq.Query.NodeType == SqlNodeType.Element) {  							exp = sql.SubSelect(SqlNodeType.Exists' cq.Query.Select);  							if (uo.NodeType == SqlNodeType.IsNull) {  								exp = sql.Unary(SqlNodeType.Not' exp' exp.SourceExpression);  							}  							return exp;  						}  						return sql.ValueFromObject(uo.NodeType == SqlNodeType.IsNotNull' false' uo.SourceExpression);  					}  					case SqlNodeType.OptionalValue:  						uo.Operand = ((SqlOptionalValue)exp).HasValue;  						return uo;    					case SqlNodeType.ClientCase: {  						// Distribute unary into simple case.  						SqlClientCase sc = (SqlClientCase)uo.Operand;  						List<SqlExpression> matches = new List<SqlExpression>();  						List<SqlExpression> values = new List<SqlExpression>();  						foreach (SqlClientWhen when in sc.Whens) {  							matches.Add(when.Match);  							values.Add(VisitUnaryOperator(sql.Unary(uo.NodeType' when.Value' when.Value.SourceExpression)));  						}  						return sql.Case(sc.ClrType' sc.Expression' matches' values' sc.SourceExpression);  					}  					case SqlNodeType.TypeCase: {  						// Distribute unary into type case. In the process' convert to simple case.  						SqlTypeCase tc = (SqlTypeCase)uo.Operand;  						List<SqlExpression> newMatches = new List<SqlExpression>();  						List<SqlExpression> newValues = new List<SqlExpression>();  						foreach (SqlTypeCaseWhen when in tc.Whens) {  							SqlUnary un = new SqlUnary(uo.NodeType' uo.ClrType' uo.SqlType' when.TypeBinding' when.TypeBinding.SourceExpression);  							SqlExpression expr = VisitUnaryOperator(un);  							if (expr is SqlNew) {  								throw Error.DidNotExpectTypeBinding();  							}  							newMatches.Add(when.Match);  							newValues.Add(expr);  						}  						return sql.Case(uo.ClrType' tc.Discriminator' newMatches' newValues' tc.SourceExpression);  					}  					case SqlNodeType.Value: {  						SqlValue val = (SqlValue)uo.Operand;  						return sql.Value(typeof(bool)' this.typeProvider.From(typeof(int))' (val.Value == null) == (uo.NodeType == SqlNodeType.IsNull)' val.IsClientSpecified' uo.SourceExpression);  					}  				}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,ConvertLinks,The following switch statement is missing a default case: switch (node.NodeType) {  				case SqlNodeType.Column: {  					SqlColumn col = (SqlColumn)node;  					if (col.Expression != null) {  						col.Expression = this.ConvertLinks(col.Expression);  					}  					return node;  				}  				case SqlNodeType.OuterJoinedValue: {  					SqlExpression o = ((SqlUnary)node).Operand;  					SqlExpression e = this.ConvertLinks(o);  					if (e == o) {  						return node;  					}  					if (e.NodeType != SqlNodeType.OuterJoinedValue) {  						return sql.Unary(SqlNodeType.OuterJoinedValue' e);  					}  					return e;  				}  				case SqlNodeType.Link:  					return this.ConvertToFetchedExpression((SqlLink)node);  				case SqlNodeType.ClientCase: {  					SqlClientCase sc = (SqlClientCase)node;  					foreach (SqlClientWhen when in sc.Whens) {  						SqlExpression converted = ConvertLinks(when.Value);  						when.Value = converted;  						if (!sc.ClrType.IsAssignableFrom(when.Value.ClrType)) {  							throw Error.DidNotExpectTypeChange(when.Value.ClrType' sc.ClrType);  						}    					}  					return node;  				}  			}
Missing Default,System.Data.Linq.Provider.Visitors,MemberAccessBinder,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MemberAccessBinder.cs,ConvertToFetchedExpression,The following switch statement is missing a default case: switch (node.NodeType) {  				case SqlNodeType.OuterJoinedValue: {  					SqlExpression o = ((SqlUnary)node).Operand;  					SqlExpression e = this.ConvertLinks(o);  					if (e == o) {  						return (SqlExpression)node;  					}  					return e;  				}  				case SqlNodeType.ClientCase: {  					// Need to recurse in case the object case has links.  					SqlClientCase cc = (SqlClientCase)node;  					List<SqlNode> fetchedValues = new List<SqlNode>();  					bool allExprs = true;  					foreach (SqlClientWhen when in cc.Whens) {  						SqlNode fetchedValue = ConvertToFetchedExpression(when.Value);  						allExprs = allExprs && (fetchedValue is SqlExpression);  						fetchedValues.Add(fetchedValue);  					}    					if (allExprs) {  						// All WHEN values are simple expressions (no sequences).   						List<SqlExpression> matches = new List<SqlExpression>();  						List<SqlExpression> values = new List<SqlExpression>();  						for (int i = 0' c = fetchedValues.Count; i < c; ++i) {  							SqlExpression fetchedValue = (SqlExpression)fetchedValues[i];  							if (!cc.ClrType.IsAssignableFrom(fetchedValue.ClrType)) {  								throw Error.DidNotExpectTypeChange(cc.ClrType' fetchedValue.ClrType);  							}  							matches.Add(cc.Whens[i].Match);  							values.Add(fetchedValue);  						}  						node = sql.Case(cc.ClrType' cc.Expression' matches' values' cc.SourceExpression);  					}  					else {  						node = SimulateCaseOfSequences(cc' fetchedValues);  					}  					break;  				}  				case SqlNodeType.TypeCase: {  					SqlTypeCase tc = (SqlTypeCase)node;  					List<SqlNode> fetchedValues = new List<SqlNode>();  					foreach (SqlTypeCaseWhen when in tc.Whens) {  						SqlNode fetchedValue = ConvertToFetchedExpression(when.TypeBinding);  						fetchedValues.Add(fetchedValue);  					}    					for (int i = 0' c = fetchedValues.Count; i < c; ++i) {  						SqlExpression fetchedValue = (SqlExpression)fetchedValues[i];  						tc.Whens[i].TypeBinding = fetchedValue;  					}  					break;  				}  				case SqlNodeType.SearchedCase: {  					SqlSearchedCase sc = (SqlSearchedCase)node;  					foreach (SqlWhen when in sc.Whens) {  						when.Match = this.ConvertToFetchedExpression(when.Match);  						when.Value = this.ConvertToFetchedExpression(when.Value);  					}  					sc.Else = this.ConvertToFetchedExpression(sc.Else);  					break;  				}  				case SqlNodeType.Link: {  					SqlLink link = (SqlLink)node;    					if (link.Expansion != null) {  						return this.VisitLinkExpansion(link);  					}    					SqlExpression cached;  					if (this.linkMap.TryGetValue(link.Id' out cached)) {  						return this.VisitExpression(cached);  					}    					// translate link into expanded form  					node = this.translator.TranslateLink(link' true);    					// New nodes may have been produced because of Subquery.  					// Prebind again for method-call and static treat handling.  					node = binder.Prebind(node);    					// Make it an expression.  					node = this.ConvertToExpression(node);    					// bind the translation  					node = this.Visit(node);    					// Check for element node' rewrite as sql apply.  					if (this.currentSelect != null   						&& node != null   						&& node.NodeType == SqlNodeType.Element   						&& link.Member.IsAssociation  						&& this.binder.OptimizeLinkExpansions  						) {  							// if link in a non-nullable foreign key association then inner-join is okay to use (since it must always exist)  							// otherwise use left-outer-join   							SqlJoinType joinType = (link.Member.Association.IsForeignKey && !link.Member.Association.IsNullable)  								? SqlJoinType.Inner : SqlJoinType.LeftOuter;  							SqlSubSelect ss = (SqlSubSelect)node;  							SqlExpression where = ss.Select.Where;  							ss.Select.Where = null;  							// form cross apply   							SqlAlias sa = new SqlAlias(ss.Select);  							if (joinType == SqlJoinType.Inner && this.IsOuterDependent(this.currentSelect.From' sa' @where))  							{  								joinType = SqlJoinType.LeftOuter;  							}  							this.currentSelect.From = sql.MakeJoin(joinType' this.currentSelect.From' sa' @where' ss.SourceExpression);  							SqlExpression result = new SqlAliasRef(sa);  							this.linkMap.Add(link.Id' result);  							return this.VisitExpression(result);  						}  				}  					break;  			}
Missing Default,System.Data.Linq.Provider.Visitors,CaseSimplifier,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\CaseSimplifier.cs,VisitBinaryOperator,The following switch statement is missing a default case: switch(bo.NodeType)  			{  				case SqlNodeType.EQ:  				case SqlNodeType.NE:  				case SqlNodeType.EQ2V:  				case SqlNodeType.NE2V:  					if(bo.Left.NodeType == SqlNodeType.SimpleCase &&  					   bo.Right.NodeType == SqlNodeType.Value &&  					   AreCaseWhenValuesConstant((SqlSimpleCase)bo.Left))  					{  						return this.DistributeOperatorIntoCase(bo.NodeType' (SqlSimpleCase)bo.Left' bo.Right);  					}  					else if(bo.Right.NodeType == SqlNodeType.SimpleCase &&  							bo.Left.NodeType == SqlNodeType.Value &&  							AreCaseWhenValuesConstant((SqlSimpleCase)bo.Right))  					{  						return this.DistributeOperatorIntoCase(bo.NodeType' (SqlSimpleCase)bo.Right' bo.Left);  					}  					break;  			}
Missing Default,System.Data.Linq.Provider.Visitors,SqlAliasDeflator,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlAliasDeflator.cs,VisitJoin,The following switch statement is missing a default case: switch(@join.JoinType)  			{  				case SqlJoinType.Cross:  				case SqlJoinType.Inner:  					// reducing either side would effect cardinality of results  					break;  				case SqlJoinType.LeftOuter:  				case SqlJoinType.CrossApply:  				case SqlJoinType.OuterApply:  					// may reduce to left if no references to the right  					if(this.HasEmptySource(@join.Right))  					{  						SqlAlias a = (SqlAlias)@join.Right;  						_removedMap[a] = a;  						return @join.Left;  					}  					break;  			}
Missing Default,System.Data.Linq.Provider.Visitors,SqlColumnEqualizer,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlColumnEqualizer.cs,CheckJoinCondition,The following switch statement is missing a default case: switch(expr.NodeType)  			{  				case SqlNodeType.And:  				{  					SqlBinary b = (SqlBinary)expr;  					CheckJoinCondition(b.Left);  					CheckJoinCondition(b.Right);  					break;  				}  				case SqlNodeType.EQ:  				case SqlNodeType.EQ2V:  				{  					SqlBinary b = (SqlBinary)expr;  					SqlColumnRef crLeft = b.Left as SqlColumnRef;  					SqlColumnRef crRight = b.Right as SqlColumnRef;  					if(crLeft != null && crRight != null)  					{  						SqlColumn cLeft = crLeft.GetRootColumn();  						SqlColumn cRight = crRight.GetRootColumn();  						this._map[cLeft] = cRight;  						this._map[cRight] = cLeft;  					}  					break;  				}  			}
Missing Default,System.Data.Linq.Provider.Visitors,SingleTableQueryVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SingleTableQueryVisitor.cs,IsColumnMatch,The following switch statement is missing a default case: switch(expr.NodeType)  			{  				case SqlNodeType.Column:  					{  						memberInfo = ((SqlColumn)expr).MetaMember.Member;  						break;  					}  				case SqlNodeType.ColumnRef:  					{  						memberInfo = (((SqlColumnRef)expr).Column).MetaMember.Member;  						break;  					}  				case SqlNodeType.Member:  					{  						memberInfo = ((SqlMember)expr).Member;  						break;  					}  			}
Missing Default,System.Data.Linq.Provider.Visitors,TypeCorrector,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\TypeCorrector.cs,CanDbConvert,The following switch statement is missing a default case: switch(tcTo)  			{  #warning [FB] REFACTOR SQL Server specific  				case TypeCode.Int16: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte;  				case TypeCode.Int32: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16;  				case TypeCode.Int64: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16 || tcFrom == TypeCode.Int32 || tcFrom == TypeCode.UInt32;  				case TypeCode.UInt16: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte;  				case TypeCode.UInt32: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16;  				case TypeCode.UInt64: return tcFrom == TypeCode.Byte || tcFrom == TypeCode.SByte || tcFrom == TypeCode.Int16 || tcFrom == TypeCode.UInt16 || tcFrom == TypeCode.Int32 || tcFrom == TypeCode.UInt32;  				case TypeCode.Double: return tcFrom == TypeCode.Single;  				case TypeCode.Decimal: return tcFrom == TypeCode.Single || tcFrom == TypeCode.Double;  			}
Missing Default,System.Data.Linq.Provider.Visitors,SqlVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlVisitor.cs,VisitSubSelect,The following switch statement is missing a default case: switch(ss.NodeType) {                 case SqlNodeType.ScalarSubSelect: return this.VisitScalarSubSelect(ss);                 case SqlNodeType.Multiset: return this.VisitMultiset(ss);                 case SqlNodeType.Element: return this.VisitElement(ss);                 case SqlNodeType.Exists: return this.VisitExists(ss);              }
Missing Default,System.Data.Linq.Provider.Visitors,SqlVisitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\SqlVisitor.cs,RefersToColumn,The following switch statement is missing a default case: switch (exp.NodeType) {                          case SqlNodeType.Column:                              return exp == col || this.RefersToColumn(((SqlColumn)exp).Expression' col);                          case SqlNodeType.ColumnRef:                              SqlColumnRef cref = (SqlColumnRef)exp;                              return cref.Column == col || this.RefersToColumn(cref.Column.Expression' col);                          case SqlNodeType.ExprSet:                              SqlExprSet set = (SqlExprSet)exp;                              for (int i = 0' n = set.Expressions.Count; i < n; i++) {                                  if (this.RefersToColumn(set.Expressions[i]' col)) {                                      return true;                                  }                              }                              break;                          case SqlNodeType.OuterJoinedValue:                              return this.RefersToColumn(((SqlUnary)exp).Operand' col);                      }
Missing Default,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,MakeCompareTo,The following switch statement is missing a default case: switch(iValue)  					{  						case -1:  							return sql.Binary(SqlNodeType.LT' left' right);  						case 1:  							return sql.Binary(SqlNodeType.GT' left' right);  					}
Missing Default,System.Data.Linq.Provider.Visitors,Visitor,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\ContainsRowNumberChecker.cs,VisitMethodCall,The following switch statement is missing a default case: switch(mc.Method.Name)  					{  						case "op_Equality":  							return sql.Binary(SqlNodeType.EQ' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Inequality":  							return sql.Binary(SqlNodeType.NE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_LessThan":  							return sql.Binary(SqlNodeType.LT' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_LessThanOrEqual":  							return sql.Binary(SqlNodeType.LE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_GreaterThan":  							return sql.Binary(SqlNodeType.GT' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_GreaterThanOrEqual":  							return sql.Binary(SqlNodeType.GE' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Multiply":  							return sql.Binary(SqlNodeType.Mul' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Division":  							return sql.Binary(SqlNodeType.Div' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Subtraction":  							return sql.Binary(SqlNodeType.Sub' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Addition":  							return sql.Binary(SqlNodeType.Add' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_Modulus":  							return sql.Binary(SqlNodeType.Mod' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_BitwiseAnd":  							return sql.Binary(SqlNodeType.BitAnd' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_BitwiseOr":  							return sql.Binary(SqlNodeType.BitOr' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_ExclusiveOr":  							return sql.Binary(SqlNodeType.BitXor' mc.Arguments[0]' mc.Arguments[1]' mc.Method' mc.ClrType);  						case "op_UnaryNegation":  							return sql.Unary(SqlNodeType.Negate' mc.Arguments[0]' mc.Method' mc.SourceExpression);  						case "op_OnesComplement":  							return sql.Unary(SqlNodeType.BitNot' mc.Arguments[0]' mc.Method' mc.SourceExpression);  						case "op_False":  							return sql.Unary(SqlNodeType.Not' mc.Arguments[0]' mc.Method' mc.SourceExpression);  					}
Missing Default,System.Data.Linq.Provider.Visitors,PreBindDotNetConverter,C:\repos\FransBouma_LinqToSQL2\src\Provider\Visitors\MethodCallConverter.cs,IsSupportedMethod,The following switch statement is missing a default case: switch(mc.Method.Name)  				{  					case "op_Equality":  					case "op_Inequality":  					case "op_LessThan":  					case "op_LessThanOrEqual":  					case "op_GreaterThan":  					case "op_GreaterThanOrEqual":  					case "op_Multiply":  					case "op_Division":  					case "op_Subtraction":  					case "op_Addition":  					case "op_Modulus":  					case "op_BitwiseAnd":  					case "op_BitwiseOr":  					case "op_ExclusiveOr":  					case "op_UnaryNegation":  					case "op_OnesComplement":  					case "op_False":  						return true;  					case "Equals":  						return mc.Arguments.Count == 2;  					case "Concat":  						return mc.Method.DeclaringType == typeof(string);  				}
Missing Default,LinqToSqlShared.Mapping,MappingSystem,C:\repos\FransBouma_LinqToSQL2\src\Mapping\DbmlShared\MappingSystem.cs,IsSupportedDiscriminatorType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type)) {                  case TypeCode.Byte:                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                  case TypeCode.Char:                  case TypeCode.String:                  case TypeCode.Boolean:                      return true;              }
Missing Default,LinqToSqlShared.Mapping,MappingSystem,C:\repos\FransBouma_LinqToSQL2\src\Mapping\DbmlShared\MappingSystem.cs,IsSupportedDiscriminatorType,The following switch statement is missing a default case: switch (type) {                  case SqlDbType.BigInt:                  case SqlDbType.Bit:                  case SqlDbType.Char:                  case SqlDbType.Int:                  case SqlDbType.NChar:                  case SqlDbType.NVarChar:                  case SqlDbType.SmallInt:                  case SqlDbType.TinyInt:                  case SqlDbType.VarChar:                      return true;              }
Missing Default,LinqToSqlShared.Mapping,MappingSystem,C:\repos\FransBouma_LinqToSQL2\src\Mapping\DbmlShared\MappingSystem.cs,IsSupportedIdentityType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Byte:                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                  case TypeCode.Char:                  case TypeCode.String:                  case TypeCode.Boolean:                  case TypeCode.Decimal:                  case TypeCode.Single:                  case TypeCode.Double:                      return true;              }
