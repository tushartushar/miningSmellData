Implementation smell,Namespace,Class,File,Method,Description
Long Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The method has 388 lines of code.
Long Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The method has 191 lines of code.
Complex Method,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,WriteEscapedString,Cyclomatic complexity of the method is 8
Complex Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,Cyclomatic complexity of the method is 26
Complex Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,Cyclomatic complexity of the method is 8
Complex Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,Cyclomatic complexity of the method is 8
Complex Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,Cyclomatic complexity of the method is 63
Complex Method,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,Cyclomatic complexity of the method is 11
Complex Method,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,Cyclomatic complexity of the method is 10
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian2,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartographicExtent,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian3,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian3Velocity,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitCartesian3,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteSpherical,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteBoundingRectangle,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteNearFarScalar,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteBounds,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitSpherical,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartographic,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgba,The method has 5 parameters. Parameters: output' red' green' blue' alpha
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgba,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The method has 5 parameters. Parameters: output' red' green' blue' alpha
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteDouble,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteInteger,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitQuaternion,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The method has 5 parameters. Parameters: year' dayOfYear' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,RolloverTime,The method has 5 parameters. Parameters: days' hours' minutes' seconds' timeStandard
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseExact,The method has 8 parameters. Parameters: s' formats' dfi' ret' exact' longYear' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The method has 5 parameters. Parameters: s' provider' result' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseDateSeparator,The method has 5 parameters. Parameters: s' sPos' dfi' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,The method has 6 parameters. Parameters: s' valuePos' minDigits' digits' leadingzero' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseEnum,The method has 6 parameters. Parameters: s' sPos' values' invValues' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseString,The method has 5 parameters. Parameters: s' sPos' maxlength' value' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseAmPm,The method has 7 parameters. Parameters: s' valuePos' num' dfi' exact' numParsed' ampm
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseTimeSeparator,The method has 5 parameters. Parameters: s' sPos' dfi' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The method has 8 parameters. Parameters: s' firstPart' secondPart' exact' result' dfi' incompleteFormat' longYear
Long Parameter List,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The method has 5 parameters. Parameters: isoString' dfi' result' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The method has 9 parameters. Parameters: m11' m12' m13' m21' m22' m23' m31' m32' m33
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The method has 5 parameters. Parameters: w' x' y' z' magnitude
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The method has 5 parameters. Parameters: w' x' y' z' normalization
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,NormalizeCoordinates,The method has 5 parameters. Parameters: w' x' y' z' magnitude
Long Parameter List,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The method has 6 parameters. Parameters: low' w' high' buffer' length' kappa
Long Parameter List,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The method has 7 parameters. Parameters: buffer' length' distance_too_high_w' unsafe_interval' rest' ten_kappa' unit
Long Parameter List,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateDecimalRepresentation,The method has 5 parameters. Parameters: decimal_digits' length' decimal_point' digits_after_point' writer
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter PixelOffsetScaleByDistancePropertyName is 38.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,BoxCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoxCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,CorridorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CorridorCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CylinderCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CylinderCesiumWriter.cs,,The length of the parameter NumberOfVerticalLinesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CylinderCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CylinderCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,DistanceDisplayConditionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DistanceDisplayConditionCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter NumberOfVerticalLinesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,EllipsoidCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipsoidCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,FanCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\FanCesiumWriter.cs,,The length of the parameter PerDirectionRadiusPropertyName is 30.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter PixelOffsetScaleByDistancePropertyName is 38.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter IncrementallyLoadTexturesPropertyName is 37.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter NodeTransformationsPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PacketCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PacketCesiumWriter.cs,,The length of the parameter CustomPatternSensorPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PathCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PathCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,PolygonCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolygonCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PolylineCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolylineCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,VectorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\VectorCesiumWriter.cs,,The length of the parameter MinimumLengthInPixelsPropertyName is 33.
Long Identifier,CesiumLanguageWriter,WallCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\WallCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,,The length of the parameter s_extraDateTimePatternTemplates is 31.
Long Identifier,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,,The length of the parameter s_commonYearCumulativeMonthTable is 32.
Long Identifier,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,,The length of the parameter s_leapYearCumulativeMonthTable is 30.
Long Identifier,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,Grisu3,The length of the parameter ten_mk_minimal_binary_exponent is 30.
Long Identifier,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,Grisu3,The length of the parameter ten_mk_maximal_binary_exponent is 30.
Long Statement,CesiumLanguageWriter.Advanced,CesiumPropertyWriter<TDerived>,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumPropertyWriter.cs,WriteInterval,The length of the statement  "            Output.WriteValue(CesiumFormattingHelper.ToIso8601Interval(interval.Start' interval.Stop' Output.PrettyFormatting ? Iso8601Format.Extended : Iso8601Format.Compact)); " is 165.
Long Statement,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteDate,The length of the statement  "            output.WriteValue(CesiumFormattingHelper.ToIso8601(date' output.PrettyFormatting ? Iso8601Format.Extended : Iso8601Format.Compact)); " is 132.
Long Statement,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteTimeInterval,The length of the statement  "            output.WriteValue(CesiumFormattingHelper.ToIso8601Interval(interval.Start' interval.Stop' output.PrettyFormatting ? Iso8601Format.Extended : Iso8601Format.Compact)); " is 165.
Long Statement,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,GetAndWriteEpoch,The length of the statement  "                output.WriteValue(CesiumFormattingHelper.ToIso8601(epoch' output.PrettyFormatting ? Iso8601Format.Extended : Iso8601Format.Compact)); " is 133.
Long Statement,CesiumLanguageWriter,Cartesian,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Cross,The length of the statement  "            return new Cartesian(m_y * other.m_z - m_z * other.m_y' m_z * other.m_x - m_x * other.m_z' m_x * other.m_y - m_y * other.m_x); " is 126.
Long Statement,CesiumLanguageWriter,AlignedAxisCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\AlignedAxisCesiumWriter.cs,CreateUnitCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<AlignedAxisCesiumWriter' UnitCartesian>(this' (me' value) => me.WriteUnitCartesian(value)' (me' dates' values' startIndex' length) => me.WriteUnitCartesian(dates' values' startIndex' length)); " is 237.
Long Statement,CesiumLanguageWriter,AlignedAxisCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\AlignedAxisCesiumWriter.cs,CreateUnitSphericalAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<AlignedAxisCesiumWriter' UnitSpherical>(this' (me' value) => me.WriteUnitSpherical(value)' (me' dates' values' startIndex' length) => me.WriteUnitSpherical(dates' values' startIndex' length)); " is 237.
Long Statement,CesiumLanguageWriter,AlignedAxisCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\AlignedAxisCesiumWriter.cs,CreateVelocityReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<AlignedAxisCesiumWriter' Reference>(this' (me' value) => me.WriteVelocityReference(value)); " is 122.
Long Statement,CesiumLanguageWriter,BackgroundPaddingCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BackgroundPaddingCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<BackgroundPaddingCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 235.
Long Statement,CesiumLanguageWriter,BackgroundPaddingCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BackgroundPaddingCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<BackgroundPaddingCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 120.
Long Statement,CesiumLanguageWriter,BoundingRectangleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoundingRectangleCesiumWriter.cs,CreateBoundingRectangleAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<BoundingRectangleCesiumWriter' BoundingRectangle>(this' (me' value) => me.WriteBoundingRectangle(value)' (me' dates' values' startIndex' length) => me.WriteBoundingRectangle(dates' values' startIndex' length)); " is 255.
Long Statement,CesiumLanguageWriter,BoundingRectangleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoundingRectangleCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<BoundingRectangleCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 120.
Long Statement,CesiumLanguageWriter,BoxDimensionsCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoxDimensionsCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<BoxDimensionsCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 227.
Long Statement,CesiumLanguageWriter,ColorBlendModeCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ColorBlendModeCesiumWriter.cs,CreateColorBlendModeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<ColorBlendModeCesiumWriter' CesiumColorBlendMode>(this' (me' value) => me.WriteColorBlendMode(value)); " is 133.
Long Statement,CesiumLanguageWriter,ColorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ColorCesiumWriter.cs,CreateRgbaAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<ColorCesiumWriter' Color>(this' (me' value) => me.WriteRgba(value)' (me' dates' values' startIndex' length) => me.WriteRgba(dates' values' startIndex' length)); " is 205.
Long Statement,CesiumLanguageWriter,ColorCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ColorCesiumWriter.cs,CreateRgbafAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<ColorCesiumWriter' Color>(this' (me' value) => me.WriteRgbaf(value)' (me' dates' values' startIndex' length) => me.WriteRgbaf(dates' values' startIndex' length)); " is 207.
Long Statement,CesiumLanguageWriter,CornerTypeCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CornerTypeCesiumWriter.cs,CreateCornerTypeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CornerTypeCesiumWriter' CesiumCornerType>(this' (me' value) => me.WriteCornerType(value)); " is 121.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateBoundingRectangleAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' BoundingRectangle>(this' (me' value) => me.WriteBoundingRectangle(value)' (me' dates' values' startIndex' length) => me.WriteBoundingRectangle(dates' values' startIndex' length)); " is 252.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 228.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateCartographicRadiansAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Cartographic>(this' (me' value) => me.WriteCartographicRadians(value)' (me' dates' values' startIndex' length) => me.WriteCartographicRadians(dates' values' startIndex' length)); " is 251.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateCartographicDegreesAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Cartographic>(this' (me' value) => me.WriteCartographicDegrees(value)' (me' dates' values' startIndex' length) => me.WriteCartographicDegrees(dates' values' startIndex' length)); " is 251.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 232.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateUnitCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' UnitCartesian>(this' (me' value) => me.WriteUnitCartesian(value)' (me' dates' values' startIndex' length) => me.WriteUnitCartesian(dates' values' startIndex' length)); " is 240.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateSphericalAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Spherical>(this' (me' value) => me.WriteSpherical(value)' (me' dates' values' startIndex' length) => me.WriteSpherical(dates' values' startIndex' length)); " is 228.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateUnitSphericalAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' UnitSpherical>(this' (me' value) => me.WriteUnitSpherical(value)' (me' dates' values' startIndex' length) => me.WriteUnitSpherical(dates' values' startIndex' length)); " is 240.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateRgbaAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Color>(this' (me' value) => me.WriteRgba(value)' (me' dates' values' startIndex' length) => me.WriteRgba(dates' values' startIndex' length)); " is 214.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateRgbafAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' Color>(this' (me' value) => me.WriteRgbaf(value)' (me' dates' values' startIndex' length) => me.WriteRgbaf(dates' values' startIndex' length)); " is 216.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateColorBlendModeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumColorBlendMode>(this' (me' value) => me.WriteColorBlendMode(value)); " is 133.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateCornerTypeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumCornerType>(this' (me' value) => me.WriteCornerType(value)); " is 125.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateHeightReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumHeightReference>(this' (me' value) => me.WriteHeightReference(value)); " is 135.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateHorizontalOriginAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumHorizontalOrigin>(this' (me' value) => me.WriteHorizontalOrigin(value)); " is 137.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateLabelStyleAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumLabelStyle>(this' (me' value) => me.WriteLabelStyle(value)); " is 125.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateNumberAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' double>(this' (me' value) => me.WriteNumber(value)' (me' dates' values' startIndex' length) => me.WriteNumber(dates' values' startIndex' length)); " is 219.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateNearFarScalarAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' NearFarScalar>(this' (me' value) => me.WriteNearFarScalar(value)' (me' dates' values' startIndex' length) => me.WriteNearFarScalar(dates' values' startIndex' length)); " is 240.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateUnitQuaternionAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' UnitQuaternion>(this' (me' value) => me.WriteUnitQuaternion(value)' (me' dates' values' startIndex' length) => me.WriteUnitQuaternion(dates' values' startIndex' length)); " is 243.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateShadowModeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumShadowMode>(this' (me' value) => me.WriteShadowMode(value)); " is 125.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateStripeOrientationAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumStripeOrientation>(this' (me' value) => me.WriteStripeOrientation(value)); " is 139.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateWsenAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' CartographicExtent>(this' (me' value) => me.WriteWsen(value)' (me' dates' values' startIndex' length) => me.WriteWsen(dates' values' startIndex' length)); " is 227.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateWsenDegreesAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<CustomPropertyCesiumWriter' CartographicExtent>(this' (me' value) => me.WriteWsenDegrees(value)' (me' dates' values' startIndex' length) => me.WriteWsenDegrees(dates' values' startIndex' length)); " is 241.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateVerticalOriginAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<CustomPropertyCesiumWriter' CesiumVerticalOrigin>(this' (me' value) => me.WriteVerticalOrigin(value)); " is 133.
Long Statement,CesiumLanguageWriter,DirectionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionCesiumWriter.cs,CreateSphericalAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DirectionCesiumWriter' Spherical>(this' (me' value) => me.WriteSpherical(value)' (me' dates' values' startIndex' length) => me.WriteSpherical(dates' values' startIndex' length)); " is 223.
Long Statement,CesiumLanguageWriter,DirectionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionCesiumWriter.cs,CreateUnitSphericalAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DirectionCesiumWriter' UnitSpherical>(this' (me' value) => me.WriteUnitSpherical(value)' (me' dates' values' startIndex' length) => me.WriteUnitSpherical(dates' values' startIndex' length)); " is 235.
Long Statement,CesiumLanguageWriter,DirectionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DirectionCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 223.
Long Statement,CesiumLanguageWriter,DirectionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionCesiumWriter.cs,CreateUnitCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DirectionCesiumWriter' UnitCartesian>(this' (me' value) => me.WriteUnitCartesian(value)' (me' dates' values' startIndex' length) => me.WriteUnitCartesian(dates' values' startIndex' length)); " is 235.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateSphericalAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DirectionListCesiumWriter' IEnumerable<Spherical>>(this' (me' value) => me.WriteSpherical(value)); " is 129.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateUnitSphericalAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DirectionListCesiumWriter' IEnumerable<UnitSpherical>>(this' (me' value) => me.WriteUnitSpherical(value)); " is 137.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DirectionListCesiumWriter' IEnumerable<Cartesian>>(this' (me' value) => me.WriteCartesian(value)); " is 129.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateUnitCartesianAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DirectionListCesiumWriter' IEnumerable<UnitCartesian>>(this' (me' value) => me.WriteUnitCartesian(value)); " is 137.
Long Statement,CesiumLanguageWriter,DistanceDisplayConditionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DistanceDisplayConditionCesiumWriter.cs,CreateDistanceDisplayConditionAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DistanceDisplayConditionCesiumWriter' Bounds>(this' (me' value) => me.WriteDistanceDisplayCondition(value)' (me' dates' values' startIndex' length) => me.WriteDistanceDisplayCondition(dates' values' startIndex' length)); " is 265.
Long Statement,CesiumLanguageWriter,DistanceDisplayConditionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DistanceDisplayConditionCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DistanceDisplayConditionCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 127.
Long Statement,CesiumLanguageWriter,DoubleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DoubleCesiumWriter.cs,CreateNumberAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<DoubleCesiumWriter' double>(this' (me' value) => me.WriteNumber(value)' (me' dates' values' startIndex' length) => me.WriteNumber(dates' values' startIndex' length)); " is 211.
Long Statement,CesiumLanguageWriter,DoubleListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DoubleListCesiumWriter.cs,CreateReferencesAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<DoubleListCesiumWriter' IEnumerable<Reference>>(this' (me' value) => me.WriteReferences(value)); " is 127.
Long Statement,CesiumLanguageWriter,EllipsoidRadiiCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipsoidRadiiCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<EllipsoidRadiiCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 228.
Long Statement,CesiumLanguageWriter,EyeOffsetCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EyeOffsetCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<EyeOffsetCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 223.
Long Statement,CesiumLanguageWriter,HeightReferenceCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\HeightReferenceCesiumWriter.cs,CreateHeightReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<HeightReferenceCesiumWriter' CesiumHeightReference>(this' (me' value) => me.WriteHeightReference(value)); " is 136.
Long Statement,CesiumLanguageWriter,HorizontalOriginCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\HorizontalOriginCesiumWriter.cs,CreateHorizontalOriginAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<HorizontalOriginCesiumWriter' CesiumHorizontalOrigin>(this' (me' value) => me.WriteHorizontalOrigin(value)); " is 139.
Long Statement,CesiumLanguageWriter,IntegerCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\IntegerCesiumWriter.cs,CreateNumberAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<IntegerCesiumWriter' int>(this' (me' value) => me.WriteNumber(value)' (me' dates' values' startIndex' length) => me.WriteNumber(dates' values' startIndex' length)); " is 209.
Long Statement,CesiumLanguageWriter,LabelStyleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelStyleCesiumWriter.cs,CreateLabelStyleAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<LabelStyleCesiumWriter' CesiumLabelStyle>(this' (me' value) => me.WriteLabelStyle(value)); " is 121.
Long Statement,CesiumLanguageWriter,LineCountCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LineCountCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<LineCountCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 227.
Long Statement,CesiumLanguageWriter,LineOffsetCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LineOffsetCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<LineOffsetCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 228.
Long Statement,CesiumLanguageWriter,LineThicknessCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LineThicknessCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<LineThicknessCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 231.
Long Statement,CesiumLanguageWriter,NearFarScalarCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\NearFarScalarCesiumWriter.cs,CreateNearFarScalarAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<NearFarScalarCesiumWriter' NearFarScalar>(this' (me' value) => me.WriteNearFarScalar(value)' (me' dates' values' startIndex' length) => me.WriteNearFarScalar(dates' values' startIndex' length)); " is 239.
Long Statement,CesiumLanguageWriter,OrientationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\OrientationCesiumWriter.cs,CreateUnitQuaternionAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<OrientationCesiumWriter' UnitQuaternion>(this' (me' value) => me.WriteUnitQuaternion(value)' (me' dates' values' startIndex' length) => me.WriteUnitQuaternion(dates' values' startIndex' length)); " is 240.
Long Statement,CesiumLanguageWriter,OrientationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\OrientationCesiumWriter.cs,CreateVelocityReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<OrientationCesiumWriter' Reference>(this' (me' value) => me.WriteVelocityReference(value)); " is 122.
Long Statement,CesiumLanguageWriter,PixelOffsetCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PixelOffsetCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<PixelOffsetCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 229.
Long Statement,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<PositionCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 222.
Long Statement,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,CreateCartographicRadiansAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<PositionCesiumWriter' Cartographic>(this' (me' value) => me.WriteCartographicRadians(value)' (me' dates' values' startIndex' length) => me.WriteCartographicRadians(dates' values' startIndex' length)); " is 245.
Long Statement,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,CreateCartographicDegreesAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<PositionCesiumWriter' Cartographic>(this' (me' value) => me.WriteCartographicDegrees(value)' (me' dates' values' startIndex' length) => me.WriteCartographicDegrees(dates' values' startIndex' length)); " is 245.
Long Statement,CesiumLanguageWriter,PositionCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,CreateCartesianVelocityAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<PositionCesiumWriter' Motion<Cartesian>>(this' (me' value) => me.WriteCartesianVelocity(value)' (me' dates' values' startIndex' length) => me.WriteCartesianVelocity(dates' values' startIndex' length)); " is 246.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<PositionListCesiumWriter' IEnumerable<Cartesian>>(this' (me' value) => me.WriteCartesian(value)); " is 128.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateCartographicRadiansAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<PositionListCesiumWriter' IEnumerable<Cartographic>>(this' (me' value) => me.WriteCartographicRadians(value)); " is 141.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateCartographicDegreesAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<PositionListCesiumWriter' IEnumerable<Cartographic>>(this' (me' value) => me.WriteCartographicDegrees(value)); " is 141.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateReferencesAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<PositionListCesiumWriter' IEnumerable<Reference>>(this' (me' value) => me.WriteReferences(value)); " is 129.
Long Statement,CesiumLanguageWriter,RectangleCoordinatesCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCoordinatesCesiumWriter.cs,CreateWsenAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<RectangleCoordinatesCesiumWriter' CartographicExtent>(this' (me' value) => me.WriteWsen(value)' (me' dates' values' startIndex' length) => me.WriteWsen(dates' values' startIndex' length)); " is 233.
Long Statement,CesiumLanguageWriter,RectangleCoordinatesCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCoordinatesCesiumWriter.cs,CreateWsenDegreesAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<RectangleCoordinatesCesiumWriter' CartographicExtent>(this' (me' value) => me.WriteWsenDegrees(value)' (me' dates' values' startIndex' length) => me.WriteWsenDegrees(dates' values' startIndex' length)); " is 247.
Long Statement,CesiumLanguageWriter,RectangleCoordinatesCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCoordinatesCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<RectangleCoordinatesCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 123.
Long Statement,CesiumLanguageWriter,RepeatCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RepeatCesiumWriter.cs,CreateCartesian2Adaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<RepeatCesiumWriter' Rectangular>(this' (me' value) => me.WriteCartesian2(value)' (me' dates' values' startIndex' length) => me.WriteCartesian2(dates' values' startIndex' length)); " is 224.
Long Statement,CesiumLanguageWriter,RotationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RotationCesiumWriter.cs,CreateUnitQuaternionAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<RotationCesiumWriter' UnitQuaternion>(this' (me' value) => me.WriteUnitQuaternion(value)' (me' dates' values' startIndex' length) => me.WriteUnitQuaternion(dates' values' startIndex' length)); " is 237.
Long Statement,CesiumLanguageWriter,ScaleCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ScaleCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<ScaleCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 219.
Long Statement,CesiumLanguageWriter,SensorVolumePortionToDisplayCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\SensorVolumePortionToDisplayCesiumWriter.cs,CreatePortionToDisplayAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<SensorVolumePortionToDisplayCesiumWriter' CesiumSensorVolumePortionToDisplay>(this' (me' value) => me.WritePortionToDisplay(value)); " is 163.
Long Statement,CesiumLanguageWriter,SensorVolumePortionToDisplayCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\SensorVolumePortionToDisplayCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<SensorVolumePortionToDisplayCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 131.
Long Statement,CesiumLanguageWriter,ShadowModeCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ShadowModeCesiumWriter.cs,CreateShadowModeAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<ShadowModeCesiumWriter' CesiumShadowMode>(this' (me' value) => me.WriteShadowMode(value)); " is 121.
Long Statement,CesiumLanguageWriter,StripeOrientationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\StripeOrientationCesiumWriter.cs,CreateStripeOrientationAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<StripeOrientationCesiumWriter' CesiumStripeOrientation>(this' (me' value) => me.WriteStripeOrientation(value)); " is 142.
Long Statement,CesiumLanguageWriter,StripeOrientationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\StripeOrientationCesiumWriter.cs,CreateReferenceAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<StripeOrientationCesiumWriter' Reference>(this' (me' value) => me.WriteReference(value)); " is 120.
Long Statement,CesiumLanguageWriter,TranslationCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\TranslationCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<TranslationCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 225.
Long Statement,CesiumLanguageWriter,VerticalOriginCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\VerticalOriginCesiumWriter.cs,CreateVerticalOriginAdaptor,The length of the statement  "            return new CesiumWriterAdaptor<VerticalOriginCesiumWriter' CesiumVerticalOrigin>(this' (me' value) => me.WriteVerticalOrigin(value)); " is 133.
Long Statement,CesiumLanguageWriter,ViewFromCesiumWriter,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ViewFromCesiumWriter.cs,CreateCartesianAdaptor,The length of the statement  "            return new CesiumInterpolatableWriterAdaptor<ViewFromCesiumWriter' Cartesian>(this' (me' value) => me.WriteCartesian(value)' (me' dates' values' startIndex' length) => me.WriteCartesian(dates' values' startIndex' length)); " is 222.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The length of the statement  "                        exception = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfMonthAndDateNotDefined' dfi.MonthDayPattern)); " is 131.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The length of the statement  "                if (ParseExact(s' dfi.GetAllDateTimePatterns()' dfi' out result' false' ref longYear' setExceptionOnError' ref exception)) " is 122.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,The length of the statement  "                        ex = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfYearMonthAndDateNotDefined' dfi.ShortDatePattern)); " is 129.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseString,The length of the statement  "                if (sPos + maxlength <= s.Length && string.Compare(s' sPos' value' 0' maxlength' StringComparison.InvariantCultureIgnoreCase) == 0) " is 131.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The length of the statement  "                            result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length); " is 172.
Long Statement,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The length of the statement  "                                        matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex]; " is 140.
Long Statement,CesiumLanguageWriter,JulianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\JulianDate.cs,ToInternationalAtomicTime,The length of the statement  "            return new JulianDate(Day' SecondsOfDay + LeapSeconds.Instance.GetTaiMinusUtc(this)' TimeStandard.InternationalAtomicTime); " is 123.
Long Statement,CesiumLanguageWriter,JulianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\JulianDate.cs,MinutesDifference,The length of the statement  "            return (endDay - startDay) * TimeConstants.MinutesPerDay + (end.SecondsOfDay - start.SecondsOfDay) / TimeConstants.SecondsPerMinute; " is 132.
Long Statement,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,DoesDayHaveLeapSecond,The length of the statement  "            LeapSecond potentialLeapSecond = new LeapSecond(new JulianDate(julianDayNumber' 43200' TimeStandard.CoordinatedUniversalTime)' 0.0); " is 132.
Long Statement,CesiumLanguageWriter,StringFormatting,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\StringFormatting.cs,ToNonExponentialNotation,The length of the statement  "                withoutDecimalSeparator = withoutDecimalSeparator + new string('0'' desiredIndexOfSeparator - withoutDecimalSeparator.Length + 1); " is 130.
Long Statement,CesiumLanguageWriter,StringFormatting,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\StringFormatting.cs,ToNonExponentialNotation,The length of the statement  "            return withoutDecimalSeparator.Substring(0' desiredIndexOfSeparator) + decimalSeparator + withoutDecimalSeparator.Substring(desiredIndexOfSeparator); " is 149.
Long Statement,CesiumLanguageWriter,UnitCartesian,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitCartesian.cs,Cross,The length of the statement  "            return new Cartesian(m_y * other.m_z - m_z * other.m_y' m_z * other.m_x - m_x * other.m_z' m_x * other.m_y - m_y * other.m_x); " is 126.
Complex Conditional,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseAmPm,The conditional expression  "!exact && ParseString(s' valuePos' num' invInfo.PMDesignator' out numParsed) ||                      dfi.PMDesignator != "" && ParseString(s' valuePos' num' dfi.PMDesignator' out numParsed)"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos]))"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "num < 2 && day != -1 || num >= 2 && dayofweek != -1"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "(year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos)"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z')"  is complex.
Complex Conditional,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The conditional expression  "rest < small_distance &&  // Negated condition 1                     unsafe_interval - rest >= ten_kappa &&  // Negated condition 2                     (rest + ten_kappa < small_distance ||  // buffer{-1} > w_high                      small_distance - rest >= rest + ten_kappa - small_distance)"  is complex.
Complex Conditional,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The conditional expression  "rest < big_distance &&                  unsafe_interval - rest >= ten_kappa &&                  (rest + ten_kappa < big_distance ||                   big_distance - rest > rest + ten_kappa - big_distance)"  is complex.
Empty Catch Block,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,TryParse,The method has an empty catch block.
Magic Number,CesiumLanguageWriter.Advanced,CesiumFormattingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumFormattingHelper.cs,StreamToDataUri,The following statement contains a magic number: using (var memoryStream = new MemoryStream())              {                  byte[] buffer = new byte[8192];                  int bytesRead;                  while ((bytesRead = stream.Read(buffer' 0' buffer.Length)) > 0)                  {                      memoryStream.Write(buffer' 0' bytesRead);                  }                    builder.Append(Convert.ToBase64String(memoryStream.GetBuffer()' 0' (int)memoryStream.Length));              }
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: for (int i = startIndex; i < last; ++i)              {                  output.WriteValue(epoch.SecondsDifference(dates[i]));                  Color value = values[i];                  output.WriteValue(value.R / 255.0);                  output.WriteValue(value.G / 255.0);                  output.WriteValue(value.B / 255.0);                  output.WriteValue(value.A / 255.0);                  output.WriteLineBreak();              }
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: for (int i = startIndex; i < last; ++i)              {                  output.WriteValue(epoch.SecondsDifference(dates[i]));                  Color value = values[i];                  output.WriteValue(value.R / 255.0);                  output.WriteValue(value.G / 255.0);                  output.WriteValue(value.B / 255.0);                  output.WriteValue(value.A / 255.0);                  output.WriteLineBreak();              }
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: for (int i = startIndex; i < last; ++i)              {                  output.WriteValue(epoch.SecondsDifference(dates[i]));                  Color value = values[i];                  output.WriteValue(value.R / 255.0);                  output.WriteValue(value.G / 255.0);                  output.WriteValue(value.B / 255.0);                  output.WriteValue(value.A / 255.0);                  output.WriteLineBreak();              }
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: for (int i = startIndex; i < last; ++i)              {                  output.WriteValue(epoch.SecondsDifference(dates[i]));                  Color value = values[i];                  output.WriteValue(value.R / 255.0);                  output.WriteValue(value.G / 255.0);                  output.WriteValue(value.B / 255.0);                  output.WriteValue(value.A / 255.0);                  output.WriteLineBreak();              }
Magic Number,CesiumLanguageWriter,Cartesian,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,Cartesian,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,Cartesian,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h1 = IntToHex((c >> 12) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h2 = IntToHex((c >> 8) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h3 = IntToHex((c >> 4) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: if (n <= 9)              {                  return (char)(n + 48);              }
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: if (n <= 9)              {                  return (char)(n + 48);              }
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: return (char)(n - 10 + 97);
Magic Number,CesiumLanguageWriter,CesiumOutputStream,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: return (char)(n - 10 + 97);
Magic Number,CesiumLanguageWriter,HashCode,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\HashCode.cs,Combine,The following statement contains a magic number: int result = 17;
Magic Number,CesiumLanguageWriter,HashCode,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\HashCode.cs,Combine,The following statement contains a magic number: foreach (int hash in hashes)              {                  result = result * 31 + hash;              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: m_hour += 12;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: if (m_hour > 23)                  m_hour -= 24;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: if (m_hour > 23)                  m_hour -= 24;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: const double ticksPerSecond = 1.0e7;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool hourInvalid = hour < 0 || hour >= 24;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool minuteInvalid = minute < 0 || minute >= 60;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool secondInvalid = second < 0 || second >= 61;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: if (second >= 60 && second < 61)              {                  //check to see if it's a valid leap second                  bool dayHasLeapSecond = LeapSeconds.Instance.DoesDayHaveLeapSecond(new YearMonthDay(year' month' day).JulianDayNumber);                  return dayHasLeapSecond && hour == 23 && minute == 59;              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: if (second >= 60 && second < 61)              {                  //check to see if it's a valid leap second                  bool dayHasLeapSecond = LeapSeconds.Instance.DoesDayHaveLeapSecond(new YearMonthDay(year' month' day).JulianDayNumber);                  return dayHasLeapSecond && hour == 23 && minute == 59;              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: if (second >= 60 && second < 61)              {                  //check to see if it's a valid leap second                  bool dayHasLeapSecond = LeapSeconds.Instance.DoesDayHaveLeapSecond(new YearMonthDay(year' month' day).JulianDayNumber);                  return dayHasLeapSecond && hour == 23 && minute == 59;              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: if (second >= 60 && second < 61)              {                  //check to see if it's a valid leap second                  bool dayHasLeapSecond = LeapSeconds.Instance.DoesDayHaveLeapSecond(new YearMonthDay(year' month' day).JulianDayNumber);                  return dayHasLeapSecond && hour == 23 && minute == 59;              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToJulianDate,The following statement contains a magic number: if (IsLeapSecond)                  julianSecondsOfDay -= 1;              else if (julianSecondsOfDay >= 43200.0)                  julianDayNumber -= 1;
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,RoundSeconds,The following statement contains a magic number: if (roundedSeconds < 60.0 || secondsDifference <= 0)              {                  return new GregorianDate(Year' Month' Day' Hour' Minute' roundedSeconds);              }
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToIso8601String,The following statement contains a magic number: return ToIso8601String(format' 15' false);
Magic Number,CesiumLanguageWriter,GregorianDate,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,BuildIso8601FormatString,The following statement contains a magic number: var formatStringBuilder = new StringBuilder(50);
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,The following statement contains a magic number: for (i = valuePos; i < digits + valuePos; i++)                  {                      char c = s[i];                      if (!char.IsDigit(c))                      {                          numParsed = -1;                          return 0;                      }                        number = number * 10 + (byte)(c - '0');                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: for (;;)                  {                      if (valuePos == s.Length)                          break;                        int numParsed;                      if (flexibleTwoPartsParsing && pos + num == 0)                      {                          bool isLetter = IsLetter(s' valuePos);                          if (isLetter)                          {                              if (s[valuePos] == 'Z')                                  numParsed = 1;                              else                                  ParseString(s' valuePos' 0' "GMT"' out numParsed);                              if (numParsed > 0 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                          }                          if (!afterTFormat && ParseAmPm(s' valuePos' 0' dfi' false' out numParsed' ref ampm))                          {                              if (IsLetter(s' valuePos + numParsed))                                  ampm = -1;                              else if (numParsed > 0)                              {                                  valuePos += numParsed;                                  continue;                              }                          }                            if (!afterTFormat && dayofweek == -1 && isLetter)                          {                              dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' false' out numParsed);                              if (dayofweek == -1)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' false' out numParsed);                              if (dayofweek != -1 && !IsLetter(s' valuePos + numParsed))                              {                                  valuePos += numParsed;                                  continue;                              }                                dayofweek = -1;                          }                            if (char.IsWhiteSpace(s[valuePos]) || s[valuePos] == ''')                          {                              valuePos += 1;                              continue;                          }                      }                        if (pos + num >= len)                      {                          if (flexibleTwoPartsParsing && num == 0)                          {                              afterTFormat = isFirstPart && firstPart[firstPart.Length - 1] == 'T';                              if (!isFirstPart && format == "")                                  break;                                pos = 0;                              if (isFirstPart)                                  format = secondPart;                              else                                  format = "";                              chars = format;                              len = chars.Length;                              isFirstPart = false;                              continue;                          }                          break;                      }                        if (chars[pos] == '\'')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '\'')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '"')                      {                          num = 1;                          while (pos + num < len)                          {                              if (chars[pos + num] == '"')                                  break;                                if (valuePos == s.Length || s[valuePos] != chars[pos + num])                                  return false;                                valuePos++;                              num++;                          }                            pos += num + 1;                          num = 0;                          continue;                      }                        if (chars[pos] == '\\')                      {                          pos += num + 1;                          num = 0;                          if (pos >= len)                              return false;                          if (s[valuePos] != chars[pos])                              return false;                            valuePos++;                          pos++;                          continue;                      }                        if (chars[pos] == '%')                      {                          pos++;                          continue;                      }                        if (char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos])))                      {                          valuePos++;                          num = 0;                            int ws = valuePos;                          while (ws < s.Length)                          {                              if (char.IsWhiteSpace(s[ws]) || s[ws] == ''')                                  ws++;                              else                                  break;                          }                          valuePos = ws;                          ws = pos;                          while (ws < chars.Length)                          {                              if (char.IsWhiteSpace(chars[ws]) || chars[ws] == ''')                                  ws++;                              else                                  break;                          }                          pos = ws;                          // A whitespace may match a '/' in the pattern.                          if (!exact && pos < chars.Length && chars[pos] == '/')                              if (!ParseDateSeparator(s' valuePos' dfi' false' out numParsed))                                  pos++;                          continue;                      }                        if ((pos + num + 1 < len) && (chars[pos + num + 1] == chars[pos + num]))                      {                          num++;                          continue;                      }                        switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                  num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }                        if (numParsed < 0)                          return false;                        valuePos += numParsed;                        if (!exact && !flexibleTwoPartsParsing)                      {                          switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }                      }                        pos = pos + num + 1;                      num = 0;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: if (ampm == 0 && hour == 12)                      hour = 0;
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: if (ampm == 1 && (!flexibleTwoPartsParsing || hour < 12))                      hour = hour + 12;
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: if (ampm == 1 && (!flexibleTwoPartsParsing || hour < 12))                      hour = hour + 12;
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: char[] buffer = new char[16];
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: int pos = 16;
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: do                  {                      buffer[--pos] = (char)('0' + digits % 10);                      digits /= 10;                      len--;                  } while (digits > 0);
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: do                  {                      buffer[--pos] = (char)('0' + digits % 10);                      digits /= 10;                      len--;                  } while (digits > 0);
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: output.Append(new string(buffer' pos' 16 - pos));
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: if (tokens.Length != 2)                  {                      // In this case we simply have no idea what this format is.                      // Defer the exception to the surrounding code                      return false;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: if (tokens[0].Length != 4 || !int.TryParse(tokens[0]' out yr4))                  {                      exception = new FormatException(string.Format(CesiumLocalization.GregorianDateStringNotRecognized' isoString));                      if (setExceptionOnError)                          return false;                      else                          throw exception;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: if (doy > 366)                  {                      exception = new FormatException(string.Format(CesiumLocalization.DayOfYearOutOfRange' isoString));                      if (setExceptionOnError)                          return false;                      else                          throw exception;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: StringBuilder result = new StringBuilder(format.Length + 10);
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: while (i < format.Length)                  {                      int tokLen;                      char ch = format[i];                        switch (ch)                      {                          //                          // Time Formats                          //                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                      if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                                  result.Append(desig);                                break;                          //                          // Date tokens                          //                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            //                          // Other                          //                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }                      i += tokLen;                  }
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,GetOffsetForIndex,The following statement contains a magic number: if (index < 0)              {                  return 10.0;              }
Magic Number,CesiumLanguageWriter,LeapSeconds,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,DoesDayHaveLeapSecond,The following statement contains a magic number: LeapSecond potentialLeapSecond = new LeapSecond(new JulianDate(julianDayNumber' 43200' TimeStandard.CoordinatedUniversalTime)' 0.0);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m12 = 2.0 * (xy + zw);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m13 = 2.0 * (xz - yw);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m21 = 2.0 * (xy - zw);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m23 = 2.0 * (yz + xw);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m31 = 2.0 * (xz + yw);
Magic Number,CesiumLanguageWriter,Matrix3By3,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m32 = 2.0 * (yz - xw);
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (matrix.M22 > factor)              {                  type = 2;                  factor = matrix.M22;              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (matrix.M33 > factor)              {                  type = 3;                  factor = matrix.M33;              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,UnitQuaternion,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: if (type == 1)              {                  m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_x);                    m_w = factor * (matrix.M23 - matrix.M32);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_x = -m_x;                      factor = -factor;                  }                    m_y = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M13 + matrix.M31);              }              else if (type == 2)              {                  m_y = 0.5 * Math.Sqrt(1.0 - matrix.M11 + matrix.M22 - matrix.M33);                  factor = 1.0 / (4.0 * m_y);                    m_w = factor * (matrix.M31 - matrix.M13);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_y = -m_y;                      factor = -factor;                  }                    m_x = factor * (matrix.M12 + matrix.M21);                  m_z = factor * (matrix.M23 + matrix.M32);              }              else if (type == 3)              {                  m_z = 0.5 * Math.Sqrt(1.0 - matrix.M11 - matrix.M22 + matrix.M33);                  factor = 1.0 / (4.0 * m_z);                    m_w = factor * (matrix.M12 - matrix.M21);                    if (m_w < 0)                  {                      m_w = -m_w;                      m_z = -m_z;                      factor = -factor;                  }                    m_x = factor * (matrix.M13 + matrix.M31);                  m_y = factor * (matrix.M23 + matrix.M32);              }              else              {                  m_w = 0.5 * Math.Sqrt(1.0 + factor);                  factor = 1.0 / (4.0 * m_w);                    m_x = factor * (matrix.M23 - matrix.M32);                  m_y = factor * (matrix.M31 - matrix.M13);                  m_z = factor * (matrix.M12 - matrix.M21);              }
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: for (m_month = 11; m_month > 0; --m_month)              {                  if (cumulativeMonthTable[m_month] < dayOfYear)                      break;              }
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int L = astronomicalJulianDayNumber + 68569;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int N = 4 * L / 146097;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int N = 4 * L / 146097;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int I = 4000 * (L + 1) / 1461001;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int I = 4000 * (L + 1) / 1461001;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int J = 80 * L / 2447;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int J = 80 * L / 2447;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_day = L - 2447 * J / 80;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_day = L - 2447 * J / 80;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = J / 11;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_month = J + 2 - 12 * L;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_month = J + 2 - 12 * L;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_year = 100 * (N - 49) + I + L;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_year = 100 * (N - 49) + I + L;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,GetAdjustedJulianDayNumber,The following statement contains a magic number: if (date.SecondsOfDay >= 43200.0)              {                  ++day;              }
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,DaysInYear,The following statement contains a magic number: return IsLeapYear(year) ? 366 : 365;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,DaysInYear,The following statement contains a magic number: return IsLeapYear(year) ? 366 : 365;
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,IsValidDate,The following statement contains a magic number: return year >= 1 && year <= 9999 &&                     month >= 1 && month <= 12 &&                     day >= 1 && day <= DaysInMonth(year' month);
Magic Number,CesiumLanguageWriter,YearMonthDay,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,IsValidDate,The following statement contains a magic number: return year >= 1 && year <= 9999 &&                     month >= 1 && month <= 12 &&                     day >= 1 && day <= DaysInMonth(year' month);
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong a = f_ >> 32;
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong c = other.f_ >> 32;
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong tmp = (bd >> 32) + (ad & kM32) + (bc & kM32);
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: tmp += 1U << 31;
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: e_ += other.e_ + 64;
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Normalize,The following statement contains a magic number: while ((f & k10MSBits) == 0)              {                  f <<= 10;                  e -= 10;              }
Magic Number,GrisuDotNet,DiyFp,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Normalize,The following statement contains a magic number: while ((f & k10MSBits) == 0)              {                  f <<= 10;                  e -= 10;              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: int exponentRepLength = decimal_rep_length + 3;
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: if (absExponent >= 10)              {                  ++exponentRepLength;                  if (absExponent >= 100)                      ++exponentRepLength;              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: if (absExponent >= 10)              {                  ++exponentRepLength;                  if (absExponent >= 100)                      ++exponentRepLength;              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: while (kappa > 0)              {                  int digit = (int)(integrals / divisor);                  buffer[length] = (char)('0' + digit);                  ++length;                  integrals %= divisor;                  kappa--;                  // Note that kappa now equals the exponent of the divisor and that the                  // invariant thus holds again.                  ulong rest =                      ((ulong)(integrals) << -one.E) + fractionals;                  // Invariant: too_high = buffer * 10^kappa + DiyFp(rest' one.e())                  // Reminder: unsafe_interval.e() == one.e()                  if (rest < unsafeIntervalF)                  {                      // Rounding down (by not emitting the remaining digits) yields a number                      // that lies within the unsafe interval.                      too_high.Subtract(ref w);                      return RoundWeed(buffer' length' too_high.F'                                       unsafeIntervalF' rest'                                       (ulong)(divisor) << -one.E' unit);                  }                  divisor /= 10;              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: Debug.Assert(one.E >= -60);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: Debug.Assert(0xFFFFFFFFFFFFFFFF / 10 >= one.F);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: while (true)              {                  fractionals *= 10;                  unit *= 10;                  unsafe_interval.F *= 10;                  // Integer division by one.                  int digit = (int)(fractionals >> -one.E);                  buffer[length] = (char)('0' + digit);                  ++length;                  fractionals &= one.F - 1;  // Modulo by one.                  kappa--;                  if (fractionals < unsafe_interval.F)                  {                      too_high.Subtract(ref w);                      return RoundWeed(buffer' length' too_high.F * unit'                                       unsafe_interval.F' fractionals' one.F' unit);                  }              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: while (true)              {                  fractionals *= 10;                  unit *= 10;                  unsafe_interval.F *= 10;                  // Integer division by one.                  int digit = (int)(fractionals >> -one.E);                  buffer[length] = (char)('0' + digit);                  ++length;                  fractionals &= one.F - 1;  // Modulo by one.                  kappa--;                  if (fractionals < unsafe_interval.F)                  {                      too_high.Subtract(ref w);                      return RoundWeed(buffer' length' too_high.F * unit'                                       unsafe_interval.F' fractionals' one.F' unit);                  }              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: while (true)              {                  fractionals *= 10;                  unit *= 10;                  unsafe_interval.F *= 10;                  // Integer division by one.                  int digit = (int)(fractionals >> -one.E);                  buffer[length] = (char)('0' + digit);                  ++length;                  fractionals &= one.F - 1;  // Modulo by one.                  kappa--;                  if (fractionals < unsafe_interval.F)                  {                      too_high.Subtract(ref w);                      return RoundWeed(buffer' length' too_high.F * unit'                                       unsafe_interval.F' fractionals' one.F' unit);                  }              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,BiggestPowerTen,The following statement contains a magic number: int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,BiggestPowerTen,The following statement contains a magic number: int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The following statement contains a magic number: return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The following statement contains a magic number: return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: Debug.Assert(exponent < 1e4);
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,Grisu,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: if (exponent >= 100)              {                  writer.Write((char)('0' + exponent / 100));                  exponent %= 100;                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else if (exponent >= 10)              {                  writer.Write((char)('0' + exponent / 10));                  exponent %= 10;                  writer.Write((char)('0' + exponent));              }              else              {                  writer.Write(exponent);              }
Magic Number,GrisuDotNet,GrisuDouble,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,UpperBoundary,The following statement contains a magic number: return new DiyFp(Significand * 2 + 1' Exponent - 1);
Magic Number,GrisuDotNet,GrisuDouble,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: while ((plusF & k10MSBits) == 0)              {                  plusF <<= 10;                  plusE -= 10;              }
Magic Number,GrisuDotNet,GrisuDouble,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: while ((plusF & k10MSBits) == 0)              {                  plusF <<= 10;                  plusE -= 10;              }
Magic Number,GrisuDotNet,GrisuDouble,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: if (significand_is_zero && vE != kDenormalExponent)              {                  // The boundary is closer. Think of v = 1000e10 and v- = 9999e9.                  // Then the boundary (== (v - v-)/2) is not just at a distance of 1e9 but                  // at a distance of 1e8.                  // The only exception is for the smallest normal: the largest denormal is                  // at the same distance as its successor.                  // Note: denormals have the same exponent as the smallest normals.                  minusF = (vF << 2) - 1;                  minusE = vE - 2;              }              else              {                  minusF = (vF << 1) - 1;                  minusE = vE - 1;              }
Magic Number,GrisuDotNet,GrisuDouble,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: if (significand_is_zero && vE != kDenormalExponent)              {                  // The boundary is closer. Think of v = 1000e10 and v- = 9999e9.                  // Then the boundary (== (v - v-)/2) is not just at a distance of 1e9 but                  // at a distance of 1e8.                  // The only exception is for the smallest normal: the largest denormal is                  // at the same distance as its successor.                  // Note: denormals have the same exponent as the smallest normals.                  minusF = (vF << 2) - 1;                  minusE = vE - 2;              }              else              {                  minusF = (vF << 1) - 1;                  minusE = vE - 1;              }
Missing Default,CesiumLanguageWriter,Parser,C:\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following switch statement is missing a default case: switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                  break;                          }
