Implementation smell,Namespace,Class,File,Method,Description
Long Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The method has 392 lines of code.
Long Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The method has 187 lines of code.
Complex Method,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,WriteEscapedString,Cyclomatic complexity of the method is 17
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,Cyclomatic complexity of the method is 26
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,Cyclomatic complexity of the method is 10
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,Cyclomatic complexity of the method is 8
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseAmPm,Cyclomatic complexity of the method is 8
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,Cyclomatic complexity of the method is 109
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GetStandardPattern,Cyclomatic complexity of the method is 15
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,Cyclomatic complexity of the method is 11
Complex Method,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,Cyclomatic complexity of the method is 42
Complex Method,CesiumLanguageWriter,Reference,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Reference.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,Cyclomatic complexity of the method is 10
Complex Method,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,Cyclomatic complexity of the method is 11
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian2,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartographicExtent,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian3,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartesian3Velocity,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitCartesian3,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteSpherical,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteBoundingRectangle,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteNearFarScalar,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteBounds,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitSpherical,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteCartographic,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgba,The method has 5 parameters. Parameters: output' red' green' blue' alpha
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgba,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The method has 5 parameters. Parameters: output' red' green' blue' alpha
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteDouble,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteInteger,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteUnitQuaternion,The method has 6 parameters. Parameters: output' propertyName' dates' values' startIndex' length
Long Parameter List,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The method has 5 parameters. Parameters: year' dayOfYear' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,RolloverTime,The method has 5 parameters. Parameters: days' hours' minutes' seconds' timeStandard
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseExact,The method has 8 parameters. Parameters: s' formats' dfi' ret' exact' longYear' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The method has 5 parameters. Parameters: s' provider' result' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseDateSeparator,The method has 5 parameters. Parameters: s' sPos' dfi' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,The method has 6 parameters. Parameters: s' valuePos' minDigits' digits' leadingzero' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseEnum,The method has 6 parameters. Parameters: s' sPos' values' invValues' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseString,The method has 5 parameters. Parameters: s' sPos' maxlength' value' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseAmPm,The method has 7 parameters. Parameters: s' valuePos' num' dfi' exact' numParsed' ampm
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseTimeSeparator,The method has 5 parameters. Parameters: s' sPos' dfi' exact' numParsed
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The method has 8 parameters. Parameters: s' firstPart' secondPart' exact' result' dfi' incompleteFormat' longYear
Long Parameter List,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The method has 5 parameters. Parameters: isoString' dfi' result' setExceptionOnError' exception
Long Parameter List,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The method has 9 parameters. Parameters: m11' m12' m13' m21' m22' m23' m31' m32' m33
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The method has 5 parameters. Parameters: w' x' y' z' magnitude
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The method has 5 parameters. Parameters: w' x' y' z' normalization
Long Parameter List,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,NormalizeCoordinates,The method has 5 parameters. Parameters: w' x' y' z' magnitude
Long Parameter List,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The method has 6 parameters. Parameters: low' w' high' buffer' length' kappa
Long Parameter List,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The method has 7 parameters. Parameters: buffer' length' distance_too_high_w' unsafe_interval' rest' ten_kappa' unit
Long Parameter List,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateDecimalRepresentation,The method has 5 parameters. Parameters: decimal_digits' length' decimal_point' digits_after_point' writer
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter PixelOffsetScaleByDistancePropertyName is 38.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,BillboardCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BillboardCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,BoxCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoxCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ClassificationTypeCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ClassificationTypeCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,ConicSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ConicSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,CorridorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CorridorCesiumWriter.cs,,The length of the parameter ExtrudedHeightReferencePropertyName is 35.
Long Identifier,CesiumLanguageWriter,CorridorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CorridorCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CorridorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CorridorCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,CustomPatternSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPatternSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,CylinderCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CylinderCesiumWriter.cs,,The length of the parameter NumberOfVerticalLinesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,CylinderCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CylinderCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,DistanceDisplayConditionCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DistanceDisplayConditionCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter ExtrudedHeightReferencePropertyName is 35.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter NumberOfVerticalLinesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,EllipseCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipseCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,EllipsoidCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\EllipsoidCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,FanCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\FanCesiumWriter.cs,,The length of the parameter PerDirectionRadiusPropertyName is 30.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter PixelOffsetScaleByDistancePropertyName is 38.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,LabelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\LabelCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter IncrementallyLoadTexturesPropertyName is 37.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,ModelCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ModelCesiumWriter.cs,,The length of the parameter NodeTransformationsPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PacketCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PacketCesiumWriter.cs,,The length of the parameter CustomPatternSensorPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PathCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PathCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter TranslucencyByDistancePropertyName is 34.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PointCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PointCesiumWriter.cs,,The length of the parameter DisableDepthTestDistancePropertyName is 36.
Long Identifier,CesiumLanguageWriter,PolygonCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolygonCesiumWriter.cs,,The length of the parameter ExtrudedHeightReferencePropertyName is 35.
Long Identifier,CesiumLanguageWriter,PolygonCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolygonCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PolygonCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolygonCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,PolylineCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolylineCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,PolylineCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PolylineCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,PositionCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,,The length of the parameter CartographicRadiansPropertyName is 31.
Long Identifier,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,,The length of the parameter CartographicDegreesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangleCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCesiumWriter.cs,,The length of the parameter ExtrudedHeightReferencePropertyName is 35.
Long Identifier,CesiumLanguageWriter,RectangleCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangleCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCesiumWriter.cs,,The length of the parameter ClassificationTypePropertyName is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowLateralSurfacesPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter LateralSurfaceMaterialPropertyName is 34.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidSurfacesPropertyName is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EllipsoidSurfaceMaterialPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEllipsoidHorizonSurfacesPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EllipsoidHorizonSurfaceMaterialPropertyName is 43.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter DomeSurfaceMaterialPropertyName is 31.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentConstraintPropertyName is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentOcclusionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentOcclusionMaterialPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter ShowEnvironmentIntersectionPropertyName is 39.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionColorPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter EnvironmentIntersectionWidthPropertyName is 40.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_showEllipsoidHorizonSurfaces is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_ellipsoidHorizonSurfaceMaterial is 33.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentOcclusionMaterial is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionColor is 30.
Long Identifier,CesiumLanguageWriter,RectangularSensorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangularSensorCesiumWriter.cs,,The length of the parameter m_environmentIntersectionWidth is 30.
Long Identifier,CesiumLanguageWriter,VectorCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\VectorCesiumWriter.cs,,The length of the parameter MinimumLengthInPixelsPropertyName is 33.
Long Identifier,CesiumLanguageWriter,WallCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\WallCesiumWriter.cs,,The length of the parameter DistanceDisplayConditionPropertyName is 36.
Long Identifier,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,,The length of the parameter s_extraDateTimePatternTemplates is 31.
Long Identifier,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,,The length of the parameter s_commonYearCumulativeMonthTable is 32.
Long Identifier,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,,The length of the parameter s_leapYearCumulativeMonthTable is 30.
Long Identifier,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,Grisu3,The length of the parameter ten_mk_minimal_binary_exponent is 30.
Long Identifier,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,Grisu3,The length of the parameter ten_mk_maximal_binary_exponent is 30.
Long Statement,CesiumLanguageWriter.Advanced,CesiumPropertyWriter<TDerived>,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumPropertyWriter.cs,WriteInterval,The length of the statement  "            Output.WriteValue(CesiumFormattingHelper.ToIso8601Interval(interval.Start' interval.Stop' Output.PrettyFormatting ? Iso8601Format.Extended : Iso8601Format.Compact)); " is 165.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateArcType,The length of the statement  "            return new CesiumArcTypeValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteArcType(value)' CreateWriteDeleteCallback<TFrom>()); " is 143.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateBoolean,The length of the statement  "            return new CesiumBooleanValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteBoolean(value)' CreateWriteDeleteCallback<TFrom>()); " is 143.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateBoundingRectangle,The length of the statement  "            return new CesiumBoundingRectangleValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteBoundingRectangle(value)' (writer' dates' values' startIndex' length) => writer.WriteBoundingRectangle(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 276.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartesian2,The length of the statement  "            return new CesiumCartesian2ValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartesian2(value)' (writer' dates' values' startIndex' length) => writer.WriteCartesian2(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 255.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartesian3,The length of the statement  "            return new CesiumCartesian3ValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartesian(value)' (writer' dates' values' startIndex' length) => writer.WriteCartesian(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 253.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartesian3Velocity,The length of the statement  "            return new CesiumCartesian3VelocityValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartesianVelocity(value)' (writer' dates' values' startIndex' length) => writer.WriteCartesianVelocity(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 277.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartesian3List,The length of the statement  "            return new CesiumCartesian3ListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartesian(value)' CreateWriteDeleteCallback<TFrom>()); " is 152.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartesian3ListOfLists,The length of the statement  "            return new CesiumCartesian3ListOfListsValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartesian(value)' CreateWriteDeleteCallback<TFrom>()); " is 159.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicRadians,The length of the statement  "            return new CesiumCartographicRadiansValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicRadians(value)' (writer' dates' values' startIndex' length) => writer.WriteCartographicRadians(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 282.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicRadiansList,The length of the statement  "            return new CesiumCartographicRadiansListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicRadians(value)' CreateWriteDeleteCallback<TFrom>()); " is 171.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicRadiansListOfLists,The length of the statement  "            return new CesiumCartographicRadiansListOfListsValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicRadians(value)' CreateWriteDeleteCallback<TFrom>()); " is 178.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicDegrees,The length of the statement  "            return new CesiumCartographicDegreesValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicDegrees(value)' (writer' dates' values' startIndex' length) => writer.WriteCartographicDegrees(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 282.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicDegreesList,The length of the statement  "            return new CesiumCartographicDegreesListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicDegrees(value)' CreateWriteDeleteCallback<TFrom>()); " is 171.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicDegreesListOfLists,The length of the statement  "            return new CesiumCartographicDegreesListOfListsValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCartographicDegrees(value)' CreateWriteDeleteCallback<TFrom>()); " is 178.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicRectangleRadians,The length of the statement  "            return new CesiumCartographicRectangleRadiansValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteWsen(value)' (writer' dates' values' startIndex' length) => writer.WriteWsen(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 261.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCartographicRectangleDegrees,The length of the statement  "            return new CesiumCartographicRectangleDegreesValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteWsenDegrees(value)' (writer' dates' values' startIndex' length) => writer.WriteWsenDegrees(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 275.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateClassificationType,The length of the statement  "            return new CesiumClassificationTypeValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteClassificationType(value)' CreateWriteDeleteCallback<TFrom>()); " is 165.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateColorBlendMode,The length of the statement  "            return new CesiumColorBlendModeValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteColorBlendMode(value)' CreateWriteDeleteCallback<TFrom>()); " is 157.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateCornerType,The length of the statement  "            return new CesiumCornerTypeValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteCornerType(value)' CreateWriteDeleteCallback<TFrom>()); " is 149.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateDistanceDisplayCondition,The length of the statement  "            return new CesiumDistanceDisplayConditionValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteDistanceDisplayCondition(value)' (writer' dates' values' startIndex' length) => writer.WriteDistanceDisplayCondition(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 297.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateDouble,The length of the statement  "            return new CesiumDoubleValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteNumber(value)' (writer' dates' values' startIndex' length) => writer.WriteNumber(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 243.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateDoubleList,The length of the statement  "            return new CesiumDoubleListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteArray(value)' CreateWriteDeleteCallback<TFrom>()); " is 144.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateHeightReference,The length of the statement  "            return new CesiumHeightReferenceValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteHeightReference(value)' CreateWriteDeleteCallback<TFrom>()); " is 159.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateHorizontalOrigin,The length of the statement  "            return new CesiumHorizontalOriginValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteHorizontalOrigin(value)' CreateWriteDeleteCallback<TFrom>()); " is 161.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateInteger,The length of the statement  "            return new CesiumIntegerValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteNumber(value)' (writer' dates' values' startIndex' length) => writer.WriteNumber(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 244.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateLabelStyle,The length of the statement  "            return new CesiumLabelStyleValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteLabelStyle(value)' CreateWriteDeleteCallback<TFrom>()); " is 149.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateNearFarScalar,The length of the statement  "            return new CesiumNearFarScalarValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteNearFarScalar(value)' (writer' dates' values' startIndex' length) => writer.WriteNearFarScalar(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 264.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateReference,The length of the statement  "            return new CesiumReferenceValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteReference(value)' CreateWriteDeleteCallback<TFrom>()); " is 147.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateReferenceList,The length of the statement  "            return new CesiumReferenceListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteReferences(value)' CreateWriteDeleteCallback<TFrom>()); " is 152.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateReferenceListOfLists,The length of the statement  "            return new CesiumReferenceListOfListsValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteReferences(value)' CreateWriteDeleteCallback<TFrom>()); " is 159.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateRgbaf,The length of the statement  "            return new CesiumRgbafValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteRgbaf(value)' (writer' dates' values' startIndex' length) => writer.WriteRgbaf(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 240.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateRgba,The length of the statement  "            return new CesiumRgbaValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteRgba(value)' (writer' dates' values' startIndex' length) => writer.WriteRgba(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 237.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateSensorVolumePortionToDisplay,The length of the statement  "            return new CesiumSensorVolumePortionToDisplayValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WritePortionToDisplay(value)' CreateWriteDeleteCallback<TFrom>()); " is 173.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateShadowMode,The length of the statement  "            return new CesiumShadowModeValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteShadowMode(value)' CreateWriteDeleteCallback<TFrom>()); " is 149.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateSpherical,The length of the statement  "            return new CesiumSphericalValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteSpherical(value)' (writer' dates' values' startIndex' length) => writer.WriteSpherical(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 252.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateSphericalList,The length of the statement  "            return new CesiumSphericalListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteSpherical(value)' CreateWriteDeleteCallback<TFrom>()); " is 151.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateFont,The length of the statement  "            return new CesiumFontValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteFont(value)' CreateWriteDeleteCallback<TFrom>()); " is 137.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateString,The length of the statement  "            return new CesiumStringValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteString(value)' CreateWriteDeleteCallback<TFrom>()); " is 141.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateStripeOrientation,The length of the statement  "            return new CesiumStripeOrientationValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteStripeOrientation(value)' CreateWriteDeleteCallback<TFrom>()); " is 163.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUnitCartesian3,The length of the statement  "            return new CesiumUnitCartesian3ValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUnitCartesian(value)' (writer' dates' values' startIndex' length) => writer.WriteUnitCartesian(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 265.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUnitCartesian3List,The length of the statement  "            return new CesiumUnitCartesian3ListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUnitCartesian(value)' CreateWriteDeleteCallback<TFrom>()); " is 160.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUnitQuaternion,The length of the statement  "            return new CesiumUnitQuaternionValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUnitQuaternion(value)' (writer' dates' values' startIndex' length) => writer.WriteUnitQuaternion(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 267.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUnitSpherical,The length of the statement  "            return new CesiumUnitSphericalValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUnitSpherical(value)' (writer' dates' values' startIndex' length) => writer.WriteUnitSpherical(dates' values' startIndex' length)' CreateWriteDeleteCallback<TFrom>()); " is 264.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUnitSphericalList,The length of the statement  "            return new CesiumUnitSphericalListValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUnitSpherical(value)' CreateWriteDeleteCallback<TFrom>()); " is 159.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateUri,The length of the statement  "            return new CesiumUriValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteUri(value)' CreateWriteDeleteCallback<TFrom>()); " is 135.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateVerticalOrigin,The length of the statement  "            return new CesiumVerticalOriginValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteVerticalOrigin(value)' CreateWriteDeleteCallback<TFrom>()); " is 157.
Long Statement,CesiumLanguageWriter.Advanced,CesiumValuePropertyAdaptors,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumValuePropertyAdaptors.cs,CreateVelocityReference,The length of the statement  "            return new CesiumVelocityReferenceValuePropertyAdaptor<TFrom>(parent' (writer' value) => writer.WriteVelocityReference(value)' CreateWriteDeleteCallback<TFrom>()); " is 163.
Long Statement,CesiumLanguageWriter,Cartesian,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Cross,The length of the statement  "            return new Cartesian(m_y * other.m_z - m_z * other.m_y' m_z * other.m_x - m_x * other.m_z' m_x * other.m_y - m_y * other.m_x); " is 126.
Long Statement,CesiumLanguageWriter,BoundingRectangleCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\BoundingRectangleCesiumWriter.cs,CreateAsBoundingRectangle,The length of the statement  "            return new Lazy<CesiumBoundingRectangleValuePropertyAdaptor<BoundingRectangleCesiumWriter>>(CreateBoundingRectangle' false); " is 124.
Long Statement,CesiumLanguageWriter,ClassificationTypeCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\ClassificationTypeCesiumWriter.cs,CreateAsClassificationType,The length of the statement  "            return new Lazy<CesiumClassificationTypeValuePropertyAdaptor<ClassificationTypeCesiumWriter>>(CreateClassificationType' false); " is 127.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsBoundingRectangle,The length of the statement  "            return new Lazy<CesiumBoundingRectangleValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateBoundingRectangle' false); " is 121.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsCartographicRadians,The length of the statement  "            return new Lazy<CesiumCartographicRadiansValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateCartographicRadians' false); " is 125.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsCartographicDegrees,The length of the statement  "            return new Lazy<CesiumCartographicDegreesValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateCartographicDegrees' false); " is 125.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsStripeOrientation,The length of the statement  "            return new Lazy<CesiumStripeOrientationValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateStripeOrientation' false); " is 121.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsWsen,The length of the statement  "            return new Lazy<CesiumCartographicRectangleRadiansValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateCartographicRectangleRadians' false); " is 143.
Long Statement,CesiumLanguageWriter,CustomPropertyCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\CustomPropertyCesiumWriter.cs,CreateAsWsenDegrees,The length of the statement  "            return new Lazy<CesiumCartographicRectangleDegreesValuePropertyAdaptor<CustomPropertyCesiumWriter>>(CreateCartographicRectangleDegrees' false); " is 143.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateAsUnitSpherical,The length of the statement  "            return new Lazy<CesiumUnitSphericalListValuePropertyAdaptor<DirectionListCesiumWriter>>(CreateUnitSphericalList' false); " is 120.
Long Statement,CesiumLanguageWriter,DirectionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DirectionListCesiumWriter.cs,CreateAsUnitCartesian,The length of the statement  "            return new Lazy<CesiumUnitCartesian3ListValuePropertyAdaptor<DirectionListCesiumWriter>>(CreateUnitCartesian3List' false); " is 122.
Long Statement,CesiumLanguageWriter,DistanceDisplayConditionCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\DistanceDisplayConditionCesiumWriter.cs,CreateAsDistanceDisplayCondition,The length of the statement  "            return new Lazy<CesiumDistanceDisplayConditionValuePropertyAdaptor<DistanceDisplayConditionCesiumWriter>>(CreateDistanceDisplayCondition' false); " is 145.
Long Statement,CesiumLanguageWriter,HorizontalOriginCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\HorizontalOriginCesiumWriter.cs,CreateAsHorizontalOrigin,The length of the statement  "            return new Lazy<CesiumHorizontalOriginValuePropertyAdaptor<HorizontalOriginCesiumWriter>>(CreateHorizontalOrigin' false); " is 121.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateAsCartographicRadians,The length of the statement  "            return new Lazy<CesiumCartographicRadiansListValuePropertyAdaptor<PositionListCesiumWriter>>(CreateCartographicRadiansList' false); " is 131.
Long Statement,CesiumLanguageWriter,PositionListCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListCesiumWriter.cs,CreateAsCartographicDegrees,The length of the statement  "            return new Lazy<CesiumCartographicDegreesListValuePropertyAdaptor<PositionListCesiumWriter>>(CreateCartographicDegreesList' false); " is 131.
Long Statement,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,CreateAsCartesian,The length of the statement  "            return new Lazy<CesiumCartesian3ListOfListsValuePropertyAdaptor<PositionListOfListsCesiumWriter>>(CreateCartesian3ListOfLists' false); " is 134.
Long Statement,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,CreateAsCartographicRadians,The length of the statement  "            return new Lazy<CesiumCartographicRadiansListOfListsValuePropertyAdaptor<PositionListOfListsCesiumWriter>>(CreateCartographicRadiansListOfLists' false); " is 152.
Long Statement,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,CreateAsCartographicDegrees,The length of the statement  "            return new Lazy<CesiumCartographicDegreesListOfListsValuePropertyAdaptor<PositionListOfListsCesiumWriter>>(CreateCartographicDegreesListOfLists' false); " is 152.
Long Statement,CesiumLanguageWriter,PositionListOfListsCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\PositionListOfListsCesiumWriter.cs,CreateAsReferences,The length of the statement  "            return new Lazy<CesiumReferenceListOfListsValuePropertyAdaptor<PositionListOfListsCesiumWriter>>(CreateReferenceListOfLists' false); " is 132.
Long Statement,CesiumLanguageWriter,RectangleCoordinatesCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCoordinatesCesiumWriter.cs,CreateAsWsen,The length of the statement  "            return new Lazy<CesiumCartographicRectangleRadiansValuePropertyAdaptor<RectangleCoordinatesCesiumWriter>>(CreateCartographicRectangleRadians' false); " is 149.
Long Statement,CesiumLanguageWriter,RectangleCoordinatesCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\RectangleCoordinatesCesiumWriter.cs,CreateAsWsenDegrees,The length of the statement  "            return new Lazy<CesiumCartographicRectangleDegreesValuePropertyAdaptor<RectangleCoordinatesCesiumWriter>>(CreateCartographicRectangleDegrees' false); " is 149.
Long Statement,CesiumLanguageWriter,SensorVolumePortionToDisplayCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\SensorVolumePortionToDisplayCesiumWriter.cs,CreateAsPortionToDisplay,The length of the statement  "            return new Lazy<CesiumSensorVolumePortionToDisplayValuePropertyAdaptor<SensorVolumePortionToDisplayCesiumWriter>>(CreateSensorVolumePortionToDisplay' false); " is 157.
Long Statement,CesiumLanguageWriter,StripeOrientationCesiumWriter,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Generated\StripeOrientationCesiumWriter.cs,CreateAsStripeOrientation,The length of the statement  "            return new Lazy<CesiumStripeOrientationValuePropertyAdaptor<StripeOrientationCesiumWriter>>(CreateStripeOrientation' false); " is 124.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The length of the statement  "                        exception = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfMonthAndDateNotDefined' dfi.MonthDayPattern)); " is 131.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,CoreParse,The length of the statement  "                if (ParseExact(s' dfi.GetAllDateTimePatterns()' dfi' out result' false' ref longYear' setExceptionOnError' ref exception)) " is 122.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,The length of the statement  "                        ex = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfYearMonthAndDateNotDefined' dfi.ShortDatePattern)); " is 129.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,The length of the statement  "                            ex = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfYearMonthAndDateNotSupported' dfi.ShortDatePattern)); " is 131.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,YearMonthDayFormats,The length of the statement  "                    ex = new FormatException(string.Format(CesiumLocalization.GregorianDateOrderOfYearMonthAndDateNotSupported' dfi.ShortDatePattern)); " is 131.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseString,The length of the statement  "                if (sPos + maxlength <= s.Length && string.Compare(s' sPos' value' 0' maxlength' StringComparison.InvariantCultureIgnoreCase) == 0) " is 131.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The length of the statement  "                            result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length); " is 172.
Long Statement,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The length of the statement  "                                        matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex]; " is 140.
Long Statement,CesiumLanguageWriter,JulianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\JulianDate.cs,ToInternationalAtomicTime,The length of the statement  "            return new JulianDate(Day' SecondsOfDay + LeapSeconds.Instance.GetTaiMinusUtc(this)' TimeStandard.InternationalAtomicTime); " is 123.
Long Statement,CesiumLanguageWriter,JulianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\JulianDate.cs,MinutesDifference,The length of the statement  "            return (endDay - startDay) * TimeConstants.MinutesPerDay + (end.SecondsOfDay - start.SecondsOfDay) / TimeConstants.SecondsPerMinute; " is 132.
Long Statement,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,DoesDayHaveLeapSecond,The length of the statement  "            LeapSecond potentialLeapSecond = new LeapSecond(new JulianDate(julianDayNumber' 43200' TimeStandard.CoordinatedUniversalTime)' 0.0); " is 132.
Long Statement,CesiumLanguageWriter,StringFormatting,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\StringFormatting.cs,ToNonExponentialNotation,The length of the statement  "                withoutDecimalSeparator = withoutDecimalSeparator + new string('0'' desiredIndexOfSeparator - withoutDecimalSeparator.Length + 1); " is 130.
Long Statement,CesiumLanguageWriter,StringFormatting,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\StringFormatting.cs,ToNonExponentialNotation,The length of the statement  "            return withoutDecimalSeparator.Substring(0' desiredIndexOfSeparator) + decimalSeparator + withoutDecimalSeparator.Substring(desiredIndexOfSeparator); " is 149.
Long Statement,CesiumLanguageWriter,UnitCartesian,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitCartesian.cs,Cross,The length of the statement  "            return new Cartesian(m_y * other.m_z - m_z * other.m_y' m_z * other.m_x - m_x * other.m_z' m_x * other.m_y - m_y * other.m_x); " is 126.
Complex Conditional,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseAmPm,The conditional expression  "!exact && ParseString(s' valuePos' num' invInfo.PMDesignator' out numParsed) ||                      dfi.PMDesignator.Length != 0 && ParseString(s' valuePos' num' dfi.PMDesignator' out numParsed)"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "char.IsWhiteSpace(s[valuePos]) ||                          s[valuePos] == ''' && (!exact && chars[pos] == '/' || char.IsWhiteSpace(chars[pos]))"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "num < 2 && day != -1 || num >= 2 && dayofweek != -1"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "(year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos)"  is complex.
Complex Conditional,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The conditional expression  "s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z')"  is complex.
Complex Conditional,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The conditional expression  "rest < small_distance &&  // Negated condition 1                     unsafe_interval - rest >= ten_kappa &&  // Negated condition 2                     (rest + ten_kappa < small_distance ||  // buffer{-1} > w_high                      small_distance - rest >= rest + ten_kappa - small_distance)"  is complex.
Complex Conditional,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The conditional expression  "rest < big_distance &&                  unsafe_interval - rest >= ten_kappa &&                  (rest + ten_kappa < big_distance ||                   big_distance - rest > rest + ten_kappa - big_distance)"  is complex.
Empty Catch Block,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,TryParse,The method has an empty catch block.
Magic Number,CesiumLanguageWriter.Advanced,CesiumFormattingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumFormattingHelper.cs,StreamToDataUri,The following statement contains a magic number: byte[] buffer = new byte[8192];
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: WriteRgbaf(output' value.R / 255.0' value.G / 255.0' value.B / 255.0' value.A / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: output.WriteValue(value.R / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: output.WriteValue(value.G / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: output.WriteValue(value.B / 255.0);
Magic Number,CesiumLanguageWriter.Advanced,CesiumWritingHelper,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Advanced\CesiumWritingHelper.cs,WriteRgbaf,The following statement contains a magic number: output.WriteValue(value.A / 255.0);
Magic Number,CesiumLanguageWriter,Cartesian,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,Cartesian,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,Cartesian,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Cartesian.cs,Rotate,The following statement contains a magic number: return new Cartesian(difference * m_x + 2.0 * (w * (m_y * rotation.Z - m_z * rotation.Y) + dot * rotation.X)'                                   difference * m_y + 2.0 * (w * (m_z * rotation.X - m_x * rotation.Z) + dot * rotation.Y)'                                   difference * m_z + 2.0 * (w * (m_x * rotation.Y - m_y * rotation.X) + dot * rotation.Z));
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h1 = IntToHex((c >> 12) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h2 = IntToHex((c >> 8) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,ToCharAsUnicode,The following statement contains a magic number: char h3 = IntToHex((c >> 4) & '\x000f');
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: return (char)(n + 48);
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: n <= 9
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: return (char)(n - 10 + 97);
Magic Number,CesiumLanguageWriter,CesiumOutputStream,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\CesiumOutputStream.cs,IntToHex,The following statement contains a magic number: return (char)(n - 10 + 97);
Magic Number,CesiumLanguageWriter,HashCode,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\HashCode.cs,Combine,The following statement contains a magic number: int result = 17;
Magic Number,CesiumLanguageWriter,HashCode,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\HashCode.cs,Combine,The following statement contains a magic number: result = result * 31 + hash;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: m_hour += 12;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: m_hour -= 24;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: m_hour > 23
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: const long ticksPerMinute = 600000000L;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,GregorianDate,The following statement contains a magic number: const double ticksPerSecond = 1.0e7;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool hourInvalid = hour < 0 || hour >= 24;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool minuteInvalid = minute < 0 || minute >= 60;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: bool secondInvalid = second < 0 || second >= 61;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: return dayHasLeapSecond && hour == 23 && minute == 59;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: return dayHasLeapSecond && hour == 23 && minute == 59;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: second >= 60 && second < 61
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,IsValid,The following statement contains a magic number: second >= 60 && second < 61
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToDateTime,The following statement contains a magic number: const long ticksPerHour = 36000000000L;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToDateTime,The following statement contains a magic number: const long ticksPerMinute = 600000000L;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToDateTime,The following statement contains a magic number: const long ticksPerSecond = 10000000L;
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,RoundSeconds,The following statement contains a magic number: roundedSeconds < 60.0 || secondsDifference <= 0
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToIso8601String,The following statement contains a magic number: return ToIso8601String(format' 15' false);
Magic Number,CesiumLanguageWriter,GregorianDate,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,BuildIso8601FormatString,The following statement contains a magic number: var formatStringBuilder = new StringBuilder(50);
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseNumber,The following statement contains a magic number: number = number * 10 + (byte)(c - '0');
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: switch (chars[pos])                      {                          case 'd':                              if (num < 2 && day != -1 || num >= 2 && dayofweek != -1)                                  return false;                              if (num == 0)                                  day = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  day = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  dayofweek = ParseEnum(s' valuePos' dfi.AbbreviatedDayNames' invInfo.AbbreviatedDayNames' exact' out numParsed);                              else                                  dayofweek = ParseEnum(s' valuePos' dfi.DayNames' invInfo.DayNames' exact' out numParsed);                              break;                          case 'M':                              if (month != -1)                                  return false;                                if (flexibleTwoPartsParsing)                              {                                  numParsed = -1;                                  if (num == 0 || num == 3)                                      month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' false' out numParsed) + 1;                                  if (num > 1 && numParsed == -1)                                      month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' false' out numParsed) + 1;                                  break;                              }                                if (num == 0)                                  month = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else if (num == 1)                                  month = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              else if (num == 2)                                  month = ParseEnum(s' valuePos' dfi.AbbreviatedMonthNames' invInfo.AbbreviatedMonthNames' exact' out numParsed) + 1;                              else                                  month = ParseEnum(s' valuePos' dfi.MonthNames' invInfo.MonthNames' exact' out numParsed) + 1;                              break;                          case 'y':                              if (year != -1)                                  return false;                                if (num == 0)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              }                              else if (num < 3)                              {                                  year = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                              }                              else                              {                                  year = (int)ParseNumber(s' valuePos' exact ? 4 : 3' 4' false' out numParsed);                                  if ((year >= 1000) && (numParsed == 4) && !longYear && (s.Length > 4 + valuePos))                                  {                                      int np;                                      int ly = (int)ParseNumber(s' valuePos' 5' 5' false' out np);                                      longYear = ly > 9999;                                  }                                    num = 3;                              }                                //FIXME: We should do use dfi.Calendat.TwoDigitYearMax                              if (numParsed <= 2)                                  year += year < 30 ? 2000 : 1900;                              break;                          case 'h':                              if (hour != -1)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour > 12)                                  return false;                              if (hour == 12)                                  hour = 0;                                break;                          case 'H':                              if (hour != -1 || !flexibleTwoPartsParsing && ampm >= 0)                                  return false;                              if (num == 0)                                  hour = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  hour = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (hour >= 24)                                  return false;                                break;                          case 'm':                              if (minute != -1)                                  return false;                              if (num == 0)                                  minute = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  minute = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                if (minute >= 60)                                  return false;                                break;                          case 's':                              if (second != -1)                                  return false;                              if (num == 0)                                  second = (int)ParseNumber(s' valuePos' 1' 2' false' out numParsed);                              else                                  second = (int)ParseNumber(s' valuePos' 1' 2' true' out numParsed);                                break;                          case 'F':                          case 'f':                              bool leadingZeros = chars[pos] == 'f';                                if (fractionalSeconds != -1)                                  return false;                              double decimalNumber = ParseNumber(s' valuePos' 0' num + 1' leadingZeros' out numParsed);                              if (numParsed == -1)                                  return false;                              fractionalSeconds = decimalNumber / Math.Pow(10.0' numParsed);                              break;                          case 't':                              if (!ParseAmPm(s' valuePos' num > 0 ? 0 : 1' dfi' exact' out numParsed' ref ampm))                                  return false;                              break;                          case ':':                              if (!ParseTimeSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                              break;                          case '/':                              if (!ParseDateSeparator(s' valuePos' dfi' exact' out numParsed))                                  return false;                                num = 0;                              break;                          default:                              if (s[valuePos] != chars[pos])                                  return false;                                num = 0;                              numParsed = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: ampm == 0 && hour == 12
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: hour = hour + 12;
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following statement contains a magic number: ampm == 1 && (!flexibleTwoPartsParsing || hour < 12)
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: char[] buffer = new char[16];
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: int pos = 16;
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: buffer[--pos] = (char)('0' + digits % 10);
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: digits /= 10;
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ZeroPad,The following statement contains a magic number: output.Append(new string(buffer' pos' 16 - pos));
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: tokens.Length != 2
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: tokens[0].Length != 4 || !int.TryParse(tokens[0]' out yr4)
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ParseIso8601DayOfYear,The following statement contains a magic number: doy > 366
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: StringBuilder result = new StringBuilder(format.Length + 10);
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,ToString,The following statement contains a magic number: switch (ch)                      {                          // Time Formats                          case 'h':                              // hour' [1' 12]                              tokLen = CountRepeat(format' i' ch);                                int hr = dt.Hour % 12;                              if (hr == 0)                                  hr = 12;                                ZeroPad(result' hr' tokLen == 1 ? 1 : 2);                              break;                          case 'H':                              // hour' [0' 23]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Hour' tokLen == 1 ? 1 : 2);                              break;                          case 'm':                              // minute' [0' 59]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' dt.Minute' tokLen == 1 ? 1 : 2);                              break;                          case 's':                              // second [0' 29]                              tokLen = CountRepeat(format' i' ch);                              ZeroPad(result' (int)dt.Second' tokLen == 1 ? 1 : 2);                              break;                          case 'F':                          case 'f':                              // fraction of second' to same number of                              // digits as there are f's                              tokLen = CountRepeat(format' i' ch);                                if (tokLen > 15)                                  throw new FormatException(CesiumLocalization.GregorianDateFormatInvalid);                                int startLen = result.Length;                                string formattedSeconds = dt.Second.ToString("R"' provider);                              formattedSeconds = StringFormatting.ToNonExponentialNotation(nfi' formattedSeconds);                              int indexOfDecimalPoint = formattedSeconds.IndexOf(nfi.NumberDecimalSeparator' StringComparison.CurrentCulture);                              if (indexOfDecimalPoint == -1)                                  indexOfDecimalPoint = formattedSeconds.Length;                              int digitsAfterDecimalPoint = formattedSeconds.Length - indexOfDecimalPoint - 1;                              if (digitsAfterDecimalPoint > tokLen)                                  formattedSeconds = formattedSeconds.Substring(0' tokLen + indexOfDecimalPoint + 1);                              else if (digitsAfterDecimalPoint < tokLen)                                  formattedSeconds = formattedSeconds.PadRight(tokLen + indexOfDecimalPoint + 1' '0');                              result.Append(formattedSeconds' indexOfDecimalPoint + nfi.NumberDecimalSeparator.Length' formattedSeconds.Length - indexOfDecimalPoint - nfi.NumberDecimalSeparator.Length);                                if (ch == 'F')                              {                                  while (result.Length > startLen && result[result.Length - 1] == '0')                                      result.Length = result.Length - 1;                                  // when the value was 0' then trim even preceding '.' (!) It is fixed character.                                  if (result.Length == startLen && startLen >= nfi.NumberDecimalSeparator.Length)                                  {                                      bool matchesSeparator = true;                                      for (int separatorIndex = 0; matchesSeparator && separatorIndex < nfi.NumberDecimalSeparator.Length; ++separatorIndex)                                      {                                          matchesSeparator = result[result.Length - nfi.NumberDecimalSeparator.Length + separatorIndex] == nfi.NumberDecimalSeparator[separatorIndex];                                      }                                        if (matchesSeparator)                                          result.Length = result.Length - nfi.NumberDecimalSeparator.Length;                                  }                              }                                break;                          case 't':                              // AM/PM. t == first char' tt+ == full                              tokLen = CountRepeat(format' i' ch);                              string desig = dt.Hour < 12 ? dfi.AMDesignator : dfi.PMDesignator;                                if (tokLen == 1)                              {                                  if (desig.Length >= 1)                                      result.Append(desig[0]);                              }                              else                              {                                  result.Append(desig);                              }                                break;                          // Date tokens                          case 'd':                              // day. d(d?) = day of month (leading 0 if two d's)                              // ddd = three leter day of week                              // dddd+ full day-of-week                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Day' tokLen == 1 ? 1 : 2);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedDayName(dt.DayOfWeek));                              else                                  result.Append(dfi.GetDayName(dt.DayOfWeek));                                break;                          case 'M':                              // Month.m(m?) = month # (with leading 0 if two mm)                              // mmm = 3 letter name                              // mmmm+ = full name                              tokLen = CountRepeat(format' i' ch);                              int month = dt.Month;                              if (tokLen <= 2)                                  ZeroPad(result' month' tokLen);                              else if (tokLen == 3)                                  result.Append(dfi.GetAbbreviatedMonthName(month));                              else                                  result.Append(dfi.GetMonthName(month));                                break;                          case 'y':                              // Year. y(y?) = two digit year' with leading 0 if yy                              // yyy+ full year with leading zeros if needed.                              tokLen = CountRepeat(format' i' ch);                                if (tokLen <= 2)                                  ZeroPad(result' dt.Year % 100' tokLen);                              else                                  ZeroPad(result' dt.Year' tokLen);                              break;                            case 'g':                              // Era name                              tokLen = CountRepeat(format' i' ch);                              result.Append(dfi.GetEraName(1));                              break;                            // Other                          case ':':                              result.Append(dfi.TimeSeparator);                              tokLen = 1;                              break;                          case '/':                              result.Append(dfi.DateSeparator);                              tokLen = 1;                              break;                          case '\'':                          case '"':                              tokLen = ParseQuotedString(format' i' result);                              break;                          case '%':                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "%"));                              if (format[i + 1] == '%')                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacter' "%%"));                                // Look for the next char                              tokLen = 1;                              break;                          case '\\':                              // C-Style escape                              if (i >= format.Length - 1)                                  throw new FormatException(string.Format(CesiumLocalization.GregorianDateInvalidCharacterAtEnd' "\\"));                                result.Append(format[i + 1]);                              tokLen = 2;                                break;                          case '.':                              // decimal separator                              result.Append(nfi.NumberDecimalSeparator);                              tokLen = nfi.NumberDecimalSeparator.Length;                              break;                          default:                              // catch all                              result.Append(ch);                              tokLen = 1;                              break;                      }
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,LeapSeconds,The following statement contains a magic number: m_leapSeconds = new List<LeapSecond>              {                  new LeapSecond(2441317.5' 10)'                  new LeapSecond(2441499.5' 11)'                  new LeapSecond(2441683.5' 12)'                  new LeapSecond(2442048.5' 13)'                  new LeapSecond(2442413.5' 14)'                  new LeapSecond(2442778.5' 15)'                  new LeapSecond(2443144.5' 16)'                  new LeapSecond(2443509.5' 17)'                  new LeapSecond(2443874.5' 18)'                  new LeapSecond(2444239.5' 19)'                  new LeapSecond(2444786.5' 20)'                  new LeapSecond(2445151.5' 21)'                  new LeapSecond(2445516.5' 22)'                  new LeapSecond(2446247.5' 23)'                  new LeapSecond(2447161.5' 24)'                  new LeapSecond(2447892.5' 25)'                  new LeapSecond(2448257.5' 26)'                  new LeapSecond(2448804.5' 27)'                  new LeapSecond(2449169.5' 28)'                  new LeapSecond(2449534.5' 29)'                  new LeapSecond(2450083.5' 30)'                  new LeapSecond(2450630.5' 31)'                  new LeapSecond(2451179.5' 32)'                  new LeapSecond(2453736.5' 33)'                  new LeapSecond(2454832.5' 34)'                  new LeapSecond(2456109.5' 35)'                  new LeapSecond(2457204.5' 36)'                  new LeapSecond(2457754.5' 37)'              };
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,GetOffsetForIndex,The following statement contains a magic number: return 10.0;
Magic Number,CesiumLanguageWriter,LeapSeconds,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\LeapSeconds.cs,DoesDayHaveLeapSecond,The following statement contains a magic number: LeapSecond potentialLeapSecond = new LeapSecond(new JulianDate(julianDayNumber' 43200' TimeStandard.CoordinatedUniversalTime)' 0.0);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m12 = 2.0 * (xy + zw);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m13 = 2.0 * (xz - yw);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m21 = 2.0 * (xy - zw);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m23 = 2.0 * (yz + xw);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m31 = 2.0 * (xz + yw);
Magic Number,CesiumLanguageWriter,Matrix3By3,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\Matrix3By3.cs,Matrix3By3,The following statement contains a magic number: m_m32 = 2.0 * (yz - xw);
Magic Number,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: type = 2;
Magic Number,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: type = 3;
Magic Number,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: m_x = 0.5 * Math.Sqrt(1.0 + matrix.M11 - matrix.M22 - matrix.M33);
Magic Number,CesiumLanguageWriter,UnitQuaternion,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\UnitQuaternion.cs,UnitQuaternion,The following statement contains a magic number: factor = 1.0 / (4.0 * m_x);
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int L = astronomicalJulianDayNumber + 68569;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int N = 4 * L / 146097;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int N = 4 * L / 146097;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - (146097 * N + 3) / 4;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int I = 4000 * (L + 1) / 1461001;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int I = 4000 * (L + 1) / 1461001;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = L - 1461 * I / 4 + 31;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int J = 80 * L / 2447;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: int J = 80 * L / 2447;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_day = L - 2447 * J / 80;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_day = L - 2447 * J / 80;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: L = J / 11;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_month = J + 2 - 12 * L;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_month = J + 2 - 12 * L;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_year = 100 * (N - 49) + I + L;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,YearMonthDay,The following statement contains a magic number: m_year = 100 * (N - 49) + I + L;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,GetAdjustedJulianDayNumber,The following statement contains a magic number: date.SecondsOfDay >= 43200.0
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,DaysInYear,The following statement contains a magic number: return IsLeapYear(year) ? 366 : 365;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,DaysInYear,The following statement contains a magic number: return IsLeapYear(year) ? 366 : 365;
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,IsValidDate,The following statement contains a magic number: return year >= 1 && year <= 9999 &&                     month >= 1 && month <= 12 &&                     day >= 1 && day <= DaysInMonth(year' month);
Magic Number,CesiumLanguageWriter,YearMonthDay,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\YearMonthDay.cs,IsValidDate,The following statement contains a magic number: return year >= 1 && year <= 9999 &&                     month >= 1 && month <= 12 &&                     day >= 1 && day <= DaysInMonth(year' month);
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong a = f_ >> 32;
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong c = other.f_ >> 32;
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong tmp = (bd >> 32) + (ad & kM32) + (bc & kM32);
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: tmp += 1U << 31;
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: ulong result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Multiply,The following statement contains a magic number: e_ += other.e_ + 64;
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Normalize,The following statement contains a magic number: f <<= 10;
Magic Number,GrisuDotNet,DiyFp,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\DiyFp.cs,Normalize,The following statement contains a magic number: e -= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: int exponentRepLength = decimal_rep_length + 2;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: absExponent >= 100
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DoubleToString,The following statement contains a magic number: absExponent >= 10
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: divisor /= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: Debug.Assert(one.E >= -60);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: Debug.Assert(0xFFFFFFFFFFFFFFFF / 10 >= one.F);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: fractionals *= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: unit *= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,DigitGen,The following statement contains a magic number: unsafe_interval.F *= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,BiggestPowerTen,The following statement contains a magic number: int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,BiggestPowerTen,The following statement contains a magic number: int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The following statement contains a magic number: return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,RoundWeed,The following statement contains a magic number: return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: Debug.Assert(exponent < 1e4);
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: writer.Write((char)('0' + exponent / 100));
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: exponent %= 100;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: writer.Write((char)('0' + exponent / 10));
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: exponent %= 10;
Magic Number,GrisuDotNet,Grisu,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\Grisu.cs,CreateExponentialRepresentation,The following statement contains a magic number: exponent >= 100
Magic Number,GrisuDotNet,GrisuDouble,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,UpperBoundary,The following statement contains a magic number: return new DiyFp(Significand * 2 + 1' Exponent - 1);
Magic Number,GrisuDotNet,GrisuDouble,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: plusF <<= 10;
Magic Number,GrisuDotNet,GrisuDouble,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: plusE -= 10;
Magic Number,GrisuDotNet,GrisuDouble,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: minusF = (vF << 2) - 1;
Magic Number,GrisuDotNet,GrisuDouble,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\grisu\GrisuDouble.cs,NormalizedBoundaries,The following statement contains a magic number: minusE = vE - 2;
Missing Default,CesiumLanguageWriter,Parser,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\CesiumLanguageWriter\GregorianDate.cs,DoParse,The following switch statement is missing a default case: switch (chars[pos])                          {                              case 'm':                              case 's':                              case 'F':                              case 'f':                              case 'z':                                  if (s.Length > valuePos && s[valuePos] == 'Z' &&                                      (pos + 1 == chars.Length || chars[pos + 1] != 'Z'))                                  {                                      valuePos++;                                  }                                    break;                          }
